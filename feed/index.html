<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Maverick</title><link>/</link><description>This is Maverick, Theme Galileo.</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png</url><title>Maverick</title><link>/</link></image><language>english</language><lastBuildDate>Fri, 14 Jan 2022 16:11:48 +0806</lastBuildDate><pubDate>Fri, 14 Jan 2022 16:11:48 +0806</pubDate><item><title>通过GPS数据反向地理信息编码得到当前位置信息</title><link>/archives/%E9%80%9A%E8%BF%87GPS%E6%95%B0%E6%8D%AE%E5%8F%8D%E5%90%91%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81%E5%BE%97%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</link><description>&lt;h1&gt;检查可用性&lt;/h1&gt;
&lt;p&gt;这属于基础知识, 不赘述, 总的来说,你的设备的支持要打开, 添加CoreLocation的framework, 引用头文件, 添加委托,然后, 好的实践是在使用前编程检查相关可用性:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (CLLocationManager *)locationManager
{
    if(!_locationManager){
        if([CLLocationManager locationServicesEnabled]){
            _locationManager = [[CLLocationManager alloc] init];
            _locationManager.delegate = self;
            _locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters;
            CLAuthorizationStatus status = [CLLocationManager authorizationStatus];
            if (status == kCLAuthorizationStatusNotDetermined) {
                NSLog(@&amp;quot; not determined&amp;quot;);
                if([_locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]){
                    [_locationManager requestAlwaysAuthorization];
                }
            }else if (status == kCLAuthorizationStatusDenied) {
                NSLog(@&amp;quot;denied&amp;quot;);
            }else if (status == kCLAuthorizationStatusRestricted) {
                NSLog(@&amp;quot;restricted&amp;quot;);
            }else if (status == kCLAuthorizationStatusAuthorizedAlways) {
                NSLog(@&amp;quot;always allowed&amp;quot;);
            }else if (status == kCLAuthorizationStatusAuthorizedWhenInUse) {
                NSLog(@&amp;quot;when in use allowed&amp;quot;);
            }else{
            }
        }else _locationManager = nil;
    }
    return _locationManager;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;kCLAuthorizationStatusNotDetermined&lt;/code&gt;状态, iOS8以后, 需要手动编辑info.plist文件, 添加两个请求用户授权时的文案, 才能正常使用, 这里觉得匪夷所思:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;NSLocationWhenInUseUsageDescription&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;请授权使用地理位置服务&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSLocationAlwaysUsageDescription&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;请授权使用地理位置服务&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上, 可随便参考网上任何&lt;a href="http://kittenyang.com/cllocationmanager/"&gt;一篇教程&lt;/a&gt;&lt;/p&gt;&lt;h1&gt;请求地理位置并反向编码&lt;/h1&gt;
&lt;p&gt;这里需要注意的是, 苹果的&lt;code&gt;CLGeocoder&lt;/code&gt; API并不允许你频繁调用, 一分钟一次为宜, 所以你千万不要&lt;code&gt;[self.locationManager startUpdatingLocation]&lt;/code&gt;, 然后在&lt;code&gt;locationManager:didChangeAuthorizationStatus:&lt;/code&gt;
方法里去decode, 因为只是为了获取城市, 精度要求不高, 并且不需要持续更新, 所以我们就不update了, 只request一次, 然后在获取位置失败的时候再手动request一次:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)locationManager:(nonnull CLLocationManager *)manager didFailWithError:(nonnull NSError *)error{
    NSLog(@&amp;quot;fail with error:\n %@&amp;quot;, error);
    [self.locationManager requestLocation];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关解释参考&lt;a href="http://stackoverflow.com/questions/17867422/kclerrordomain-error-2-after-geocoding-repeatedly-with-clgeocoder"&gt;这篇文章&lt;/a&gt;&lt;/p&gt;&lt;p&gt;#语言的问题&lt;/p&gt;&lt;p&gt;因为习惯用英文系统, 就碰到请求回来的信息是英文的原因, 这里苹果是固化起来的, 暂时不支持用参数来指定返回数据的显示语言, 借鉴&lt;a href="http://stackoverflow.com/questions/20388891/cllocationmanager-reversegeocodelocation-language"&gt;这篇文章&lt;/a&gt;的思路, 在请求前把当前语言设置保存起来, 临时改成中文, 请求结束后再修改回来:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (void)locationManager:(nonnull CLLocationManager *)manager didUpdateLocations:(nonnull NSArray *)locations{
    CLLocation *location = [locations lastObject];
    CLGeocoder *geocoder = [CLGeocoder new];
    // 修改语言为中文
    NSArray *currentLanguageArray = [[NSUserDefaults standardUserDefaults] objectForKey:@&amp;quot;AppleLanguages&amp;quot;];
    [[NSUserDefaults standardUserDefaults] setObject: [NSArray arrayWithObjects:@&amp;quot;zh_Hans&amp;quot;, nil] forKey:@&amp;quot;AppleLanguages&amp;quot;];
    [geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&amp;lt;CLPlacemark *&amp;gt; * __nullable placemarks, NSError * __nullable error) {
        // 恢复语言
        [[NSUserDefaults standardUserDefaults] setObject:currentLanguageArray forKey:@&amp;quot;AppleLanguages&amp;quot;];
        if(error){
            NSLog(@&amp;quot;reverse error:%@&amp;quot;, [error localizedDescription]);
        }else{
            if([placemarks count] &amp;gt; 0){
                CLPlacemark *mark = [placemarks firstObject];
                NSLog(@&amp;quot;%@&amp;quot;, mark);
                NSLog(@&amp;quot;城市名:%@&amp;quot;, mark.locality);
            }
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;
</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/%E9%80%9A%E8%BF%87GPS%E6%95%B0%E6%8D%AE%E5%8F%8D%E5%90%91%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81%E5%BE%97%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</guid><pubDate>Fri, 14 Jan 2022 00:00:00 +0806</pubDate></item><item><title>《Effective-Objective-C-2-0》笔记第1-2章</title><link>/archives/%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/</link><description>&lt;figure style="flex: 38.0" &gt;&lt;img loading="lazy" width="912" height="1200" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ac920d0dab7ba40befbff58ed826b587.png" /&gt;&lt;/figure&gt;&lt;blockquote&gt;
&lt;p&gt;这个书当然中文版的，也很经典，我也读过了，但是嘛，老规矩，有原版还是读一遍原版，再加上英文水平也只有那么好，有机会能多读读在就多读读吧。一共就7章，52节，200多页，并不多。
此外，因为很多名词其实我们平时直接叫的就是英文，中文版里统统都给了一个中文翻译，反而更陌生了，有种“访达”的即视感。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1&gt;Chapter 1: Accustoming Yourself to Objective-C&lt;/h1&gt;
&lt;h2&gt;Item 1: Familiarize Yourself with Objective-C’s Roots&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;messaging structure&lt;/code&gt; v.s. &lt;code&gt;function callihng&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;in messaging structure, the &lt;strong&gt;runtime&lt;/strong&gt; decides which code gets executed, while in function, the  &lt;strong&gt;compiler&lt;/strong&gt; decides.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic binding&lt;/code&gt; v.s. &lt;code&gt;virtual table&lt;/code&gt;  &amp;lt;= 多态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runtime component&lt;/code&gt; v.s. &lt;code&gt;compiler&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;含有所有让面向对象的OC能工作的 &lt;em&gt;data structures&lt;/em&gt; and &lt;em&gt;functions&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;比如，含有所有的memory-management methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新runtime component就能提升性能，而无需重新编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Objective-C is a superset of C&lt;ul&gt;
&lt;li&gt;所以语法基本类似：&lt;code&gt;NSString *str = @&amp;quot;The String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表示声明了一个变量，类型是&lt;em&gt;NSString *&lt;/em&gt;，是一个指向NSString的指针&lt;/li&gt;
&lt;li&gt;所有OC对象必须如此声明，对象内存也总是分配在heap space上&lt;ul&gt;
&lt;li&gt;这是分配到stack上：&lt;code&gt;NSString stackString&lt;/code&gt; &amp;lt;- 报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但指向这个对象的指针（&lt;strong&gt;pointer&lt;/strong&gt;）是分配在&lt;code&gt;stack frame&lt;/code&gt;里的，多个指向同一对象的指针就分配了多个内存&lt;ul&gt;
&lt;li&gt;每个内存大小就是一枚指针的大小&lt;/li&gt;
&lt;li&gt;值也是一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The memory allocated in the &lt;code&gt;heap&lt;/code&gt; has to be &lt;strong&gt;managed directly&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;OC将堆内存管理抽象了出来，&lt;code&gt;runtime&lt;/code&gt;进一步抽象成一套内存管理架构：&lt;code&gt;reference counting&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整个系统框架都要使用结构体，用对象会有额外的开销&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 2: Minimize Importing Headers in Headers&lt;/h2&gt;
&lt;p&gt;Objective-C, just like C and C++, makes use of &lt;code&gt;header files&lt;/code&gt; and implementation files.&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;forward declaring&lt;/code&gt; -&amp;gt; &lt;code&gt;@class SomeClass&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;头文件里并不知道知道一些类的实现细节，只需要知道有这么一个类就行了&lt;/li&gt;
&lt;li&gt;但是&lt;code&gt;.m&lt;/code&gt;文件里就要自行去import一次这个class了&lt;/li&gt;
&lt;li&gt;原则就是尽量延后引入头文件的时机，减少编译时间&lt;/li&gt;
&lt;li&gt;还解决了互相引用的问题&lt;/li&gt;
&lt;li&gt;引用&lt;code&gt;super class&lt;/code&gt;, &lt;code&gt;protocol&lt;/code&gt;等必须要知道细节，不能应用&lt;code&gt;forward declaring&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;所以最好把protocol单独放在一个头文件，避免无谓地引用大文件，增加编译时间&lt;/li&gt;
&lt;li&gt;但是&lt;code&gt;delegate&lt;/code&gt;放到&lt;code&gt;class-continuation category&lt;/code&gt;里面写更好（即在&lt;strong&gt;.m&lt;/strong&gt;文件里写protocol和import），无需暴露到公共头文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键词：&lt;code&gt;减小依赖&lt;/code&gt;，&lt;code&gt;缩减编译时间&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 3: Prefer Literal Syntax over the Equivalent Methods&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用字面量语法（&lt;code&gt;Literal Syntax&lt;/code&gt;）创建和使用对象&lt;/li&gt;
&lt;li&gt;字面量语法只是一个语法糖（&lt;code&gt;syntactic sugar&lt;/code&gt;），推荐使用字面量，会减少代码量，但最好知道它对应的原始方法。（但是还是会有所区别，看下例）&lt;/li&gt;
&lt;li&gt;用字面量初始数组，如果不是最后一个元素是nil，会报错，而原始的&lt;code&gt;arrayWithObjects:&lt;/code&gt;方法则会在碰到第一个nil时当成是终止参数而正常执行（只保留nil前的元素初始化数组）&lt;ul&gt;
&lt;li&gt;作者说这反而是好事，未预料到的情况成功执行比报错更可怕，抛异常能更早地发现错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只能创建Foundation框架的对象，自定义对象不行（一般也没必要）&lt;/li&gt;
&lt;li&gt;使用字面量语法创建出来的String, Array, Dict等都&lt;code&gt;immutable&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 4: Prefer Typed Constants to Preprocessor #define&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define&lt;/code&gt;本质是替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define&lt;/code&gt;出来的是没有类型信息的&lt;/li&gt;
&lt;li&gt;如果是声明在头文件中，引用了此头文件的代码都会应用此替换&lt;ul&gt;
&lt;li&gt;即使被重定义了，编译器也不会产生警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而常量就带了类型信息&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static NSString * const MyStringConstants = &amp;quot;Hello world;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意星号的位置，这里表示指针指向的是整个常量&lt;/li&gt;
&lt;li&gt;如果把星号写到const后，那表示指针就是那个常量...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义常量的位置很重要（预处理指令也一样），不打算公开的话就在&lt;code&gt;.m&lt;/code&gt;文件里定义&lt;/li&gt;
&lt;li&gt;命令也很重要&lt;/li&gt;
&lt;li&gt;否则成了全局变量，很可能”不经意“引起变量冲突/覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static const&lt;/code&gt;要一起使用，单独的&lt;code&gt;const&lt;/code&gt;会报错&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;不再是别的语言中的&lt;strong&gt;静态变量&lt;/strong&gt;，而保是一个作用域声明&lt;/li&gt;
&lt;li&gt;一个编译单元（&lt;code&gt;translation unit&lt;/code&gt;）个输出一个目标文件（&lt;code&gt;object file&lt;/code&gt;）&lt;ul&gt;
&lt;li&gt;考虑你编译一个c++文件，一个文件生成一个目标（二进制）文件，然后再链接。&lt;/li&gt;
&lt;li&gt;所以一个编译单元一般是一个&lt;code&gt;.m&lt;/code&gt;文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结合起来，&lt;code&gt;static&lt;/code&gt;就是在一个目标文件内可见&lt;/li&gt;
&lt;li&gt;如果不加&lt;code&gt;static&lt;/code&gt;，编译器会添加一个&lt;code&gt;external symbol&lt;/code&gt;（后面有详述），这样就有重定义风险了（&lt;code&gt;duplicate symbol&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后，事实上&lt;code&gt;static const&lt;/code&gt;一起用，编译器做的仍然是&lt;strong&gt;替换&lt;/strong&gt;，而没有去创建符号（但此时已经有类型信息了）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*如果需要公开，则添加到全局符号表（&lt;code&gt;global symbol table&lt;/code&gt;）中：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the header file&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EOCStringConstant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// In the implementation file&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EOCStringConstant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;VALUE&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;上面解释了&lt;code&gt;static&lt;/code&gt;，现在来解释&lt;code&gt;extern&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt;表示向编译器保证全局符号表中将会有这个符号，其实就是要编译器不要继续检查&lt;/li&gt;
&lt;li&gt;它知道链接成二进制文件后，肯定能找到这个常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所以在&lt;code&gt;.m&lt;/code&gt;文件里正常定义和赋值，在&lt;strong&gt;任意&lt;/strong&gt;&lt;code&gt;.h&lt;/code&gt;文件时给编译器打个招呼就行了&lt;/li&gt;
&lt;li&gt;命名规范：&lt;ul&gt;
&lt;li&gt;如果是限定可见域的，用&lt;code&gt;k&lt;/code&gt;开头就行了&lt;/li&gt;
&lt;li&gt;如果会公开的，那么就用函数名作前缀（系统框架都是这么做的）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;external symbol&lt;/strong&gt; V.S. &lt;strong&gt;global symbol&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;前文你已经知道了两种提升作用域的方式，区别在&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;一个是通过不对const加static（添加external symbol），&lt;/li&gt;
&lt;li&gt;一个是额外声明extern（添加到blobal symbol talbe）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Item 5: Use Enumerations for States, Options, and Status Codes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;枚举只是一种常量命名方式&lt;/li&gt;
&lt;li&gt;语法很奇葩：&lt;code&gt;enum EOCConnectionState&lt;/code&gt; state = EOCConnectionStateDisconnected;&lt;ul&gt;
&lt;li&gt;看高亮的部分，别人只要写一个type，它要连enum带名称写全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所以一般会&lt;code&gt;typedef&lt;/code&gt;一下：&lt;code&gt;typedef enum EOCConnectionState EOCConnectionState;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;现在就可以用&lt;code&gt;EOCConnectionState&lt;/code&gt;这个type来定义变量了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用enum来做选项(options)的时候，因为不是互斥的关系，选择bitwise OR operator来会直观很多（就是每一个二进制位代表一个状态）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingNone&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleLeftMargin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleWidth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleRightMargin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleTopMargin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleHeight&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;UIViewAutoresizingFlexibleBottomMargin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;figure style="flex: 66.52173913043478" &gt;&lt;img loading="lazy" width="918" height="690" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4a634eedbb41d909a0b262a8f2f437ee.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;Foundation框架定义了一些辅助宏，以便支持新的C++标准对宏定义的增强同时还能兼容老的标准: &lt;code&gt;NS_ENUM&lt;/code&gt;和&lt;code&gt;NS_OPTIONS&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;特别是c++对枚举值里的bitwise操作结果需要显式转换&lt;/li&gt;
&lt;li&gt;所以用到了&lt;strong&gt;可组合&lt;/strong&gt;的option类的枚举，最好用&lt;code&gt;NS_OPTIONS&lt;/code&gt;宏，否则用&lt;code&gt;NS_ENUM&lt;/code&gt;就够了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对enum应用&lt;code&gt;switch&lt;/code&gt;最好不要加&lt;code&gt;default&lt;/code&gt;，这样你添加了新的枚举值而忘记了处理，能及时得到错误反馈&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Chapter 2: Objects, Messaging, and the Runtime&lt;/h1&gt;
&lt;h2&gt;Item 6: Understand Properties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Properties&lt;/code&gt; are an Objective-C feature providing encapsulation of the data an object contains.&lt;ul&gt;
&lt;li&gt;stored by &lt;code&gt;instance variables&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;accessed through &lt;code&gt;accessor methods&lt;/code&gt; (getter, setter)&lt;ul&gt;
&lt;li&gt;can be written by complier automatically &amp;lt;= &lt;code&gt;autosynthesis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;introduced a &lt;code&gt;dot syntax&lt;/code&gt; to  accessing the data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看一下C++写法：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EOCPerson&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NSObject&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_someInternalData&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对象布局在编译期就确定了，所以就硬编码了每个属性在对象内存中的偏移量&lt;/li&gt;
&lt;li&gt;所以如果对象布局变化了（比如增加了实例变量），这些偏移量就会出错，必须要重新编译。&lt;ul&gt;
&lt;li&gt;如果链接代码时使用了不同版本的类定义，就会产生这种“不兼容”的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OC的解决方案是，把偏移量仍由“实例变量”存储&lt;ul&gt;
&lt;li&gt;但是交由“类对象“(class object)保管&lt;/li&gt;
&lt;li&gt;偏移量在运行期查找 -&amp;gt; 类的定义变了，偏移量也就变了（实时的）&lt;ul&gt;
&lt;li&gt;甚至可以在运行期向类中新增实例变量&lt;/li&gt;
&lt;li&gt;nonfragile Application Binary Interface(ABI)&lt;/li&gt;
&lt;li&gt;这样就可以不止在声明文件里定义实例变量，还可以在class-continuation和实现文件里面定义了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尽量不要直接访问实例变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;点语法&lt;/code&gt;访问属性&lt;ul&gt;
&lt;li&gt;编译器会转换为对存取方法的调用&lt;/li&gt;
&lt;li&gt;编译器会为属性生成相应的实例变量，并自动合成（生成相应的存取方法）&lt;ul&gt;
&lt;li&gt;编译期进行，所以你看不到实际的代码&lt;/li&gt;
&lt;li&gt;也可以手写同样的代码（这时你就可以自定义实例方法的签名了）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@dynamic&lt;/code&gt;能阻止合成 &amp;lt;= 相信运行期能找到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Property Attributes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)，读写的时候加锁&lt;/li&gt;
&lt;li&gt;读/写权限&lt;/li&gt;
&lt;li&gt;内存管理语义&lt;ul&gt;
&lt;li&gt;assign: on scalar type&lt;/li&gt;
&lt;li&gt;strong: 拥有关系，设置新值流程：retain new -&amp;gt; release old -&amp;gt; set new&lt;/li&gt;
&lt;li&gt;weak: 非拥有关系&lt;/li&gt;
&lt;li&gt;unsafe_unretained: 类似assign，但适用于对象类型（而不只有scalar type)&lt;ul&gt;
&lt;li&gt;与weak的区别在目标对象在销毁时，该属性值不会自动清空&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;copy: 类似strong，但是相比起retain，它直接是复制了一份，通常用于拥有可变类型的变量，比如&lt;code&gt;NSString *&lt;/code&gt;，可变版的string也能赋值给NSString，这就会引起赋值后值还自己变了的可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法名&lt;ul&gt;
&lt;li&gt;getter=&lt;name&gt;，需要注意的是有些bool类型的通常会设置为&lt;code&gt;isXXXX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;setter=&lt;name&gt;，但很少这么做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果自己来实现accessor methods，那么就要自己去保证这些方法符合这些attributes，比如内存管理语义为copy，那么在设置的时候就要拷贝传入的值：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;EOCPerson&lt;/span&gt; : &lt;span class="bp"&gt;NSManagedObject&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="k"&gt;@property&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;@property&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithFirstName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;lastName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// 实现文件：&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;initWithFirstName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;_firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;_lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;读写操作的原子性并不是线程安全&lt;/li&gt;
&lt;li&gt;iOS中使用同步锁开销较大&lt;/li&gt;
&lt;li&gt;实际iOS程序碰到多线程读写属性的场景也非常少&lt;/li&gt;
&lt;li&gt;所以基本上都是声明为&lt;code&gt;nonatomic&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally&lt;/h2&gt;
&lt;p&gt;在对象内部优先访问实例变量。&lt;/p&gt;&lt;p&gt;直接访问而不用点语法的影响：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;不经过消息派发，速度快（编译器生成的代码会直接访问相应的内存）&lt;/li&gt;
&lt;li&gt;不会调用setter，也绕过了相应的内存管理语义&lt;/li&gt;
&lt;li&gt;不会触发KVO&lt;/li&gt;
&lt;li&gt;没有机会在getter, setter中设置断点来调试&lt;/li&gt;
&lt;li&gt;没有机会&lt;code&gt;lazy intialization&lt;/code&gt;，而getter机制能在首次被调用到的时候才去初始化实例变量&lt;/li&gt;
&lt;li&gt;初始化和dealloc的时候总是要直接用实例变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者建议尽量在读取实例变量的时候直接访问，设置的时候用属性（会自动考虑内存管理语义）&lt;/p&gt;&lt;h2&gt;Item 8: Understand Object Equality&lt;/h2&gt;
&lt;p&gt;其实就是理解NSObject自带的&lt;code&gt;isEqual:&lt;/code&gt;方法。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;就是比指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isEqual:&lt;/code&gt;比的是&lt;code&gt;hash&lt;/code&gt;，所以自定义的类要实现equality就要自行实现这两个方法&lt;ul&gt;
&lt;li&gt;hash不同必然对象不同，但由于有hash collisions的存在，反过来并不成立&lt;/li&gt;
&lt;li&gt;尽量用对象的不可变部分来做hash&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个做hash的方法：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSUInteger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;hash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSUInteger&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstNameHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;_firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSUInteger&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastNameHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;_lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NSUInteger&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ageHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;firstNameHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lastNameHash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ageHash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Item 9: Use the Class Cluster Pattern to Hide Implementation Detail&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIButton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;buttonWithType:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UIButtonType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;作者将上述这种解释为“类族”，即它的返回值可能是各种button，但归根结底，都是&lt;code&gt;UIButton&lt;/code&gt;，就是靠着switch各种type来实例化各种子类。&lt;/li&gt;
&lt;li&gt;同时，因为OC没有abstract class，为了避免直接使用抽象基类，一般不提供init方法，并在基类相关方法里干脆抛异常&lt;/li&gt;
&lt;li&gt;这里使用&lt;code&gt;isMemberOfClass&lt;/code&gt;就要小心，它是kind，但不一定是member&lt;/li&gt;
&lt;li&gt;系统框架里有很多&lt;code&gt;class cluster&lt;/code&gt;，特别是&lt;code&gt;collection&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;所以&lt;code&gt;if([anArray class] == [NSArray class])&lt;/code&gt;是false（原因就是它是被当作“&lt;strong&gt;抽象基类&lt;/strong&gt;来设计的，实际上是隐藏在公共接口后面的某个内部类型）&lt;/li&gt;
&lt;li&gt;同样，用&lt;code&gt;isKindOfClass:&lt;/code&gt;至少能判断是在这个类族里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 10: Use Associated Objects to Attach Custom Data to Existing Classes&lt;/h2&gt;
&lt;p&gt;扩展现有类，我们可以继承，但有时候一些特殊机制创建的类却无法继承，可以通过&lt;code&gt;Associated Object&lt;/code&gt;来添加这些信息。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;以键值对来存储，所以是可以存储多个关联数据的&lt;/li&gt;
&lt;li&gt;可以指定storage policy，对应内存管理语义&lt;/li&gt;
&lt;/ul&gt;
&lt;figure style="flex: 140.1840490797546" &gt;&lt;img loading="lazy" width="914" height="326" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/820ae39c34d1147867f1dfb6f1d64de3.png" /&gt;&lt;/figure&gt;&lt;p&gt;方法:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Sets up an association of object to value with the given key and policy.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objc_setAssociatedObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objc_AssociationPolicy&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;policy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Retrieves the value for the association on object with the given key.&lt;/span&gt;
&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objc_getAssociatedObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Removes all associations against object.&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objc_removeAssociatedObjects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;书中写了一个例子，alertView的代理方法来处理按了什么键，而一个页面中如果有多个alertView，且用同一个代理对象，那么处理需要更精细（比如需要知道是哪个警告框弹的，我一般用tag）。
而如果把处理方法定义为一个block，并把它关联到UIAlertView类，那么处理逻辑就可以跟定义alertView写在一起了。&lt;/p&gt;&lt;p&gt;todo, item 11-14&lt;/p&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/%E3%80%8AEffective-Objective-C-2-0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/</guid><pubDate>Fri, 14 Jan 2022 00:00:00 +0806</pubDate></item><item><title>HMM、NER、PoS、Viterbi笔记</title><link>/archives/HMM%E3%80%81NER%E3%80%81PoS%E3%80%81Viterbi%E7%AC%94%E8%AE%B0/</link><description>&lt;p&gt;开局一句话，隐马尔可夫，就是在“溯源”，即产生你这个现象的源头在哪。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;比如你掷出的这个显示为6的骰子，是来自于六面体的还是四面体的，或是来自于普通的还是灌铅了的&lt;/li&gt;
&lt;li&gt;又比如你一句话里的某一个词，它是处于开始位置还是中间位置，或是它是一个人名还是一个地点或是一个介词&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任何一种表现形式，都有一个它的“原因”或“属性”。 现在正式开始，来自我能理解的网络资料，我的课程，以及一些思考&lt;/p&gt;&lt;p&gt;首先几个基础概念：&lt;/p&gt;&lt;h1&gt;命名实体识别(NER)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt;：人物(PER)，地点(LOC)，等
&lt;strong&gt;BIOES&lt;/strong&gt;: 开始(Begin)， 中间(Inner)， 结尾(E)，单个(Single)，其它(Other)&lt;/p&gt;&lt;p&gt;比如人名：张北京，就可以被识别为$\Rightarrow$ B-PER, I-PER, E-PER&lt;/p&gt;&lt;h1&gt;Part-of-Speech Tagging（词性标注）&lt;/h1&gt;
&lt;p&gt;词性标注是为输入文本中的每个词性标注词分配词性标记的过程。标记算法的输入是一系列(标记化的)单词和标记集，输出是一系列标记，每个标记一个。&lt;/p&gt;&lt;p&gt;标记是一项消除歧义的任务;单词是模糊的，有不止一个可能的词性(歧义)，我们的目标是为这种情况找到正确的标签。例如，book可以是动词(book that flight)，也可以是名词(hand me that book)。That可以是一个限定词(Does that flight serve dinner)，也可以是一个补语连词(I thought that your flight was earlier)。后置标记的目标是解决这些分辨率模糊，为上下文选择合适的标记&lt;/p&gt;&lt;h1&gt;Sequence model&lt;/h1&gt;
&lt;p&gt;Sequence models are central to NLP: they are models where there is some sort of &lt;code&gt;dependence through time&lt;/code&gt; between your inputs.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The classical example of a sequence model is the &lt;code&gt;Hidden Markov Model&lt;/code&gt; for &lt;strong&gt;part-of-speech tagging&lt;/strong&gt;. (词性标注)&lt;/li&gt;
&lt;li&gt;Another example is the &lt;code&gt;conditional random field&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HMM模型的典型应用是词性标注&lt;/p&gt;&lt;figure style="flex: 94.51219512195122" &gt;&lt;img loading="lazy" width="1240" height="656" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8246ff19ee962171c5d3b15abd234eec.png" /&gt;&lt;/figure&gt;&lt;p&gt;词性标注语料库是统计标注算法的关键训练(和测试)集。三个主要的标注语料库始终用于训练和测试英语词性标注器。&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;布朗语料库是1961年在美国出版的500篇不同体裁的书面文本的100万单词样本。&lt;/li&gt;
&lt;li&gt;《华尔街日报》语料库收录了1989年发表在《华尔街日报》上的100万个单词。&lt;/li&gt;
&lt;li&gt;总机语料库由1990-1991年收集的200万字电话对话组成。语料库的创建是通过在文本上运行一个自动的词性标记，然后由人工注释器手工更正每个标记。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;HMM&lt;/h1&gt;
&lt;p&gt;HMM是一个序列模型(&lt;code&gt;sequence model&lt;/code&gt;)。序列模型或序列分类器是一个模型，其工作是为序列中的每个单元分配一个标签或类，从而将一个观察序列(观察状态)映射到一个标签序列(隐藏状态)。HMM是一种概率序列模型：给定一个单位序列(单词、字母、语素、句子等等)，它计算可能的标签序列的概率分布，并选择最佳标签序列。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;3个骰子，6面体，4面体，8面体(D6, D4, D8)&lt;/li&gt;
&lt;li&gt;每次随机选出一个骰子投掷，得到一个数字&lt;/li&gt;
&lt;li&gt;共十次，得到10个数字&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;可见状态链&lt;/code&gt;：10次投掷得到10个数字(1,3,5...)$\Rightarrow$对应你看得的10个单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;隐含状态链&lt;/code&gt;：每一次投掷都有可能拿到三种骰子之一，(D6, D6, D4...) $\Rightarrow$对应为每个单词的词性&lt;/li&gt;
&lt;li&gt;转换概率（&lt;code&gt;transition probability&lt;/code&gt;）：隐含状态之间的概率($\Rightarrow$对应为语法)：&lt;ul&gt;
&lt;li&gt;每一次拿到某种骰子之后，下一次拿到三种骰子的概率（[1/3,1/3,1/3],...)&lt;/li&gt;
&lt;li&gt;或者说主动决策下一次用哪个骰子的概率[a,b,c...] (相加为1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可见状态之间没有转换概率&lt;/li&gt;
&lt;li&gt;输出概率（&lt;code&gt;emission probability&lt;/code&gt;）：隐含状态和可见状态之间的概率，比如D4下1的概率为1/4，D6下为1/6 (表现概率，激发概率，多种翻译)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure style="flex: 106.16438356164383" &gt;&lt;img loading="lazy" width="1240" height="584" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1c9b14ebecf2d171b7f511296c425412.png" /&gt;&lt;/figure&gt;&lt;p&gt;应用HMM模型时候，往往是缺失了一部分信息的，&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;有时候你知道骰子有几种，每种骰子是什么，但是不知道掷出来的骰子序列；&lt;/li&gt;
&lt;li&gt;有时候你只是看到了很多次掷骰子的结果，剩下的什么都不知道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何应用算法去估计这些缺失的信息，就成了一个很重要的问题，这也是HMM模型能做的几件事：&lt;/p&gt;&lt;h2&gt;Decoding&lt;/h2&gt;
&lt;p&gt;解码的过程就是在给出一串序列和已知HMM模型的情况下，找到最可能的隐性状态序列。&lt;/p&gt;&lt;p&gt;比如结果是：1 6 3 5 2 7 3 5 2 4, 求最可能的骰子序列&lt;/p&gt;&lt;h3&gt;Viterbi algorithm&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;掷出1的最大概率是4面体： P1(D4) = P(1|D4) * P(D4) = 1/4 * 1/3&lt;/li&gt;
&lt;li&gt;掷出6的最大概率是 P2(D6) = P(6|D6) * P(D6) = 1/6 * 1/3&lt;/li&gt;
&lt;li&gt;连续1，6的概率就成了1的概率 * 2的概率 P2(D6) = P1(D4) * P2(D6) = 1/216&lt;/li&gt;
&lt;li&gt;1,6,3 =&amp;gt; P3(D4) = P2(D6) * P(3|D4) * P(D4) = $\frac{1}{216} \cdot \frac{1}{3} \cdot \frac{1}{4}$&lt;/li&gt;
&lt;li&gt;and so on&lt;/li&gt;
&lt;li&gt;但这个例子忽略了转移概率，即P(D6|D4), P(D4|D6,D4)，或者说默认了转移概率就是1/3，即每次挑中三个骰子的机率均等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Evaluation&lt;/h2&gt;
&lt;p&gt;根据条件和序列结果求这一序列的概率是多少，比如三种骰子，投出了1，6，3的结果：&lt;/p&gt;&lt;figure style="flex: 169.86301369863014" &gt;&lt;img loading="lazy" width="1240" height="365" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/3008ce6fdd893286e56d1b7f9ad1a342.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;第1列表示第一次投掷得到1的可能性和为0.18&lt;/li&gt;
&lt;li&gt;第2列为1 6的的可能性和为0.05&lt;/li&gt;
&lt;li&gt;第3列为1 6 3的可能性和为0.03&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果远低于或远高于这个概率，必然有做过手脚的骰子。&lt;/p&gt;&lt;h2&gt;转移概率的矩阵表示&lt;/h2&gt;
&lt;p&gt;这次假定不同的骰子是用来作弊的，作弊者会根据情况来挑选骰子，这样转移概率就不可能是均等的了：&lt;/p&gt;&lt;figure style="flex: 83.33333333333333" &gt;&lt;img loading="lazy" width="500" height="300" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8259518e5781e3ce798778e8da69de85.png" /&gt;&lt;/figure&gt;&lt;p&gt;很幸运，这么复杂的概率转移图，竟然能用矩阵表达：
$A = 
\begin{bmatrix}
0.15 &amp;amp; 0.45 &amp;amp; 0.4 \
0.25 &amp;amp; 0.35 &amp;amp; 0.4 \
0.10 &amp;amp; 0.55 &amp;amp; 0.35
\end{bmatrix}
$&lt;/p&gt;&lt;p&gt;既然是3行3列，显然$A_{ij}$就是从i切换到j的概率，比如$A_{12}$ 就应该是这个人把骰子从作弊骰子1切换到2的概率。&lt;/p&gt;&lt;figure style="flex: 102.04081632653062" &gt;&lt;img loading="lazy" width="500" height="245" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/653c3cb7f8c2f3a541d170421fe489bf.png" /&gt;&lt;/figure&gt;&lt;p&gt;相应地，发射概率（即不同骰子摇出的点数的概率）也能表示为矩阵：
$B = 
\begin{bmatrix}
0.16 &amp;amp; 0.16 &amp;amp; 0.16 &amp;amp; 0.16 &amp;amp; 0.16 &amp;amp; 0.16 \
0.02 &amp;amp; 0.02 &amp;amp; 0.02 &amp;amp; 0.02 &amp;amp; 0.02 &amp;amp; 0.90 \
0.40 &amp;amp; 0.20 &amp;amp; 0.25 &amp;amp; 0.05 &amp;amp; 0.05 &amp;amp; 0.05 \
\end{bmatrix}
$&lt;/p&gt;&lt;p&gt;现在有了转移概率和发射概率，我们再来看看前面的掷出1，6，3的骰子的概率：
骰子设为D1 D2 D3, 每一轮的可能性为P1 P2 P3, 则P = P3D1 + P3D2 + P3D3 即第3轮时3种骰子能投出3的概率和&lt;/p&gt;&lt;p&gt;我来推导一下P3D1怎么来的，上面的表格是我从别人的博客里复制的，这里就不做一个一模一样的图了，我们一步步来吧：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;第一次投掷每个骰子的概率应该是隐含了各为1/3吧？(这个好像叫&amp;quot;&lt;code&gt;初始隐状态&lt;/code&gt;&amp;quot; $\pi$)&lt;/li&gt;
&lt;li&gt;P1D1 = 0.16 * 0.33, 即1/3概率拿到D1，0.16概率投出1，同理：&lt;ul&gt;
&lt;li&gt;P1D2 = 0.02 * 0.33&lt;/li&gt;
&lt;li&gt;P1D3 = 0.40 * 0.33&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P2D1 =&lt;ul&gt;
&lt;li&gt;P1D1 * $A_{00}$ * $B_{05}$ = P1D1 * 0.15 * 0.16 即P1D1前提下，乘上D1换到D1的概率，再乘上D1选出6的概率&lt;/li&gt;
&lt;li&gt;$+$&lt;/li&gt;
&lt;li&gt;P1D2 * $A_{10}$ * $B_{05}$ = P1D1 * 0.25 * 0.16 即P1D2前提下，乘上D2换到D1的概率，再乘上D1选出6的概率&lt;/li&gt;
&lt;li&gt;$+$&lt;/li&gt;
&lt;li&gt;P1D3 * $A_{20}$ * $B_{05}$ = P1D1 * 0.10 * 0.16 即P1D3前提下，乘上D3换到D1的概率，再乘上D1选出6的概率&lt;/li&gt;
&lt;li&gt;以此类推得到P2D2, P2D3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P3D2 = （&lt;em&gt;D1的概率太平均，这次换个D2来演示&lt;/em&gt;）&lt;ul&gt;
&lt;li&gt;P2D1 * $A_{01}$ * $B_{12}$ = P2D1 * 0.45 * 0.02 即P2D1前提下，乘上D1换到D2的概率，再乘上D2选出3的概率&lt;/li&gt;
&lt;li&gt;$+$&lt;/li&gt;
&lt;li&gt;P2D2 * $A_{11}$ * $B_{12}$ = P2D1 * 0.35 * 0.02 即P2D2前提下，乘上D2换到D2的概率，再乘上D2选出3的概率&lt;/li&gt;
&lt;li&gt;$+$&lt;/li&gt;
&lt;li&gt;P2D3 * $A_{21}$ * $B_{12}$ = P2D1 * 0.35 * 0.02 即P2D3前提下，乘上D3换到D2的概率，再乘上D2选出3的概率&lt;/li&gt;
&lt;li&gt;以此类推得到P3D1, P3D2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P = P3D1 + P3D2 + P3D3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
\sum_{r\in R}\prod_t^TP(v(t)|w_r(t)) | w_r(t-1))
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v: visible 可见序列&lt;/li&gt;
&lt;li&gt;w: 隐性状态序列&lt;/li&gt;
&lt;li&gt;R: 所有隐状态的可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;t-1隐状态前提下得到t的概率（转移概率）如D2换到D3的概率&lt;/li&gt;
&lt;li&gt;上一概率前提下得到v(t)的概率，如D3扔出1的概率&lt;/li&gt;
&lt;li&gt;一种隐状态下出序列的结果为累乘&lt;/li&gt;
&lt;li&gt;所有隐状态下出该序列的结果为3的累加&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单来说：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;可见序列$v(t)$的概率依赖当前$t$下的隐状态（比如是不是作弊了的骰子）$w_r(t)$&lt;ul&gt;
&lt;li&gt;得到：$P(v(t)\ \color{red}|\ w_r(t))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当前隐状态$w_r(t)$又有两个特征:&lt;ol&gt;
&lt;li&gt;由$w_r(t-1)$转换而来的: $P(v(t)|w_r(t))\color{red}{|}w_r(t-1)$&lt;/li&gt;
&lt;li&gt;$T$是链式的，概率累乘： $\color{red}{\prod_t^T}P(v(t)|w_r(t)) | w_r(t-1))$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后一步时的隐状态显然是几种之一，累加起来就是所有可能性：&lt;ul&gt;
&lt;li&gt;$\color{red}{\sum_{r\in R}}\prod_t^TP(v(t)|w_r(t)) | w_r(t-1))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;应用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;初始概率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以&lt;code&gt;BMES&lt;/code&gt;为例（参考NER），把其认为是隐状态，然后认为每个词（里的字）是由隐状态产生的。&lt;/p&gt;&lt;p&gt;即&lt;code&gt;B&lt;/code&gt;对应的字可能有“&lt;code&gt;中&lt;/code&gt;”，“&lt;code&gt;国&lt;/code&gt;”，等等，能作为词语打头的字都可能由隐状态&lt;code&gt;B&lt;/code&gt;产生，其它状态依次类推。&lt;/p&gt;&lt;p&gt;就像我们三种骰子的初始概率，完全取决于每种骰子占总数的多少一样，HHM应用到语言模型里，初始概率就是先把文字全部用&lt;code&gt;BMES&lt;/code&gt;表示，然后分别数出个数，与总数做个对比。（此时已经可以判断出&lt;code&gt;M&lt;/code&gt;和&lt;code&gt;E&lt;/code&gt;的概率只能是0了。&lt;/p&gt;&lt;ol start="2"&gt;
&lt;li&gt;转移概率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应该是4个循环吧，每次把当前状态后面跟上四个状态的情况都数出来，就是一个隐状态到其它四个状态的转移概率，四行拼到一起就是一个转移概率的矩阵，类似上面的三种骰子互相切换的矩阵。&lt;/p&gt;&lt;p&gt;也可以用字典，比如 BE BS BB BM等共16个键，两两遍历整个字符串完后，16个count就出来了，group后就能得到概率了。&lt;/p&gt;&lt;ol start="3"&gt;
&lt;li&gt;观测概率（发射概率）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个就是每一个隐状态下对应不同表面文字的概率了，比如：{s:{&amp;quot;周&amp;quot;: 0.3357, &amp;quot;爬&amp;quot;:0.00003}...}&lt;/p&gt;&lt;p&gt;要知道，三种概率里面是有很多0的，意思就是在现有的语法体系里面不可能出现的场景，比如第一个字不可能是M和E，B后面不可能跟S，B，而M后面不可能跟B，S，以及S后面不可能跟M，E等，再比如假如哪个字永远不可能是第一个字，那么它的观测概率在S里面就永远是0，等等。&lt;/p&gt;&lt;p&gt;这里要计算的话，因为隐状态是用文字推断出来的，所以这个映射关系还在，那么整理一下两个数组就能把每个隐状态能对应的文字全部映射上了。&lt;/p&gt;&lt;hr /&gt;
&lt;p&gt;以下是我课程里的笔记，理解了上面的内容，理解下面是没有任何障碍的。&lt;/p&gt;&lt;h1&gt;viterbi in NLP&lt;/h1&gt;
&lt;p&gt;$\overbrace{
  \enclose{circle}{0} 
  \xrightarrow[农]{2.5}
  \enclose{circle}{1} 
  \xrightarrow[产]{4.0}
  \enclose{circle}{2} 
}^{1.4}
\xrightarrow[物]{2.3}
\enclose{circle}{3}$&lt;/p&gt;&lt;p&gt;$\enclose{circle}{0} 
\xrightarrow[农]{2.5}
\underbrace{
  \enclose{circle}{1} 
  \xrightarrow[产]{4.0}
  \enclose{circle}{2} 
  \xrightarrow[物]{2.3}
  \enclose{circle}{3}
}_{2.1}$&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;node: $\enclose{circle}{2}$ ，圆圈，就是位置索引&lt;/li&gt;
&lt;li&gt;edge: 词， 箭头，很好理解：string[0,1] = '农'&lt;/li&gt;
&lt;li&gt;Each edge weight is a &lt;code&gt;negative log probality&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;-log(P(农)) = 2.5&lt;/li&gt;
&lt;li&gt;-log(P(产)) = 4.0&lt;/li&gt;
&lt;li&gt;-log(P(农产)) = 1.4&lt;/li&gt;
&lt;li&gt;-log(P(产物)) = 2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Each path is a segmentation for the sentence&lt;/li&gt;
&lt;li&gt;Each path weight is a sentence &lt;code&gt;unigram&lt;/code&gt; negative log probability&lt;ul&gt;
&lt;li&gt;-log(P(农产)) + -log(P(物)) = 1.4 + 2.3 = 3.7&lt;/li&gt;
&lt;li&gt;农 + 产 + 物 = 2.5 + 4.0 + 2.3 = 8.8&lt;/li&gt;
&lt;li&gt;农 + 产物 = 2.5 + 2.1 = 4.6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;two step&lt;/h2&gt;
&lt;p&gt;1.前向，从左往右，找到&lt;strong&gt;最佳路径&lt;/strong&gt;的分数
2.后向，从右往左，创建一条最佳路径&lt;/p&gt;&lt;h3&gt;forward algorithm&lt;/h3&gt;
&lt;p&gt;pseudo code&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;best_score&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ascending&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;best_score&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;∞&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;incoming&lt;/span&gt; &lt;span class="n"&gt;edge&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;
    &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;best_score&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;edgeprev_node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;best_score&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="n"&gt;best_score&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;
      &lt;span class="n"&gt;best_edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;edge&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;example:
&lt;figure style="flex: 82.65765765765765" &gt;&lt;img loading="lazy" width="734" height="444" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5aa5426eb70b4c6cd0b8c4b1dacda749.png" /&gt;&lt;/figure&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;初始节点打分0，其它节点打分为$\infty$&lt;/li&gt;
&lt;li&gt;每个节点打分由其(&lt;code&gt;incoming edge&lt;/code&gt;)(即来源箭头)和来源节点的打分构成&lt;/li&gt;
&lt;li&gt;如果有多个来源，则计算出该来源的得分，与该节点当前的得分做对比，取得分低的那个&lt;/li&gt;
&lt;li&gt;把该节点的分值和来源edge存到该节点上（edge就是词）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;简单来说，还是和之前的骰子一样，每一次算出到当前节点的最低分数的路径。&lt;/li&gt;
&lt;li&gt;上图中，我们就把e1, e2, e5选出来了，这个过程中，删除了e3, e4这几条路径&lt;/li&gt;
&lt;li&gt;best_score=(0.0, 2.5, 1.4, 3.7), best_edge = (NULL, e1, e2, e5)&lt;/li&gt;
&lt;li&gt;用字典来把Node映射上去：{0:(0.0, NULL), 1:(2.5, e1), 2:(1.4, e2), 3:(3.7, e5)}&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;backward algorithm&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;best_path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="n"&gt;next_edge&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;best_edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;best_edge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;next_edge&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;
  &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;next_edge&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;best_path&lt;/span&gt;
  &lt;span class="n"&gt;next_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;best_edge&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;next_edge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev_node&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：
&lt;figure style="flex: 102.56410256410257" &gt;&lt;img loading="lazy" width="800" height="390" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c97b27230bd42318efb72375c245c50b.png" /&gt;&lt;/figure&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;从图片可知，&lt;code&gt;path&lt;/code&gt;就是&lt;code&gt;edge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始path是空，[]&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;forward&lt;/code&gt;的结果字典里找到node 3的best_edge，就是e5 [e5]&lt;/li&gt;
&lt;li&gt;e5的来源的是node 2&lt;/li&gt;
&lt;li&gt;从字典里找到2的best_edge，是e2 [e5, e2]&lt;/li&gt;
&lt;li&gt;e2的来源是node 0&lt;/li&gt;
&lt;li&gt;0的best_edge是NULL，结束递归&lt;/li&gt;
&lt;li&gt;reverse: [e2, e5]&lt;/li&gt;
&lt;/ul&gt;
&lt;figure style="flex: 53.25581395348837" &gt;&lt;img loading="lazy" width="458" height="430" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c7650195782b845d9be6e36dac55f277.png" /&gt;&lt;/figure&gt;&lt;p&gt;这个很好理解&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;0到农，到农产，到农产物的概率，表示为0.0+ -log(p(农/农产/农产物))&lt;/li&gt;
&lt;li&gt;在农的前提下，就有农到产，和农到产物：best(1) + -log(P(产/产物))&lt;/li&gt;
&lt;li&gt;在产的前提下，就只有best(2) + -log(P(物))了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用到NLP：&lt;/p&gt;&lt;figure style="flex: 73.99193548387096" &gt;&lt;img loading="lazy" width="734" height="496" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5e643e29e4fe62ef780ba545dc3a04fb.png" /&gt;&lt;/figure&gt;&lt;p&gt;这里就是把node, egde具体了一下：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;多包了一层for-each，意思是前面的代码是处理一行的&lt;/li&gt;
&lt;li&gt;node对应是单词结尾(word_end)，其实就是一个index，前面说过了&lt;/li&gt;
&lt;li&gt;edge对应是单词(word)，前面也说过了，即&lt;code&gt;string[5,7]&lt;/code&gt;的意思&lt;/li&gt;
&lt;li&gt;score由uni-gram来计算&lt;/li&gt;
&lt;li&gt;计算上，就是找到以基准字当作单词结尾，然后前面的字跟它拼起来的所有可能性，找最低分：&lt;ul&gt;
&lt;li&gt;比如abcdefg, 如果当前是e，那么分别比较：abced, bcde, cde, de&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接上例，输出结果应该这么解读：&lt;ul&gt;
&lt;li&gt;以b为结尾的单词，最有可能的是xxx, 它的得分是，它的索引是，&lt;/li&gt;
&lt;li&gt;以c为结尾的单词，最有可能是bc或是abc，它的得分是，bc/abc的索引是(1,2)，这样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure style="flex: 90.2439024390244" &gt;&lt;img loading="lazy" width="592" height="328" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/9de76a49c53e036f86c0c2e7a950c8cd.png" /&gt;&lt;/figure&gt;&lt;ol&gt;
&lt;li&gt;显然这里已经知道edge不知道是一个词，而且是一个词的首尾边界&lt;/li&gt;
&lt;li&gt;也知道存到best_edges里面的其实就是词的位置索引&lt;/li&gt;
&lt;li&gt;反向的时候，从最后一个索引找到得分最低的词，再从这个单词向前找，一直找到&lt;ul&gt;
&lt;li&gt;所以next_edge[0]其实就是当前单词词首，[1]就是词尾&lt;/li&gt;
&lt;li&gt;所以把当前单词存进去后，向前搜索就要以next_edge[0]为字典，找对应的best_edge&lt;/li&gt;
&lt;li&gt;再从best_edge里面解析出最合适的单词的首尾索引，存到结果数组里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/HMM%E3%80%81NER%E3%80%81PoS%E3%80%81Viterbi%E7%AC%94%E8%AE%B0/</guid><pubDate>Tue, 14 Jun 2022 00:00:00 +0806</pubDate></item><item><title>cs193p_2021_笔记[2]</title><link>/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
cs193p_2021_笔记_2
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文涉及内容：&lt;code&gt;ViewModifier, Property Observers, Layout&lt;/code&gt;&lt;/p&gt;&lt;hr /&gt;
&lt;h1&gt;ViewModifier&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;.aspectRatio(2/3)&lt;/code&gt; is likely something like &lt;code&gt;.modifier(AspectModifier(2/3))&lt;/code&gt; AspectModifier can be &lt;code&gt;anything&lt;/code&gt; that conforms to the &lt;code&gt;ViewModifier&lt;/code&gt; protocol ...&lt;/p&gt;&lt;p&gt;它只有一个body方法：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;protocol&lt;/span&gt; &lt;span class="nc"&gt;ViewModifier&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;associatedtype&lt;/span&gt; &lt;span class="n"&gt;Content&lt;/span&gt; &lt;span class="c1"&gt;// this is a protocol’s version of a“don’t care” &lt;/span&gt;
    &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;body&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;represents&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;modification&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对一个view调用&lt;code&gt;.modifier&lt;/code&gt;就是把这个view传成了上述body方法的content&lt;/li&gt;
&lt;li&gt;而从&lt;code&gt;.modifer&lt;/code&gt;变成&lt;code&gt;.cardify&lt;/code&gt;，不过是用了&lt;code&gt;extension&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;extension&lt;/span&gt; &lt;span class="nc"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;cardify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isFaceUp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cardify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isFaceUp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;isFaceUp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Property Observers&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;语法长得像&lt;code&gt;computed var&lt;/code&gt;, 但完全不是一回事 （get, set之于willSet, didSet）&lt;/li&gt;
&lt;li&gt;willSet, didSet，对应newValue, oldValue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;@State&lt;/h2&gt;
&lt;p&gt;your view is &lt;strong&gt;Read Only&lt;/strong&gt;,&lt;/p&gt;&lt;p&gt;为什么？&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;因为view的生命周期足够短，基本上是不断地生成和销毁，根本不需要”被改变“&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;所以永远用&lt;code&gt;let&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以是&lt;code&gt;stateles&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的结构很简单，任何view的变化其实就是重绘。&lt;/p&gt;&lt;p&gt;仍然有些时候需要状态：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;编辑表单&lt;/li&gt;
&lt;li&gt;模态窗口或通知窗口等临时窗口&lt;/li&gt;
&lt;li&gt;动画需要追踪动画进度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;somethingTemporary&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SomeType&lt;/span&gt; &lt;span class="c1"&gt;// this can be of any type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;private 表示别人访问不到&lt;/li&gt;
&lt;li&gt;@State的的变化会在&lt;strong&gt;必要时&lt;/strong&gt;引起重绘 （相当于一个&lt;code&gt;@ObservedObject&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;view会不断销毁和重建 -&amp;gt; 指针会永远指向新的内存地址&lt;/li&gt;
&lt;li&gt;而state是在堆上分配的空间&lt;/li&gt;
&lt;li&gt;所以销毁和重建view并不会丢失state&lt;/li&gt;
&lt;li&gt;后文&lt;code&gt;property wrapper&lt;/code&gt;详述&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Layout&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;提供空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Views&lt;/code&gt;确定自身的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;提供&lt;code&gt;View&lt;/code&gt;的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;确定自身大小（等同于#2)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;HStack and VStack&lt;/h2&gt;
&lt;p&gt;横/纵向排列元素(View)，并提供“尽可能小”的空间，根据元素性质，有三种场景：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;inflexble&lt;/code&gt; view: &lt;code&gt;Image&lt;/code&gt;，fixed size&lt;/li&gt;
&lt;li&gt;slightly more flexible view: &lt;code&gt;Text&lt;/code&gt;，适应文字的合适大小&lt;/li&gt;
&lt;li&gt;very flexible view: &lt;code&gt;RoundedRectangle&lt;/code&gt;: 占满空间 -&amp;gt; 基本上&lt;code&gt;Shape&lt;/code&gt;都会有多少空间占多少&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一旦元素确定了size，多余的空间就会给下一个元素，最后&lt;code&gt;very flexible view&lt;/code&gt;平均分配剩下的空间&lt;/li&gt;
&lt;li&gt;所有元素大小确定，容器大小也就确定了，如果有&lt;code&gt;very flexible&lt;/code&gt;的，那么容易本身也是&lt;code&gt;very flexible&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;remark：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Spacer(minLength: CGFloat)&lt;/code&gt; 空格, draw nothing, 占尽可能多的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Divider()&lt;/code&gt; 画条分隔线，占尽可能小的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.layoutPriority(100)&lt;/code&gt; 用优先级来表示分配空间的顺序，默认值为0。后分配者如果没有空间了会用省略号表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HStack(alignment: .leading)&lt;/code&gt;用来控制元素的对齐&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;List, Form, OutlineGroup 其实就是 &lt;code&gt;really smart VStacks&lt;/code&gt;，即本质上就是一个纵向排列的布局。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;LazyHStack and LazyVStack&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Lazy&lt;/em&gt;的意思是如果元素对应的位置没有出现在屏幕上，就不会构建View.&lt;/li&gt;
&lt;li&gt;they also size themselves to fit their views&lt;/li&gt;
&lt;li&gt;前两条加一起，得出这个容器不会尽可能多的占用空间，即使含有very flexible的view -&amp;gt; 尽可能小的空间&lt;/li&gt;
&lt;li&gt;显然，它最多出现在&lt;code&gt;ScrollView&lt;/code&gt;里（只有在有限窗口里滚动，才有可见不可见的差别）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scrollview&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给多少空间占多少空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;LazyHGrid and LazyVGrid&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个方向view数量固定，另一个方向动态增减（scroll）的H/V stack，以竖向的&lt;code&gt;LazyVGrid&lt;/code&gt;为例：&lt;/li&gt;
&lt;li&gt;确定每行元素个数，多少行由元素总数决定&lt;/li&gt;
&lt;li&gt;或者确定元素大小，在行方向铺满后，再往下一行铺&lt;/li&gt;
&lt;li&gt;HGrid方向则是先纵向铺满，再水平铺&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ZStack&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sizes itself to fit its children&lt;/li&gt;
&lt;li&gt;can be very flexible (if one children is)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个modifier其实也是用的ZStack:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.background&lt;/code&gt;，插入一个view在底层，stack起来: &lt;code&gt;Text(&amp;quot;hello&amp;quot;).background(Rectangle().foregroundColor(.red))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.overlay&lt;/code&gt;，覆盖到表层的zstack: &lt;code&gt;Circle().overlay(Text(&amp;quot;hello&amp;quot;), alignment:.center)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;一个view是可以选择任意size的，哪怕比给它的空间更大(产生裁剪)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.aspectRatio(2/3, contentMode: .fit)&lt;/code&gt;如果是在HStack里，&lt;ul&gt;
&lt;li&gt;则是把元素横向排列后得到宽度，根据宽度计算出高度，得到元素大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.fit&lt;/code&gt;表示完整显示图片（就长边），短边部分补成黑色，&lt;code&gt;.fill&lt;/code&gt;应该是就短边，长边部分就裁剪了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;HStack&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ForEach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cards&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
        &lt;span class="n"&gt;CardView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;card&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;aspectRatio&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contentMode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foregroundColor&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;orange&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;padding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在能够分配的空间里，四边各减10 -&amp;gt; padding(10)&lt;/li&gt;
&lt;li&gt;减10后的空间里，根据aspectRation确定一个size&lt;/li&gt;
&lt;li&gt;这个size应用给CardView&lt;/li&gt;
&lt;li&gt;组合成HStack的size&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总大小就是HStack的size四边各加10&lt;/p&gt;&lt;p&gt;而View们如何知道能占多少空间？-&amp;gt; &lt;code&gt;GeometryReader&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;GeometryReader&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GeometryReader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数&lt;code&gt;geometry&lt;/code&gt;是一个&lt;code&gt;GeometryProxy&lt;/code&gt;:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;GeometryProxy&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CGSize&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;safeAreaInsets&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="n"&gt;EdgeInsets&lt;/span&gt;
    &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CoordinateSpace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CGRect&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt;表示被提供了多少的空间（by its container)&lt;/li&gt;
&lt;li&gt;并且不包含safe area（如刘海）&lt;/li&gt;
&lt;li&gt;如果需要绘制到safe area里去: &lt;code&gt;ZStack{...}.edgesIgnoringSafeArea([.top])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure style="flex: 127.6086956521739" &gt;&lt;img loading="lazy" width="1174" height="460" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/aa2a99b80008d002cfc2521af182c43d.png" /&gt;&lt;/figure&gt;&lt;p&gt;图中演示的是设置卡片字体的大小，希望尽可能地填充卡片，&lt;code&gt;geometry.size&lt;/code&gt;能给出运行时数据，而无需硬编码。&lt;/p&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/</guid><pubDate>Mon, 24 Oct 2022 01:00:00 +0806</pubDate></item><item><title>cs193p_2021笔记[3]_Animation_Transition</title><link>/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
cs193p_2021_笔记_3_Animation_Transition
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;
&lt;h1&gt;Animation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;One way to do animation is by animating a Shape.&lt;/li&gt;
&lt;li&gt;The other way to do animation is to animate Views via their &lt;code&gt;ViewModifiers&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Only &lt;code&gt;changes&lt;/code&gt; can be animated&lt;ul&gt;
&lt;li&gt;ViewModifier arguments (not all, i.e. fonts)&lt;/li&gt;
&lt;li&gt;Shapes&lt;/li&gt;
&lt;li&gt;the &lt;em&gt;existance&lt;/em&gt; of a View in the UI&lt;ul&gt;
&lt;li&gt;比如if-else和ForEach&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;You can only animate changes to Views in &lt;em&gt;containers that are already on screen&lt;/em&gt; (&lt;code&gt;CTAAOS&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个golden rule:&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;要有view modifier的属性变化&lt;/li&gt;
&lt;li&gt;要在屏幕上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;才会触发动画（其实就是上面的最后两条）&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;课程的动画例子里，用了if-else来生成view，这样导致了新生成的view不会触发动画&lt;/li&gt;
&lt;li&gt;比如点开两张牌，新点开的那张牌由于之前牌的内容并没有出现在屏幕上，导致动画没有触发&lt;/li&gt;
&lt;li&gt;所以把view的结构由if-else的生成和销毁机制，变成了透明度切换机制&lt;ul&gt;
&lt;li&gt;即正面和反面都在屏幕上，只不过透明度相反，以在视觉上要么是正面要么是反面&lt;/li&gt;
&lt;li&gt;本以为透明度为0就会销毁视图(UIKit？)，看样子并不是这样的，大胆用opacity就好了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;隐式调用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“👻&lt;/span&gt; &lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scary&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                             &lt;span class="c1"&gt;// 普通modifier, 即如果没有动画，也需要的状态（即代码也不会删）&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rotationEffect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Angle&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;degrees&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;upsideDown&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    &lt;span class="c1"&gt;// 动画modifier，即定制的动画效果，不需要动画的时候，就不需要这一行&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Animation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;easeInOut&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                         &lt;span class="c1"&gt;// 触发&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;上述所有&lt;code&gt;ViewModifier&lt;/code&gt;都会被动画&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scary, upsideDown&lt;/code&gt;等值改变时也会触发动画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隐式调用会冒泡（所以不要对一个container view做&lt;code&gt;.animation&lt;/code&gt;，还有定位的问题)&lt;/li&gt;
&lt;li&gt;animation的参数就是一个struct： duration, delay, repeat, curve...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于不能动画的modifier，看一下这个实例（上为修改前，下为修改后）
&lt;figure style="flex: 51.452991452991455" &gt;&lt;img loading="lazy" width="1204" height="1170" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4804373fb223c0a4333d720331093521.png" /&gt;&lt;/figure&gt;&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;把font设为常量，把缩放变成一个geometric effect&lt;/li&gt;
&lt;li&gt;同时也说明&lt;code&gt;.animation()&lt;/code&gt;不止作用于它前面的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;显式调用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;withAnimation&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;linear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// do something that will cause ViewModifier/Shape arguments to &lt;/span&gt;
&lt;span class="n"&gt;change&lt;/span&gt; &lt;span class="n"&gt;somewhere&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;It will appear in closures like &lt;code&gt;.onTapGesture&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;显式动画不会覆盖掉隐式动画&lt;/li&gt;
&lt;li&gt;很少有处理用户手势而不包&lt;code&gt;.withAnimation&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Transition&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;转场，主要用于view的出现和消失&lt;/li&gt;
&lt;li&gt;一对&lt;code&gt;ViewModifier&lt;/code&gt;，一个&lt;code&gt;before&lt;/code&gt;, 一个&lt;code&gt;after&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ZStack&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isFaceUp&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;RoundedRectangle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// default .transition is .opacity &lt;/span&gt;
        &lt;span class="n"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“👻&lt;/span&gt; &lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;transition&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;RoundedRectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cornerRadius&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;transition&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;identity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike .animation(), .transition() does not get redistributed to a container’s content Views. So putting .transition() on the ZStack above only works if the entire ZStack came/went.&lt;/p&gt;&lt;p&gt;(Group and ForEach do distribute .transition() to their content Views, however.)&lt;/p&gt;&lt;p&gt;意思是&lt;code&gt;.transition&lt;/code&gt;并不会向下传递，如果对&lt;code&gt;ZStack&lt;/code&gt;做转场，只会把整个容器进行转场而不是里面的view（见实例二）&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;转场只是一个声明，并没有触发动画（其实就是设置了&lt;code&gt;ViewModifier&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;所以转场没有隐式调用&lt;/li&gt;
&lt;li&gt;只对CTAAOS有用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;.onAppear&lt;/code&gt;或&lt;code&gt;.onDisappear&lt;/code&gt;时，container必然是在屏幕上的，所以这是一个写&lt;code&gt;.transition&lt;/code&gt;的好地方（记得要&lt;code&gt;withAnimation&lt;/code&gt;)&lt;/p&gt;&lt;p&gt;built-in transitions:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;AnyTransition.opacity: 通过&lt;code&gt;.opacity&lt;/code&gt; modifier来实现淡入淡出&lt;/li&gt;
&lt;li&gt;AnyTransition.scale: 通过&lt;code&gt;.frame&lt;/code&gt; modifier来实现缩放&lt;/li&gt;
&lt;li&gt;AnyTransition.offset(CGSize): 通过&lt;code&gt;.offset&lt;/code&gt;来实现移动&lt;/li&gt;
&lt;li&gt;AnyTransition.modifier(active:identity:): 你提供两个&lt;code&gt;ViewModifier&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过&lt;code&gt;AnyTransition.animation&lt;/code&gt;(Animation`)来定制动画细节：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transition&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;opacity&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;animation&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;linear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;duration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;动画机制&lt;/h1&gt;
&lt;p&gt;其实就是给出一系列的数据点，系统会根据这些数据点把时间切分，你给的数据点越多，切的时间块也就越多，而且系统会根据你的线性函数来决定是平均还是怎样去切分这些时间块：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;the animation system divides the animation duration up into little pieces.&lt;/li&gt;
&lt;li&gt;The animation system then tells the Shape/ViewModifier the current piece it should show.&lt;/li&gt;
&lt;li&gt;And the Shape/ViewModifier makes sure that its code always reflects that.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统通知变量当前的值，UI根据这个值实时绘制当前的View，不断销毁重建，就是动画的过程。&lt;/p&gt;&lt;p&gt;系统是用一个变量来通知这个进度的：&lt;code&gt;Animatable&lt;/code&gt; protocol的唯一成员变量：&lt;code&gt;animatableData&lt;/code&gt;:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;animatableData&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kr"&gt;Type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Type只需要满足&lt;code&gt;VectorArithmetic&lt;/code&gt;协议，其实就是一个可以被细分的值，基本上是Float, Double, CGFloat，以及&lt;code&gt;AnimatablePair&lt;/code&gt;(其实就是两个&lt;code&gt;VectorArithmetic&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;想要支持动画的&lt;code&gt;Shape&lt;/code&gt;, &lt;code&gt;ViewModifier&lt;/code&gt;，只需要实现&lt;code&gt;Animatable&lt;/code&gt;协议即可（即提供一个&lt;code&gt;animatableData&lt;/code&gt;属性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because it’s communicating both ways, this animatableData is a &lt;code&gt;read-write&lt;/code&gt; var.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;setting&lt;/code&gt; of this var is the animation system telling the Shape/VM which piece to draw.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;getting&lt;/code&gt; of this var is the animation system getting the &lt;code&gt;start/end&lt;/code&gt; points of an animation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例一&lt;/strong&gt;&lt;/p&gt;&lt;figure style="flex: 73.625" &gt;&lt;img loading="lazy" width="1178" height="800" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/10d0bb779b10383a36d23d581f2fadb9.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;view modifier里面有一个变量&lt;code&gt;rotation&lt;/code&gt;（ZStack, content, rotation3DEffect)&lt;/li&gt;
&lt;li&gt;那么外层在&lt;code&gt;withAnimation{}&lt;/code&gt;的时候，我们是期望rotation的值能动起来的&lt;ul&gt;
&lt;li&gt;内置的viewmodifier当然会自己动，如&lt;code&gt;opacity&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;那么我们首先就要让&lt;code&gt;Cardify&lt;/code&gt; conform to &lt;code&gt;Animatable&lt;/code&gt;（例子中的AnimatableModifer = Animatable + ViewModifer)&lt;/li&gt;
&lt;li&gt;然后我们就要实现&lt;code&gt;animatableData&lt;/code&gt;, 因为系统事实上就是不断去更新这个data值&lt;/li&gt;
&lt;li&gt;教材里把它进行了封装（当然你也可以直接用它），这只是思维方式上的区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animatedData&lt;/code&gt;会随时间变化，自然会不断invalidate view，然后rebuild view，动画就产生了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例二&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;课程里有这么个需求：卡片由&lt;code&gt;LazyVGrid&lt;/code&gt;提供布局，且卡片出现和消失的时候都要有动画。&lt;/p&gt;&lt;p&gt;出现和消失？那当然就是&lt;code&gt;Transition&lt;/code&gt;的事了:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AnyTransition&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asymmetric&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insertion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                         &lt;span class="n"&gt;removal&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opacity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行时发现消失的时候有动画，出现的动画却没有。原因是&lt;code&gt;transition&lt;/code&gt;只会在&lt;em&gt;出现和消失&lt;/em&gt;时触发，而我们的卡片是包在grid容器里的，所以grid出现在屏幕上的时候，就带着卡片一起出现了，transition并不会向下传递（前文也已经说过了，这里刚好印证）。&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;所以解决方法当然可以“延迟”呈现这些卡片&lt;/li&gt;
&lt;li&gt;课程里用了另一种方法，机制当然也是延迟，但不是那么地直白：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure style="flex: 82.95774647887323" &gt;&lt;img loading="lazy" width="1178" height="710" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e7e3ef2ac16296fabf73162c1fc678fa.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;就是利用了&lt;code&gt;.onAppear&lt;/code&gt;来阻断容器和卡片的连续生成，而改用容器呈现后，再逐个“添加”的方式，让每一张卡片都有一个单独出现的机会&lt;/li&gt;
&lt;li&gt;同时也必须利用&lt;code&gt;@State&lt;/code&gt;, 让每添加一张卡片都会invalidate view一次&lt;/li&gt;
&lt;li&gt;也能看出，animate能animate的就是属性和transition&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，课程最后改成了“发牌”的机制，手动添加卡片，彻底阻断了卡片和容器一起出现的场景。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这就带我们来到了实例三，同一个view在不同容器间的动画，怎么计算各自尺度下同一个view的位置：&lt;code&gt;matchedGeometryEffect&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;实例三&lt;/strong&gt;&lt;/p&gt;&lt;figure style="flex: 73.45679012345678" &gt;&lt;img loading="lazy" width="1190" height="810" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/08935bf9006d072875c203895aff17b7.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;想要有牌一张张发出去的效果，自然会想到添加延时&lt;/li&gt;
&lt;li&gt;实现成了同时做动画，只不过越到后面的牌，延时越长（动作越慢），而不是我们想象的先后触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了让不同的牌发出去时有立体效果，还以index为依据设置了&lt;code&gt;zIndex&lt;/code&gt;，最终效果：&lt;/p&gt;&lt;figure style="flex: 35.714285714285715" &gt;&lt;img loading="lazy" width="220" height="308" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/72b4116eb1e49a3b1eaa9097a2890b60.jpg" /&gt;&lt;/figure&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/</guid><pubDate>Mon, 24 Oct 2022 02:00:00 +0806</pubDate></item><item><title>cs193p_2021笔记[4]_Color_Image_Gesture</title><link>/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
cs193p_2021_笔记_4_Color_Image_Gesture
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;p&gt;--&lt;/p&gt;&lt;h1&gt;Color, UIColor &amp;amp; CGColor&lt;/h1&gt;
&lt;p&gt;Color:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Is a color-specifier, e.g., &lt;code&gt;.foregroundColor(Color.green)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Can also act like a &lt;code&gt;ShapeStyle&lt;/code&gt;, e.g., &lt;code&gt;.fill(Color.blue)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Can also act like a &lt;code&gt;View&lt;/code&gt;, e.g., Color.white can appear &lt;code&gt;wherever&lt;/code&gt; a View can appear.（可以当作view）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UIColor:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Is used to &lt;code&gt;manipulate&lt;/code&gt; colors.（主打操控）&lt;/li&gt;
&lt;li&gt;Also has many &lt;code&gt;more&lt;/code&gt; built-in &lt;code&gt;colors&lt;/code&gt; than &lt;code&gt;Color&lt;/code&gt;, including “system-related” colors.(颜色更多)&lt;/li&gt;
&lt;li&gt;Can be interrogated and can convert between color spaces.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, you can get the RGBA values from a UIColor.
Once you have desired UIColor, employ &lt;code&gt;Color(uiColor:)&lt;/code&gt; to use it in one of the roles above.&lt;/p&gt;&lt;p&gt;CGColor:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The fundamental color representation in the Core Graphics drawing system&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color.cgColor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Image V.S. UIImage&lt;/h1&gt;
&lt;p&gt;Image:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Primarily serves as a View.(主要功能是View)&lt;/li&gt;
&lt;li&gt;Is &lt;code&gt;not&lt;/code&gt; a type for vars that &lt;code&gt;hold an image&lt;/code&gt; (i.e. a jpeg or gif or some such). That’s UIImage.&lt;/li&gt;
&lt;li&gt;Access images in your Assets.xcassets (in Xcode) by name using &lt;code&gt;Image(_ name: String)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Also, many, many system images available via &lt;code&gt;Image(systemName:)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;You can control the size of system images with &lt;code&gt;.imageScale()&lt;/code&gt; View modifier.&lt;/li&gt;
&lt;li&gt;System images also are affected by the .font modifier.&lt;/li&gt;
&lt;li&gt;System images are also very useful &lt;code&gt;as masks&lt;/code&gt; (for gradients, for example).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UIImage&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Is the type for actually &lt;code&gt;creating/manipulating&lt;/code&gt; images and &lt;code&gt;storing&lt;/code&gt; in vars.&lt;/li&gt;
&lt;li&gt;Very powerful representation of an image.&lt;/li&gt;
&lt;li&gt;Multiple file formats, transformation primitives, animated images, etc.&lt;/li&gt;
&lt;li&gt;Once you have the UIImage you want, use Image(uiImage:) to display it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Multithreading&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;多线程其实并不是同时运行，而是前后台非常快速地切换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt;只是有顺序执行的代码，封装了&lt;code&gt;threading&lt;/code&gt;的应用&lt;/li&gt;
&lt;li&gt;这些“代码”用&lt;code&gt;closure&lt;/code&gt;来传递&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main queue&lt;/strong&gt;唯一能操作UI的线程&lt;ul&gt;
&lt;li&gt;主线程是单线程，所以不能执行异步代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;background queues&lt;/strong&gt;执行任意：&lt;em&gt;long-lived, non-UI&lt;/em&gt; tasks&lt;ul&gt;
&lt;li&gt;可以并行运行(running in parallel) -&amp;gt; even with main UI queue&lt;/li&gt;
&lt;li&gt;可以手动设置优先级，服务质量(&lt;code&gt;QoS&lt;/code&gt;)等&lt;/li&gt;
&lt;li&gt;优先级永远不可能超过main queue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;base API: GCD (&lt;code&gt;Grand Central Dispatch&lt;/code&gt;)&lt;ol&gt;
&lt;li&gt;getting access to a queue&lt;/li&gt;
&lt;li&gt;plopping a block of code on a queue&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A: Creating a Queue&lt;/p&gt;&lt;p&gt;There are numerous ways to create a queue, but we’re only going to look at two ...&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="c1"&gt;// the queue where all UI code must be posted&lt;/span&gt;
&lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;global&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;qos&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QoS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// a non-UI queue with a certain quality of service qos (quality of service) is one of the following ...&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;userInteractive&lt;/span&gt;    &lt;span class="c1"&gt;// do this fast, the UI depends on it!&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;userInitiated&lt;/span&gt;  &lt;span class="c1"&gt;// the user just asked to do this, so do it now&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;utility&lt;/span&gt;    &lt;span class="c1"&gt;// this needs to happen, but the user didn’t just ask for it&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;background&lt;/span&gt; &lt;span class="c1"&gt;// maintenance tasks (cleanups, etc.)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B: Plopping a Closure onto a Queue&lt;/p&gt;&lt;p&gt;There are two basic ways to add a closure to a queue ...&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;queue&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="c1"&gt;//or&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;queue&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;global&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;qos&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; 
&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* code to execute on queue */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* code to execute on queue */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主线程里永远不要&lt;code&gt;.sync&lt;/code&gt;, 那样会阻塞UI&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;userInitiated&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 耗时代码&lt;/span&gt;
    &lt;span class="c1"&gt;// 不阻塞UI，也不能更新UI&lt;/span&gt;
    &lt;span class="c1"&gt;// 到主线程去更新UI&lt;/span&gt;
    &lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// UI code can go here! we’re on the main queue! &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Gestures&lt;/h1&gt;
&lt;p&gt;手势是iOS里的一等公民&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// recognize&lt;/span&gt;
&lt;span class="n"&gt;myView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gesture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// theGesture must implement the Gesture protocol&lt;/span&gt;

&lt;span class="c1"&gt;// create&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Gesture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TapGesture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// double tap&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// discrete gestures&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Gesture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TapGesture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onEnded&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* do something */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 其实就是：&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Gesture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;tapGesture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// “convenience versions”&lt;/span&gt;
&lt;span class="n"&gt;myView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onTapGesture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* do something */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="n"&gt;myView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onLongPressGesture&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* do something */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// non-discrete gestures&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Gesture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;DragGesture&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onEnded&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="cm"&gt;/* do something */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;non-discrete手势里传递的&lt;code&gt;value&lt;/code&gt;是一个state:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;For a &lt;code&gt;DragGesture&lt;/code&gt;, it’s a struct with things like the &lt;code&gt;start and end location&lt;/code&gt; of the fingers.&lt;/li&gt;
&lt;li&gt;For a &lt;code&gt;MagnificationGesture&lt;/code&gt; it’s the &lt;code&gt;scale&lt;/code&gt; of the magnification (how far the fingers spread out).&lt;/li&gt;
&lt;li&gt;For a &lt;code&gt;RotationGesture&lt;/code&gt; it’s the &lt;code&gt;Angle&lt;/code&gt; of the rotation (like the fingers were turning a dial).&lt;/li&gt;
&lt;li&gt;还可以跟踪一个state: &lt;code&gt;@GestureState var myGestureState: MyGestureStateType = &amp;lt;starting value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;唯一可以更新这个&lt;code&gt;myGestureState&lt;/code&gt;的机会：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;theGesture&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Gesture&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;DragGesture&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updating&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;myGestureState&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myGestureState&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; 
            &lt;span class="n"&gt;myGestureState&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="cm"&gt;/* usually something related to value */&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onEnded&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="cm"&gt;/* do something */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意&lt;code&gt;$&lt;/code&gt;的用法&lt;/p&gt;&lt;p&gt;如果不需要去计算一个&lt;code&gt;gestureState&lt;/code&gt;传出去的话，有个&lt;code&gt;updating&lt;/code&gt;用简版：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onChanged&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
&lt;span class="cm"&gt;/* do something with value (which is the state of the fingers) */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事实上，目前来看&lt;code&gt;gestureState&lt;/code&gt;只做了两件事：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;把实时手势对应的值保存起来&lt;/li&gt;
&lt;li&gt;在手势结束时复原（对于缩放，变为1，对于移动，变为0）&lt;/li&gt;
&lt;li&gt;同时，它是只读的，只在&lt;code&gt;.updating&lt;/code&gt;方法里有更新的机会&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，如果你的UI和动画逻辑，用到了手势结束时的值（即需要它复原），那么你也可以直接在&lt;code&gt;.onEnded&lt;/code&gt;方法里手动把它设回去，等同于你也实现了你的&lt;code&gt;gestureState&lt;/code&gt;，并且没有它那些限制。&lt;/p&gt;&lt;h2&gt;Drag and Drop&lt;/h2&gt;
&lt;h3&gt;Item Provider&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The heart of drag nad drop is the &lt;code&gt;NSItemProvider&lt;/code&gt; class.&lt;/li&gt;
&lt;li&gt;It facilitates the transfer of data between processes (via drag and drop, for example)&lt;/li&gt;
&lt;li&gt;It facilitates the transfer of a number of data types in iOS, for example:&lt;ul&gt;
&lt;li&gt;NSAttributedString and NSString&lt;/li&gt;
&lt;li&gt;NSURL&lt;/li&gt;
&lt;li&gt;UIImage and UIColor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pre-Swift，所以需要bridging，比如：&lt;code&gt;String as NSString&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合几个要点，一句话就能让你的元素能被拖动(drag)：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;emoji&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onDrag&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="bp"&gt;NSItemProvider&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;emoji&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而接收(drop)则要复杂很多：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;otherView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onDrop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[.&lt;/span&gt;&lt;span class="n"&gt;plainText&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;isTarget&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;providers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;参接收的类型由&lt;code&gt;of&lt;/code&gt;参数指定，这里假定是文本&lt;/li&gt;
&lt;li&gt;方法里最终要返回一个bool值，表示成功接收与否，我返了个false，意思是你能让物体拖动，但是一松开手指就复原了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从&lt;code&gt;itemprovider&lt;/code&gt;里加载对象有模板代码：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;extension&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;Element&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;NSItemProvider&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;loadObjects&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt;&lt;span class="n"&gt;ofType&lt;/span&gt; &lt;span class="n"&gt;theType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;firstOnly&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;escaping&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;NSItemProviderReading&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;provider&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;canLoadObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ofClass&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;theType&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;provider&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ofClass&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;theType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;DispatchQueue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// and&lt;/span&gt;
&lt;span class="c1"&gt;// where T: _ObjectiveCBridgeable, T._ObjectiveCType: NSItemProviderReading&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;提供了两段代码，可以看到其实就是对要加载的对象的约束不同，提供了对OC的兼容&lt;/li&gt;
&lt;li&gt;模板代码演示了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;稳健地从拖拽对象加载内容（canload -&amp;gt; load)
3. 真正的业务逻辑其实就是为拖进来的这个view选择一个位置存放（或读取它携带的数据）
4. &lt;code&gt;T.Type&lt;/code&gt;传的是类别的&lt;code&gt;.self&lt;/code&gt;，比如&lt;code&gt;String.self&lt;/code&gt;&lt;/p&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/</guid><pubDate>Mon, 24 Oct 2022 03:00:00 +0806</pubDate></item><item><title>cs193p_2021笔记[5]_Property-Wrapper</title><link>/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
cs193p_2021_笔记_5_Property Wrapper
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;hr /&gt;
&lt;h1&gt;Property Wrappers&lt;/h1&gt;
&lt;p&gt;C#中的&lt;code&gt;Attributes&lt;/code&gt;，python中的&lt;code&gt;Decorators&lt;/code&gt;, Java的&lt;code&gt;Annonations&lt;/code&gt;，类似的设计模式。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;A property wrapper is actually a &lt;code&gt;struct&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;这个特殊的&lt;code&gt;struct&lt;/code&gt;封装了一些模板行为应用到它们wrap的vars上：&lt;ol&gt;
&lt;li&gt;Making a var live in the heap (&lt;code&gt;@State&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Making a var publish its changes (&lt;code&gt;@Published&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Causing a View to redraw when a published change is detected (&lt;code&gt;@ObservedObject&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即能够分配到堆上，能够通知状态变化和能重绘等，可以理解为&lt;code&gt;语法糖&lt;/code&gt;。&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Published&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;emojiArt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;EmojiArt&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EmojiArt&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;// ... is really just this struct ...&lt;/span&gt;
&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Published&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;wrappedValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;EmojiArt&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;projectedValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Publisher&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EmojiArt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Never&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;  &lt;span class="c1"&gt;// i.e. $&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// `projected value`的类型取决于wrapper自己，比如本例就是一个`Publisher`&lt;/span&gt;

&lt;span class="c1"&gt;// 我理解为一个属性和一个广播器&lt;/span&gt;

&lt;span class="c1"&gt;// ... and Swift (approximately) makes these vars available to you ...&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;_emojiArt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Published&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Published&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wrappedValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;EmojiArt&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; 
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;emojiArt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;EmojiArt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kr"&gt;get&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_emojiArt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrappedValue&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
     &lt;span class="kr"&gt;set&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_emojiArt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wrappedValue&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newValue&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把get,set直接通过&lt;code&gt;$emojiArt&lt;/code&gt;(即projectedValue)来使用&lt;/p&gt;&lt;p&gt;当一个&lt;code&gt;Published&lt;/code&gt;值发生变化：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;It publishes the change through its &lt;em&gt;projectedValue&lt;/em&gt; (&lt;code&gt;$emojiArt&lt;/code&gt;) which is a &lt;code&gt;Publisher&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It also invokes &lt;code&gt;objectWillChange.send()&lt;/code&gt; in its enclosing &lt;code&gt;ObservableObject&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面列的几种&lt;code&gt;Property wrapper&lt;/code&gt;，我们主要关心最核心的两个概念，&lt;code&gt;wrappedValue&lt;/code&gt;和&lt;code&gt;projectedValue&lt;/code&gt;是什么就行了:&lt;/p&gt;&lt;h2&gt;@State&lt;/h2&gt;
&lt;p&gt;这是第二次提到了，在&lt;code&gt;Property Observers&lt;/code&gt;一节里预告过，基本上点&lt;code&gt;@&lt;/code&gt;的，大都为&lt;code&gt;Property Wrapper&lt;/code&gt;的内容。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The wrappedValue is: &lt;code&gt;anything&lt;/code&gt; (but almost certainly a value type).&lt;/li&gt;
&lt;li&gt;What it does:&lt;ul&gt;
&lt;li&gt;stores the wrappedValue in the heap;&lt;/li&gt;
&lt;li&gt;when it changes, &lt;code&gt;invalidates&lt;/code&gt; the &lt;code&gt;View&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Projected value (i.e. $): a &lt;code&gt;Binding&lt;/code&gt; (to that &lt;em&gt;value in the heap&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;
&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;_foo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initiaValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意&lt;code&gt;_&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;的区别。&lt;/p&gt;&lt;h2&gt;@StateObject &amp;amp; @ObservedObject&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The wrappedValue is: &lt;code&gt;anything&lt;/code&gt; that implements the &lt;code&gt;ObservableObject&lt;/code&gt; protocol (ViewModels).&lt;/li&gt;
&lt;li&gt;What it does:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;invalidates&lt;/code&gt; the &lt;code&gt;View&lt;/code&gt; when wrappedValue does &lt;em&gt;objectWillChange.send()&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Projected value (i.e. $): a &lt;code&gt;Binding&lt;/code&gt; (to the vars of the wrappedValue (a &lt;em&gt;ViewModel&lt;/em&gt;)).&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;@StateObject V.S. @State&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个类型是&lt;code&gt;ObservableObject&lt;/code&gt;s， 一个是value type&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;@StateObject V.S. @ObservedObject&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;@StateObject is a &amp;quot;source of truth&amp;quot;，也就是说可以直接赋值：&lt;code&gt;@StateObject var foo = SomeObservableObject()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;能用在&lt;em&gt;View, APP, Scene&lt;/em&gt;等场景&lt;/li&gt;
&lt;li&gt;如果用在View里，生命周期与View一致&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;
&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;EmojiArtApp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// stateObject, source of truth&lt;/span&gt;
    &lt;span class="c1"&gt;// defined in the app&lt;/span&gt;
    &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;StateObject&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;paletteStore&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PaletteStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;named&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;default&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;DocumentGroup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newDocument&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;EmojiArtDocument&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
        &lt;span class="n"&gt;EmojiArtDocumentView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environmentObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paletteStore&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// passed by environment&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;@Binding&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The wrappedValue is: &lt;code&gt;a value&lt;/code&gt; that is bound to something else.&lt;/li&gt;
&lt;li&gt;What it does:&lt;ul&gt;
&lt;li&gt;gets/sets the value of the wrappedValue from &lt;code&gt;some other source&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;when the bound-to value changes, it &lt;code&gt;invalidates&lt;/code&gt; the &lt;code&gt;View&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Form表单典型应用场景，有UI变化的控件&lt;/li&gt;
&lt;li&gt;手势过程中的State, 或drag时是否targted&lt;/li&gt;
&lt;li&gt;模态窗口的状态&lt;/li&gt;
&lt;li&gt;分割view后共享状态&lt;/li&gt;
&lt;li&gt;总之，数据源只有一个(source of the truth)的场景，就不需要用两个@State而用@Binding,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Projected value (i.e. $): a Binding (self; i.e. the Binding itself)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;myString&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;               &lt;span class="c1"&gt;// 1&lt;/span&gt;
      &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;OtherView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;myString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;// 2&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;OtherView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Binding&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;sharedText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;             &lt;span class="c1"&gt;// 3&lt;/span&gt;
      &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;// 4&lt;/span&gt;
          &lt;span class="n"&gt;TextField&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shared&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;sharedText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 5 _myString.projectValue.projectValue&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_myString&lt;/code&gt;是实际变量，包含一个&lt;code&gt;wrappedValue&lt;/code&gt;，一个&lt;code&gt;projectedValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myString&lt;/code&gt;就是&lt;code&gt;_myString.wrappedValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$myString&lt;/code&gt;是&lt;code&gt;_myString.projectedValue&lt;/code&gt;，&lt;ul&gt;
&lt;li&gt;是一个&lt;code&gt;Binding&amp;lt;String&amp;gt;&lt;/code&gt;，传值和接值用的就是它&lt;/li&gt;
&lt;li&gt;所以传&lt;code&gt;$myString&lt;/code&gt;的地方也可以用&lt;code&gt;_myString.projectedValue&lt;/code&gt;代替，学习阶段的话&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要把&lt;code&gt;projectedValue&lt;/code&gt;层层传递下去，并不是用同一个&lt;code&gt;projectedValue&lt;/code&gt;，而是设计成了&lt;code&gt;Binding&amp;lt;T&amp;gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;参考上面代码块的第5条&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其它&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;也可以绑定一个常量：&lt;code&gt;OtherView(sharedText: .constant(“Howdy”))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;computed binding: &lt;code&gt;Binding(get:, set:).&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如你的view是一个小组件，里面有一个&lt;code&gt;Binding var user: User&lt;/code&gt;，那么在preview里面怎么传入这个User呢？用常量：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;preview&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;myView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;(...)))&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;@EnvironmenetObject&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The wrappedValue is: &lt;code&gt;ObservableObject&lt;/code&gt; obtained via .environmentObject() sent to the View.&lt;/li&gt;
&lt;li&gt;What it does: &lt;code&gt;invalidates&lt;/code&gt; the View when wrappedValue does objectWillChange.send().&lt;/li&gt;
&lt;li&gt;Projected value (i.e. $): a &lt;code&gt;Binding&lt;/code&gt; (to the vars of the wrappedValue (a ViewModel)).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与&lt;code&gt;@ObservedObject&lt;/code&gt;用法稍有点不同，有单独的赋值接口：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;myView&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyView&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;environmentObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theViewModel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// 而@ObservedObject是一个普通的属性&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;myView&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;theViewModel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// Inside the View ...&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;EnvironmentObject&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ViewModelClass&lt;/span&gt; 
&lt;span class="c1"&gt;// ... vs ...&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;ObservedObject&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ViewModelClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;visible to all views in your body (except modallay presented ones)&lt;/li&gt;
&lt;li&gt;多用于多个view共享ViewModel的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;@Environment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;与&lt;code&gt;@EnvironmentObject&lt;/code&gt;完全不是同一个东西&lt;/li&gt;
&lt;li&gt;这是&lt;code&gt;Property Wrapper&lt;/code&gt;不只有两个变量（warped..., projected...）的的一个应用&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;keyPath&lt;/code&gt;来使用：&lt;code&gt;@Environment(\.colorScheme) var colorScheme&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;wrappedValue的类型是通过&lt;code&gt;keyPath&lt;/code&gt;声明时设置的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;colorScheme&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;so:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;The wrappedValue is: the value of some var in &lt;code&gt;EnvironmentValues&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;What it does: gets/sets a value of some var in &lt;code&gt;EnvironmentValues&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Projected value (i.e. $): none.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// someView pop 一个 modal 的 myView,传递 environment&lt;/span&gt;
&lt;span class="n"&gt;someView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sheet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isPresented&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;myCondition&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;myView&lt;/span&gt;&lt;span class="p"&gt;(...&lt;/span&gt;&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;...)&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enviroment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;colorScheme&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;colorScheme&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了深色模式，还有一个典型的应用场景就是编辑模式&lt;code&gt;\.editMode&lt;/code&gt;，比如点了编辑按钮后。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;EditButton&lt;/code&gt;是一个封装了UI和行为的控件，它只做一件事，就是更改&lt;code&gt;\.editmode&lt;/code&gt;这个环境变量(的&lt;code&gt;isEditing&lt;/code&gt;)&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;@Publisher&lt;/h2&gt;
&lt;p&gt;It is an object that &lt;code&gt;emits values&lt;/code&gt; and possibly a &lt;code&gt;failure object&lt;/code&gt; if it fails while doing so.&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Publisher&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Failure&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Failure需要实现&lt;code&gt;Error&lt;/code&gt;，如果没有，可以传&lt;code&gt;Never&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;订阅&lt;/h3&gt;
&lt;p&gt;一种简单用法，&lt;code&gt;sink&lt;/code&gt;:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cancellable&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myPublisher&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;receiveCompletion&lt;/span&gt;&lt;span class="p"&gt;:{&lt;/span&gt;&lt;span class="n"&gt;resultin&lt;/span&gt;&lt;span class="p"&gt;...},&lt;/span&gt; &lt;span class="c1"&gt;//result is a Completion&amp;lt;Failure&amp;gt; enum&lt;/span&gt;
        &lt;span class="n"&gt;receiveValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;thingThePublisherPublishes&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回一个&lt;code&gt;Cancellable&lt;/code&gt;，可以随时&lt;code&gt;.cancel()&lt;/code&gt;，只要你持有这个&lt;code&gt;cancellable&lt;/code&gt;，就能随时用这个sink&lt;/p&gt;&lt;p&gt;View有自己的订阅方式：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onReceive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;publisher&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;thingThePublisherPublishes&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="c1"&gt;// do whatever you want with thingThePublisherPublishes &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.onReceive&lt;/code&gt; will automatically &lt;code&gt;invalidate&lt;/code&gt; your View (causing a redraw).&lt;/li&gt;
&lt;li&gt;既然参数是publisher，所以是一个binding的变量，即带&lt;code&gt;$&lt;/code&gt;使用：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;onReceive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;aBindData&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;bind_data&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; 
    &lt;span class="c1"&gt;// my code&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;publisher来源：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; in front of vars marked &lt;code&gt;@Published&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;还记得$就是取的projectedValue吗？&lt;/li&gt;
&lt;li&gt;一般的projectedValue是一个&lt;em&gt;Binding&lt;/em&gt;，Published的是是个&lt;em&gt;Publisher&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;URLSession’s &lt;code&gt;dataTaskPublisher&lt;/code&gt; (publishes the Data obtained from a URL)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timer&lt;/code&gt;’s publish(every:) (periodically publishes the current date and time as a Date)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotificationCenter&lt;/code&gt;’s publisher(for:) (publishes notifications when system events happen)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你有一个&lt;code&gt;ObservedObject&lt;/code&gt;(Document)，它里面有一个&lt;code&gt;@Publisher&lt;/code&gt;(background)，那么注意以下两者的区别：&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;document.&lt;code&gt;$&lt;/code&gt;background: 是一个publisher&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;document.background: 是一个binding&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;.onReceive&lt;/code&gt;只能接收&lt;code&gt;Publisher&lt;/code&gt;的推送，而事实上，&lt;code&gt;onChange&lt;/code&gt;（一般用于接收ObservedObject或State)同样也能接收Publisher。&lt;/p&gt;&lt;/blockquote&gt;
</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/</guid><pubDate>Mon, 24 Oct 2022 04:00:00 +0806</pubDate></item><item><title>cs193p_2021笔记[6]_Persistence</title><link>/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
cs193p_2021_笔记_6_Persistence
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;p&gt;--&lt;/p&gt;&lt;h1&gt;Persistence&lt;/h1&gt;
&lt;p&gt;持久化数据的方式有&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;File system（FileManager）&lt;/li&gt;
&lt;li&gt;Sqlite/CoreData&lt;/li&gt;
&lt;li&gt;iCloud: 根据上面两种格式存储&lt;/li&gt;
&lt;li&gt;CloutKit: a database in the cloud (network)&lt;/li&gt;
&lt;li&gt;UserDefaults&lt;/li&gt;
&lt;li&gt;Codable/JSON&lt;/li&gt;
&lt;li&gt;UIDocument (UIKit feature)(与Files App集成)&lt;/li&gt;
&lt;li&gt;3rd-party&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;UserDefaults&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;只能存储&lt;code&gt;Property List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Property List&lt;/code&gt;支持String, Int, Bool, floating point, Date, Data, Array or Dictionary&lt;ul&gt;
&lt;li&gt;任何其它类型需要转成&lt;code&gt;Property List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Codable&lt;/code&gt; converts structs into &lt;code&gt;Data&lt;/code&gt; objects (and &lt;code&gt;Data&lt;/code&gt; is a &lt;code&gt;Property List&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;defaults&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserDefaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;standard&lt;/span&gt;
&lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;SomeKey&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// object must be a Property List&lt;/span&gt;
&lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDouble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;37.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyDouble&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// retrive&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyInteger&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyData&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;u&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyURL&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stringArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyString&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="c1"&gt;// Retrieving Arrays of anything but String is more complicated ...&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;MyArray&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// will return Array&amp;lt;Any&amp;gt;&lt;/span&gt;
&lt;span class="c1"&gt;// 最好用Codable的data(forKey:)替代&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Core Data&lt;/h2&gt;
&lt;p&gt;SwiftUI进行的集成:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;创建的对象是&lt;code&gt;ObservableObjects&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个property wrapper &lt;code&gt;@FetchRequest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管理对象(context)是&lt;code&gt;NSManagedObjectContext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;context通过&lt;code&gt;@Environment&lt;/code&gt;传入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;demo:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Environnment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;managedObjectContext&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;context&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;flight&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aircraft&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;B737&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="c1"&gt;// etc.&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;ksjc&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Airport&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ksjc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;icao&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;KSJC&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="c1"&gt;// etc.&lt;/span&gt;

&lt;span class="n"&gt;flight&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ksjc&lt;/span&gt; &lt;span class="c1"&gt;// this would add flight to ksjc.flightsFrom too try? context.save()&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;request&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;NSFetchRequest&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Flight&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt;&lt;span class="n"&gt;entityName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Flight&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;
&lt;span class="bp"&gt;NSPredicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;arrival&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;ksjc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sortDescriptors&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSSortDescriptor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;ident&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ascending&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; 

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;flights&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// past KSJC flights sorted by ident&lt;/span&gt;
&lt;span class="c1"&gt;// flights is nil if fetch failed, [] if no such flights, otherwise [Flight]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是core data部分，还是浓浓的OC的痕迹，看看Swift UI的版本。&lt;/p&gt;&lt;p&gt;首先，上述的&lt;code&gt;Flights, Airports&lt;/code&gt;都是ViewModel。它自然拥有它的&lt;code&gt;Property Wrapper&lt;/code&gt;:&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;FetchRequest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;sortDescriptors&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;flights&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FetchedResults&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Flight&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;FetchRequest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchRequest&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;airports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FetchedResults&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Airport&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;// flights and airports will continuously update as the database changes. &lt;/span&gt;
&lt;span class="n"&gt;ForEach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flights&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;flight&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="c1"&gt;// UI for a flight built using flight &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// bi-binding&lt;/span&gt;
&lt;span class="n"&gt;_flights&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FetchRequest&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Cloud Kit&lt;/h2&gt;
&lt;p&gt;上个demo吧&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;db&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;CKContainer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;shared&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;privateCloudDatabase&lt;/span&gt; 
&lt;span class="c1"&gt;// Record理解为Table&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;tweet&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;CKRecord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Tweet&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// 索引理解为Field&lt;/span&gt;
&lt;span class="n"&gt;tweet&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="mi"&gt;140&lt;/span&gt; &lt;span class="n"&gt;characters&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;joy&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;tweeter&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;CKRecord&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;TwitterUser&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;tweet&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;tweeter&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;CKReference&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tweeter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deleteSelf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tweet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;savedRecord&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;CKRecord&lt;/span&gt;&lt;span class="p"&gt;?,&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="p"&gt;?)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Void&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// hooray!&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;?.&lt;/span&gt;&lt;span class="n"&gt;errorCode&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="n"&gt;CKErrorCode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;NotAuthenticated&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rawValue&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// tell user he or she has to be logged in to iCloud for this to work!&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// report other errors (there are 29 different CKErrorCodes!) &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Query&lt;/span&gt;
&lt;span class="c1"&gt;// 类似core data, 构造predict, request(就是query)即可&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;predicate&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;NSPredicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="bp"&gt;contains&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;searchString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;query&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;CKQuery&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;recordType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Tweet&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;records&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;CKRecord&lt;/span&gt;&lt;span class="p"&gt;]?,&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="p"&gt;?)&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// records will be an array of matching CKRecords&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;?.&lt;/span&gt;&lt;span class="n"&gt;errorCode&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="n"&gt;CKErrorCode&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NotAuthenticated&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rawValue&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// tell user he or she has to be logged in to iCloud for this to work!&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// report other errors (there are 29 different CKErrorCodes!) &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One of the coolest features of Cloud Kit is its ability to &lt;code&gt;send push notifications&lt;/code&gt; on changes. All you do is register an &lt;code&gt;NSPredicate&lt;/code&gt; and whenever the database changes to match it,&lt;/p&gt;&lt;h2&gt;File System&lt;/h2&gt;
&lt;p&gt;Sandbox包含：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Application directory — Your executable, .jpgs, etc.; not writeable.&lt;/li&gt;
&lt;li&gt;Documents directory — Permanent storage created by and always visible to the user.&lt;/li&gt;
&lt;li&gt;Application Support directory — Permanent storage not seen directly by the user.&lt;/li&gt;
&lt;li&gt;Caches directory — Store temporary files here (this is not backed up).&lt;/li&gt;
&lt;li&gt;Other directories (see documentation)&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FileManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FileManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SearchPathDirectory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;documentDirectory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// for example &lt;/span&gt;
    &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;domainMask&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;userDomainMask&lt;/span&gt; &lt;span class="c1"&gt;// always .userDomainMask on iOS&lt;/span&gt;
    &lt;span class="n"&gt;appropriateFor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// only meaningful for “replace” file operations&lt;/span&gt;
    &lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="c1"&gt;// whether to create the system directory if it doesn’t already exist&lt;/span&gt;
 &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Examples of SearchPathDirectory values :&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;documentDirectory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;applicationSupportDirectory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cachesDirectory&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再列些常用api：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// URL&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;appendingPathComponent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;appendingPathExtension&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="c1"&gt;// e.g. “jpg”&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;isFileURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="c1"&gt;// is this a file URL (whether file exists or not) or something else? &lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;resourceValues&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;URLResourceKey&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;URLResourceKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;]?&lt;/span&gt; 
&lt;span class="c1"&gt;// Example keys: .creationDateKey, .isDirectoryKey, .fileSizeKey&lt;/span&gt;

&lt;span class="c1"&gt;// Data&lt;/span&gt;

&lt;span class="c1"&gt;// retrive binary data&lt;/span&gt;
&lt;span class="c1"&gt;// option almost always []&lt;/span&gt;
&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contentsOf&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadingOptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; 
&lt;span class="c1"&gt;// write&lt;/span&gt;
&lt;span class="c1"&gt;// The options can be things like .atomic (write to tmp file, then swap) or .withoutOverwriting.&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WritingOptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt;

&lt;span class="c1"&gt;// FileManager&lt;/span&gt;
&lt;span class="n"&gt;fileExists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atPath&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt;
&lt;span class="c1"&gt;// Can also create and enumerate directories; move, copy, delete files; etc.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Codable&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;保留一个对象所有的var（变量）的机制&lt;/li&gt;
&lt;li&gt;如果一个Struct它的成员变是Codable的，那么Swift会帮你把这个Struct实现Codable，比如没有associated data的Enum。&lt;/li&gt;
&lt;li&gt;帮你实现不代表不要显式声明&lt;/li&gt;
&lt;li&gt;基础类型基本上都实现了Codable&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;object&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MyType&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;// encode&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;JSONEncoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// write file&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// deocde as string&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;jsonString&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;!,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// decode as object&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;myObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MyType&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;JSONDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jsonData&lt;/span&gt;&lt;span class="p"&gt;!)&lt;/span&gt;
&lt;span class="c1"&gt;// 从字符串到对象没有一步到位的办法，只能先string-&amp;gt;Data&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsstring&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 再把data传到上术方法里&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;encode, decode是会throw的，注意try_catch相应的Error，比如&lt;code&gt;.keyNotFound, .dataCorrupted...&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;CodingKeys&lt;/h3&gt;
&lt;p&gt;json与对象相互进行转化有一个通用的需求，就是键的映射，这更常用在外部API与本地类的映射中，比如userId，别人叫guestId，等等，Swift中，用一个叫&lt;code&gt;CodingKeys&lt;/code&gt;的枚举来实现这个映射：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;CodingKeys&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CodingKey&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;user_id&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;someDate&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some_date&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;pname&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;panme&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;// 表示在JSON中也叫这个名字 &lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;sku&lt;/span&gt; &lt;span class="c1"&gt;// 如果名字一样的话，可以这么简写 &lt;/span&gt;
    &lt;span class="c1"&gt;// 但是不写的话，序列化的时候就不会序列这个字段了&lt;/span&gt;
    &lt;span class="c1"&gt;// 解码时会有 KeyNotFound 类的错误&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 结合起来，用在init中&lt;/span&gt;
&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;decoder&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Decoder&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// container是切入点，要弄清楚&lt;/span&gt;
    &lt;span class="c1"&gt;// 如果没有手写键的映射表，那么keydBy就是自己&lt;/span&gt;
    &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;container&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;decoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keyedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CodingKeys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;someDate&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;someDate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="c1"&gt;// 从json中加载.someDate对应的键的值，尝试解码成Date&lt;/span&gt;
    &lt;span class="c1"&gt;// other vars (每种case必须全部都有)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Enum&lt;/h3&gt;
&lt;p&gt;序列化枚举有点复杂：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;简单枚举应该怎么序列化？ 其实是序列化成case对应的名字和表示空JSON的&lt;code&gt;{}&lt;/code&gt;组成的键值对，比如&lt;code&gt;{&amp;quot;math&amp;quot;:{}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有关联数据的枚举呢？ 那就得自己提供&lt;code&gt;encoder&lt;/code&gt;:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;case url: try container.encode(url, forKey: .url)&lt;/code&gt; 即对相应的枚举值进行相应的encode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并且自行decode，但是与struct（为每一个key填值）不同，因为枚举变量只是一个值，所以是依次尝试，解码成功就认定是那一个枚举值&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kc"&gt;self&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;// 别的尝试&lt;/span&gt;

&lt;span class="c1"&gt;// 此句的作用是根据.url对应的键名，取出值，反射成URL对象，如果成功，那么这个枚举值是.url无疑&lt;/span&gt;
&lt;span class="c1"&gt;// 而且关联数据就是反射的结果&lt;/span&gt;
&lt;span class="c1"&gt;// 如果失败，继续换一个键名，将对应的值转成对应的类型，依次类推&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start="4"&gt;
&lt;li&gt;那么如何手动decode一个原始的枚举呢？&lt;ul&gt;
&lt;li&gt;我们知道上述实践是为了反射出关联数据，并且根据能够成功反射关联数据来判断枚举类型&lt;/li&gt;
&lt;li&gt;原始枚举需要encode哪个值呢？-&amp;gt; 目前我只能做一个空&lt;code&gt;struct&lt;/code&gt;来实现序列化成&lt;code&gt;{}&lt;/code&gt;的目的 -&amp;gt; 为了跟默认形态保持一致&lt;ul&gt;
&lt;li&gt;事实上你是可以encode成任意值的（比如100，&amp;quot;hello&amp;quot;，因为我们只关心有没有这个键，有的话，就是这个枚举类型，只是&lt;code&gt;{}&lt;/code&gt;拥有可读性&lt;/li&gt;
&lt;li&gt;你encode成什么值，decode的时候对对应的键尝试去反射回这个值就行了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，思考题：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;上面说了，原生枚举序列化成： &lt;code&gt;{&amp;quot;math&amp;quot;:{}}&lt;/code&gt;，也说了，如果，键对应的值对原生枚举序列化是没意义的，可以是任何值，那么对于&lt;code&gt;{&amp;quot;math&amp;quot;:100}&lt;/code&gt;，能否顺序序列化回其枚举形态&lt;code&gt;.math&lt;/code&gt;呢？&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;答案：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;值为100报错了&lt;/li&gt;
&lt;li&gt;于是我改为&amp;quot;&amp;quot;或&amp;quot;other“等字符串或空字符串，解码的结果是&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，默认的decode只认&lt;code&gt;{}&lt;/code&gt;&lt;/p&gt;&lt;figure style="flex: 82.77310924369748" &gt;&lt;img loading="lazy" width="1182" height="714" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c3a4240a7582937166f9300c35b4e868.png" /&gt;&lt;/figure&gt;&lt;p&gt;而前面我们知道了，如果是自己手写，它可以是任何值，它的意义仅仅是个标识，并不会取它的值。验证：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;NormEnum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Codable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;keyMap&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CodingKey&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;history&lt;/span&gt;  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;HIST&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;     &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MATH&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;geometry&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;GEOM&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Encoder&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;container&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;encoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keyedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;keyMap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;decoder&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Decoder&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;container&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="n"&gt;decoder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;keyedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;keyMap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kc"&gt;self&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;history&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kc"&gt;self&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kc"&gt;self&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中，我将三个字段全部用空字符串编码，并且给了三个不同的键名，现在，我真入任意值，比如&lt;code&gt;&amp;quot;HAHA&amp;quot;&lt;/code&gt;，解码看看：&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;js2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;MATH&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;:&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;HAHA&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;}&amp;quot;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;js2d&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;js2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;myobj2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;JSONDecoder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NormEnum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;js2d&lt;/span&gt;&lt;span class="p"&gt;!)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果成功认出myobj2是一个&lt;code&gt;.math&lt;/code&gt;。原理当然是我的代码里在尝试转成一个字符串，而没有限定是什么字符串。&lt;/p&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/</guid><pubDate>Mon, 24 Oct 2022 05:00:00 +0806</pubDate></item><item><title>cs193p_2021笔记[7]_Document-Architecture</title><link>/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
cs193p_2021_笔记_7_Document Architecture
&lt;a href="https://www.jianshu.com/p/2136bdc2c6f6"&gt;cs193p_2021_笔记_8&lt;/a&gt;&lt;/p&gt;&lt;h1&gt;Document Architecture&lt;/h1&gt;
&lt;p&gt;所谓的Dopcument Architecture，其实就是支持把用app产生的作品保存起来，比如你创作的一幅图片，可以保存为&lt;code&gt;.jpg&lt;/code&gt;，你用photoshop做的文件是&lt;code&gt;.psd&lt;/code&gt;，下次用自己的app加载这个文件，能认出所有组件和模型，比如我们想为document取个名字叫&lt;code&gt;.emojiart&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;App Architecture&lt;/h2&gt;
&lt;h3&gt;App protocol&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个app里只能有一个struct服从&lt;code&gt;App Protocol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mark it with &lt;code&gt;@main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;it's &lt;code&gt;var body&lt;/code&gt; is &lt;code&gt;some Scene&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Scene protocol&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;Scene&lt;/code&gt; is a container fo a &lt;code&gt;top-lever&lt;/code&gt; View that you want to show in your UI&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Environment(\.scenePhase)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;three main types of Scenes:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;WindowGroup&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;aTopLevelView&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;DocumentGroup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newDocument&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;aTopLevelView&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;DocumentGroup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;viewing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;viewer&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;aTopLevelView&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;// 只读&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;后两个类似view里面的&lt;code&gt;ForEach&lt;/code&gt;但不完全相同：&lt;ul&gt;
&lt;li&gt;而是：&amp;quot;&lt;strong&gt;new window&lt;/strong&gt;&amp;quot; on Mac, &amp;quot;&lt;strong&gt;splitting the screen&lt;/strong&gt;&amp;quot; on iPad -&amp;gt; for create new Scene&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content&lt;/code&gt;参数是一个返回some View的方法&lt;ul&gt;
&lt;li&gt;返回的是top-level view&lt;/li&gt;
&lt;li&gt;每当新建一个窗口或窗口被分割时都会被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你在iPad上分屏，且两个打开同一应用，就是&lt;code&gt;WindowGroup&lt;/code&gt;在管理，为每一个windows生成一个Scene(share the same parameter e.g. view model, 因为代码是同一份，除非额外为每个scene设置自己的viewmodel之类的).&lt;/p&gt;&lt;p&gt;&lt;code&gt;config&lt;/code&gt;里保存了document(即viewModel)，也保存了文件位置。&lt;/p&gt;&lt;h3&gt;SceneStorage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;能持久化数据&lt;/li&gt;
&lt;li&gt;以窗口/分屏为单位 -&amp;gt; per-Scene basis&lt;/li&gt;
&lt;li&gt;也会invalidate view&lt;/li&gt;
&lt;li&gt;数据类型有严格限制，最通用的是&lt;code&gt;RawRepresentable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[图片上传失败...(image-66d359-1636448439942)]&lt;/p&gt;&lt;p&gt;一个View里的&lt;code&gt;@State&lt;/code&gt;改为&lt;code&gt;@SceneStorage(uniq_id)&lt;/code&gt;后，app退出或crash了，仍然能找回原来的值。&lt;/p&gt;&lt;p&gt;这个时候每个Scene里的值就已经不一样了。&lt;/p&gt;&lt;h3&gt;AppStorage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;application-wide basis&lt;/li&gt;
&lt;li&gt;存在UserDefaults里&lt;/li&gt;
&lt;li&gt;服从&lt;code&gt;@SceneStorage&lt;/code&gt;的数据才能被存储&lt;/li&gt;
&lt;li&gt;invalidate view&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DocumentGroup&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DocumentGroup&lt;/code&gt; is the document-oriented Scene-building Scene.&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;
&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyDemoApp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;StateObject&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;paletteStore&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PaletteStore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;named&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Default&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;WindowGroup&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;MyDemoView&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environmentObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paletteStore&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// V.S.&lt;/span&gt;

&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyDemoApp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DocumentGroup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newDocument&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;myDocument&lt;/span&gt;&lt;span class="p"&gt;()})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
            &lt;span class="n"&gt;MyDemoView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;不再用&lt;code&gt;@StateObject&lt;/code&gt;传递ViewModel，每新建一个Document都会有一个独立的ViewModel&lt;ul&gt;
&lt;li&gt;必须要服从&lt;code&gt;ReferenceFileDocument&lt;/code&gt;(这样能存到文件系统以及从文件系统读取了)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt;参数包含了这个ViewModel（就是document)，以及document的url&lt;/li&gt;
&lt;li&gt;很好理解，每一个document肯定有自己的数据（想象一个“最近打开”的功能，每一个文档都是独立的）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newDocument&lt;/code&gt;里自行提供一个新建document的方法&lt;/li&gt;
&lt;li&gt;封装了关联的（选择document的）UI和行为&lt;/li&gt;
&lt;li&gt;you &lt;strong&gt;MUST&lt;/strong&gt; implement &lt;code&gt;Undo&lt;/code&gt; in your application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不去实现&lt;code&gt;Undo&lt;/code&gt;，也可以直接把model存到document文件里：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;你的ViewModel要能init itself from a &lt;code&gt;Binding&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;如&lt;code&gt;config.$document&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ViewModel由一个&lt;code&gt;ObservedObject&lt;/code&gt;变成一个&lt;code&gt;StateObject&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;这次必须服从&lt;code&gt;FileDocument&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyDemoApp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;Scene&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DocumentGroup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newDocument&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;myDocument&lt;/span&gt;&lt;span class="p"&gt;()})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
            &lt;span class="c1"&gt;// MyDemoView(document: config.document) // 之前的&lt;/span&gt;
            &lt;span class="n"&gt;MyDemoView&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把&lt;code&gt;newDocument: {myDocument()}&lt;/code&gt;改为&lt;code&gt;viewer: myDocument.self&lt;/code&gt;，就成了一个只读的model，（你甚至不需要传入实例），如果你要开发的是一个查看别人文档的应用，这个特性就比较有用了。&lt;/p&gt;&lt;h3&gt;FileDocument protocol&lt;/h3&gt;
&lt;p&gt;This protocol gets/puts the contents of a document from/to a file. 即提供你的document读到文件系统的能力。&lt;/p&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// create from a file&lt;/span&gt;
&lt;span class="kd"&gt;init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;configuration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ReadConfiguration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;configuration&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;regularFileContents&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// init yourself from data&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;CocoaError&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;fileReadCorruptFile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// write&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;fileWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;configuration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;WriteConfiguration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;FileWrapper&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;FileWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regularFileWithContents&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="cm"&gt;/*my data*/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ReferenceFileDocument&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;几乎和&lt;code&gt;FileDocument&lt;/code&gt;一致&lt;/li&gt;
&lt;li&gt;继承自&lt;code&gt;ObservableObject&lt;/code&gt; -&amp;gt; ViewModel only&lt;/li&gt;
&lt;li&gt;唯一的区别是通过后台线程的一个&lt;code&gt;snapshot&lt;/code&gt;来写入&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 先snapshot&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;snapshot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contentType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;UTType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Snapshot&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="c1"&gt;// my data or something&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// then write&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;fileWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snapshot&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Snapshot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;configuration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;WriteConfiguration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;throws&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;FileWrapper&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;FileWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regularFileWithContents&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="cm"&gt;/* snapshpt converted to a Data */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;流程大概是，你的model有变化之后，会先找&lt;code&gt;snapshot&lt;/code&gt;方法创建一份镜像，然后再要求你给出一个&lt;code&gt;fileWrapper&lt;/code&gt;来写文件。&lt;/p&gt;&lt;h3&gt;自定义文件类型&lt;/h3&gt;
&lt;p&gt;声明能打开什么类型的文件，通过：UTType(&lt;code&gt;Uniform Type Identifier&lt;/code&gt;)&lt;/p&gt;&lt;p&gt;可以理解为怎么定义并注册（关联）自己的扩展名，就像photoshop关联.psd一样。&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;声明(Info tab)，设置&lt;code&gt;Exported/Imported Type Identifier&lt;/code&gt;，所以表面上的扩展名，内里还对应了一个唯一的标识符，一般用反域名的格式&lt;/li&gt;
&lt;/ol&gt;
&lt;figure style="flex: 322.98850574712645" &gt;&lt;img loading="lazy" width="1124" height="174" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6b64ff3f0d28f9e054f79ae65e4eada0.png" /&gt;&lt;/figure&gt;&lt;ol start="2"&gt;
&lt;li&gt;声明拥有权，用的就是上一步标识符，而不是扩展名&lt;/li&gt;
&lt;/ol&gt;
&lt;figure style="flex: 400.0" &gt;&lt;img loading="lazy" width="1136" height="142" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/86264dc076782270e53b2ea22b2eb60f.png" /&gt;&lt;/figure&gt;&lt;ol start="3"&gt;
&lt;li&gt;告知系统能在&lt;code&gt;Files&lt;/code&gt; app里打开这种文档&lt;ul&gt;
&lt;li&gt;info.plist &amp;gt; Supports Document Browser &amp;gt; YES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码里添加枚举：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;extension&lt;/span&gt; &lt;span class="bp"&gt;UTType&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;emojiart&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;UTType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exportedAs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;edu.bla.bla.emojimart&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;readableContentTypes&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UTType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emojiart&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Undo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;ReferenceFileDocument&lt;/code&gt; must implement Undo&lt;/li&gt;
&lt;li&gt;这也是SwiftUI能自动保存的时间节点&lt;/li&gt;
&lt;li&gt;by &lt;code&gt;UndoManager&lt;/code&gt; -&amp;gt; &lt;code&gt;@Environment(\.undoManager) var undoManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and by register an &lt;code&gt;Undo&lt;/code&gt; for it: &lt;code&gt;func registerUndo(withTarget: self, howToUndo: (target) -&amp;gt; Void)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;undoablePerform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;undoManager&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;UndoManager&lt;/span&gt;&lt;span class="p"&gt;?,&lt;/span&gt; &lt;span class="n"&gt;doit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Void&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;oldModel&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;
    &lt;span class="n"&gt;doit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;undoManager&lt;/span&gt;&lt;span class="p"&gt;?.&lt;/span&gt;&lt;span class="n"&gt;registerUndo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;withTarget&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;myself&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;
        &lt;span class="n"&gt;myself&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;undoManager&lt;/span&gt;&lt;span class="p"&gt;?.&lt;/span&gt;&lt;span class="n"&gt;setActionName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 给操作一个名字，如&amp;quot;undo paste&amp;quot;， 非必需&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用`undoablyPerform(with:){} 包住的任何改变model的操作就都支持了undo&lt;/p&gt;&lt;h2&gt;Review&lt;/h2&gt;
&lt;p&gt;回顾一下，我们把应用改造为&lt;code&gt;Document Architechture&lt;/code&gt;的步骤：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;应用入口，将&lt;code&gt;WindowGroup&lt;/code&gt;改为了&lt;code&gt;DocumentGroup&lt;/code&gt;，并修改了相应的传递document的方式&lt;/li&gt;
&lt;li&gt;实现document(即view model) comform to &lt;code&gt;ReferenceFileDocument&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;实现snapshot, write to file (&lt;code&gt;FileWrapper&lt;/code&gt;), and read from file&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义一个文件类别（扩展名，标识符，声明拥有者等）&lt;/li&gt;
&lt;li&gt;此时启动应用，入口UI已经是文档选择界面了，所以我说它封装了UI和行为&lt;ul&gt;
&lt;li&gt;但此时不具备保存的功能，需要进一步实现&lt;code&gt;Undo&lt;/code&gt;'&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;undoManager&lt;/code&gt;把改动model的行为都包进去实现undo/redo&lt;ul&gt;
&lt;li&gt;此时document已能自动保存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增加toolbar, 实现手动undo/redo&lt;/li&gt;
&lt;li&gt;顺便注册文档类型，以便在Files应用内能用本app打开&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Info.plist&lt;/code&gt; &amp;gt; &lt;code&gt;Supports Document Browser&lt;/code&gt; &amp;gt; YES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/</guid><pubDate>Mon, 24 Oct 2022 06:00:00 +0806</pubDate></item><item><title>cs193p_2021_笔记_[完结]_pdf下载</title><link>/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/</link><description>&lt;p&gt;&lt;a href="https://www.jianshu.com/p/998b0ef4a2cd"&gt;cs193p_2021_笔记_1&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/af0ad1bead34"&gt;cs193p_2021_笔记_2&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/d103f8d12052"&gt;cs193p_2021_笔记_3_Animation_Transition&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/41e7309c7f55"&gt;cs193p_2021_笔记_4_Color_Image_Gesture&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/e3c2ee1628c6"&gt;cs193p_2021_笔记_5_Property Wrapper&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/a315274a4fd2"&gt;cs193p_2021_笔记_6_Persistence&lt;/a&gt;
&lt;a href="https://www.jianshu.com/p/f4ae879eef9c"&gt;cs193p_2021_笔记_7_Document Architecture&lt;/a&gt;&lt;/p&gt;&lt;p&gt;所有笔记已导出成一篇pdf文档，已上传百度：
链接: &lt;a href="https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g"&gt;https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g&lt;/a&gt; 提取码: 7w1f&lt;/p&gt;&lt;hr /&gt;
&lt;p&gt;本文内容：与UIKit的集成，以及学习过程中的一些tips，skills，与章节无章的notes&lt;/p&gt;&lt;hr /&gt;
&lt;h1&gt;MVVM&lt;/h1&gt;
&lt;figure style="flex: 89.08045977011494" &gt;&lt;img loading="lazy" width="1240" height="696" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/da570de12fc64177b4e88c6429ae285b.png" /&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;viewmodel要起到gete keeper的作用，它就要把model给private起来&lt;ul&gt;
&lt;li&gt;或者private (set), 这样保护了写，但是能读&lt;/li&gt;
&lt;li&gt;或者用一个计算属性把需要的model 暴露出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个viewmodel通常要conform &lt;code&gt;ObservableObject&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;就隐含了一个&lt;code&gt;var objectWillChange: ObservableObjectPublisher&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;model要改动前：&lt;code&gt;objectWillChange.send()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;或者，把model改为&lt;code&gt;@Publisher var model&lt;/code&gt;，会自动广播&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;订阅者（通常就是View）就要把这个viewmodel打个可订阅的标识：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@ObservedObject var viewModel: MyViewModel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只能是&lt;code&gt;var&lt;/code&gt;，因为很明显是会变的&lt;/li&gt;
&lt;li&gt;View监听到是会自动invalicate view的，就会重绘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;UIKit Integration&lt;/h1&gt;
&lt;p&gt;UIKit并不是纯View的世界，大多数时候是跟ViewController一起出现的，还严重依赖&lt;code&gt;Delegate&lt;/code&gt;这种机制进行跨View的事件传递（回调）。&lt;/p&gt;&lt;h2&gt;Representbles&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;UIViewRepresentable&lt;/code&gt;，&lt;code&gt;UIViewContorllerRepresentable&lt;/code&gt;都是SwiftUI的View了，包含几个组件：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;makeUIView{Controller}(context: Context) -&amp;gt; view/controller&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateUIView{Controller}(view/controller, context: Context) -&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;makeCoordiinator() -&amp;gt; Coordinator&lt;/code&gt; // handle delegate&lt;ul&gt;
&lt;li&gt;调用该方法后, &lt;code&gt;context.coordinator&lt;/code&gt;就有值了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Context&lt;/code&gt; containn the coordinator, swiftui's env, animation transaction&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dismantleUIView{Controller}(view/controller, coordinator: Coordinator)&lt;/code&gt; // clean up when disappears&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Tips &amp;amp; Skills&lt;/h1&gt;
&lt;p&gt;学习过程随笔记下来的一些技巧和知识点:&lt;/p&gt;&lt;h2&gt;basic&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[0...6]是0到6，[0..&amp;lt;6]是0到5&lt;/li&gt;
&lt;li&gt;var s = struct_a; s[&amp;quot;a&amp;quot;] = 3, 不会改变struct_a, 因为struct永远是复制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr.firstIndex(where: { item in item.id == myID})&lt;/code&gt;，因为where需要的函数传递的是本身（类似map, filter)，所以可以简化为：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr.firstIndex(where: { $0.id == myID})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typealias Card = MemoryGame&amp;lt;String&amp;gt;.Card&lt;/code&gt; 别名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var a_int_array = [Int]()&lt;/code&gt; 一种初始化方式&lt;/li&gt;
&lt;li&gt;extension中的属性可以直接用，（当然也可以用&lt;code&gt;self.&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr.filter { isGood($0)}&lt;/code&gt; 因为参数就是自己，还可以继续简化： `arr.filter(isGood)``&lt;ul&gt;
&lt;li&gt;同理：&lt;code&gt;[1...100].reduce(0, +)&lt;/code&gt;，因为默认参数是两个，所以会自动填到+号两边，展开就是&lt;code&gt;{ $0 + $1 }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collection&lt;/code&gt; protocol is for &lt;em&gt;immutable&lt;/em&gt; collections&lt;ul&gt;
&lt;li&gt;mutalbe Collection protocol is &lt;code&gt;RangeReplaceableCollection&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以要写一个扩展，在改变集合的元素，先选对正确的protocol&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;try&lt;/code&gt;还是&lt;code&gt;try?&lt;/code&gt;调用一个声明了&lt;code&gt;throw&lt;/code&gt;的函数，取决于你是要忽略它还是处理它&lt;ul&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt;就是不处理，结果就是包含了这段代码的函数也要标上&lt;code&gt;throw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;try?&lt;/code&gt;就是忽略掉，承认&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String(describing: obj)&lt;/code&gt;: 对象的字符串表示，或字符串描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#function&lt;/code&gt; 程序名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ScaleMetric var fontSize: CGFloat = 40.0&lt;/code&gt; 固定大小的字体，用&lt;code&gt;@ScaleMetric&lt;/code&gt;也能按比例缩放&lt;/li&gt;
&lt;li&gt;剪贴板：&lt;code&gt;UIPasteboard.general.image?.jpegData(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;safe area: &lt;code&gt;UIAplication.shared.windows.first?.safeAreaInsets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;views.map{ UIHostingController(rootView: $0)}&lt;/code&gt; 把一组View转为ViewController&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timer = Timer.publish(erery: 3, on: .current, in: .common).autoconnect()&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;view&lt;code&gt;.onReceive(timer, perform: {})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Texxt(Image(systemName: &amp;quot;video.circle&amp;quot;)) + Text(&amp;quot;视频&amp;quot;)&lt;/code&gt;: 两个知识点&lt;ul&gt;
&lt;li&gt;Text view重载了&lt;code&gt;+&lt;/code&gt;操作符，省去了用&lt;code&gt;HStack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Image也可以作为Text的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Circle + trim + stroke + rotation&lt;/code&gt; 可以组合出一段任意角度的弧形&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;PreferenceKey&lt;/code&gt;用来广播属性变化的例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure style="flex: 38.9937106918239" &gt;&lt;img loading="lazy" width="1240" height="1590" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e660e659aadcd624c62b1b9102d015d5.png" /&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;* see more [https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/](https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看一个简化的实例：
&lt;figure style="flex: 43.13868613138686" &gt;&lt;img loading="lazy" width="1182" height="1370" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/01b4f14b413613c6bd36ad5b2288df9d.png" /&gt;&lt;/figure&gt;
可以看到，其实化简化可读性更强，用for循环，再在里面做逻辑，会把直白的初衷绕进去：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;返回唯一一个面朝上的卡片&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置选定索引的卡片面朝上&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同样， &lt;code&gt;Button&lt;/code&gt;的声明是：&lt;code&gt;(_ title: StringProtocol, action: () -&amp;gt; Void)&lt;/code&gt;,&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;简化后也更加直观了：&lt;code&gt;Button(&amp;quot;text&amp;quot;){ actions }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给class/struct添加和使用默认的&lt;code&gt;description&lt;/code&gt;有点绕，等于原生并不支持，还理解成了&lt;code&gt;String&lt;/code&gt;的方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;CustomStringConvertible&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;
    &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;de&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// #function, file, filePaht, fileID, line, column&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;\(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="si"&gt;(&lt;/span&gt;&lt;span class="n"&gt;describing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="si"&gt;))&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="si"&gt;\(&lt;/span&gt;&lt;span class="kc"&gt;#function&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="si"&gt;\(&lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="n"&gt;filePath&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;

        &lt;span class="c1"&gt;// String(describing: obj)&lt;/span&gt;
        &lt;span class="c1"&gt;// 理解为用obj对象的description属性来构造字符串&lt;/span&gt;
        &lt;span class="c1"&gt;// 而一般人的设计思路会是：给obj对象增加一个description属性，这个属性是个string&lt;/span&gt;
        &lt;span class="c1"&gt;// 并且这个对象要服务 CustomStringConvertible 协议&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;description&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;{&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;a&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;:&lt;/span&gt;&lt;span class="si"&gt;\(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s"&gt;, &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;b&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s"&gt;:&lt;/span&gt;&lt;span class="si"&gt;\(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="si"&gt;)&lt;/span&gt;&lt;span class="s"&gt;}&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;de&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;// 输出： {&amp;quot;a&amp;quot;: 77, &amp;quot;b&amp;quot;: 88} \n de() \n myfile_path&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;view&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var body : some View {...}&lt;/code&gt; 意思是你自己不需要实现View，但你要返回some实现了View的（别的）对象&lt;ul&gt;
&lt;li&gt;它是一个computed var，所以跟的{}就是一个function&lt;/li&gt;
&lt;li&gt;所以{}里隐含了一个return&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Text(&amp;quot;hello&amp;quot;).padding()&lt;/code&gt;返回的不再是Text&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZStack(alignment: .center, content: {...})&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;简化为：&lt;code&gt;ZStack(alignment: .center) {...}&lt;/code&gt;，提取了方法体&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;alignment&lt;/code&gt;为空： &lt;code&gt;ZStack {...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以它里面也可以有局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多个函数参数也可以简化：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Button(action: {...}, label: {...})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Button {...} label: {...}&lt;/code&gt;省掉了第一个参数名，省掉了逗号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Button.contextMenu{ some View}&lt;/code&gt; 上下文菜单，内容就是some View&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Menu{ some View} label: { Label }&lt;/code&gt; 呈现为一个button，点击后会自动呈现some View组成的菜单&lt;ul&gt;
&lt;li&gt;也就是说它自己帮你封装了UI和行为（点击弹出菜单），不需要写什么&lt;code&gt;onTap&lt;/code&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myView.sheet(isPresented: $flag) { some View}&lt;/code&gt; 通过&lt;code&gt;$flag&lt;/code&gt;就能根据&lt;code&gt;myView&lt;/code&gt;的位置在合适的位置打开sheet，内容由@viewBuilder的closure提供&lt;/li&gt;
&lt;li&gt;&lt;code&gt;popover&lt;/code&gt;也同理，还有一种popover时把对象传进去的用法：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;popover&lt;/code&gt;与&lt;code&gt;sheet&lt;/code&gt;的区别是&lt;code&gt;popover&lt;/code&gt;在计算自身大小的时候是“尽可能小”，所以在包的对象里对好自己size一下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alert有点不同：&lt;code&gt;.alert(item: $flag) { alertToShow in return Alert}&lt;/code&gt;， 就是要返回一个&lt;code&gt;Alert&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myView.popover(item: $obj) {obj in ...}&lt;/code&gt; 这一类传item做flag的用法也有广泛的使用场景&lt;/li&gt;
&lt;li&gt;弹出的页面查看自己的状态，用&lt;code&gt;presentationMode&lt;/code&gt;环境变量&lt;ul&gt;
&lt;li&gt;&lt;code&gt;presentationMode.wrappedValue.isPresented&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NavigationView&lt;/code&gt;里的&lt;code&gt;NavigationLink&lt;/code&gt;也是一样封装了UI和行为（点击跳转）&lt;/li&gt;
&lt;li&gt;toolbaritem的placement除了leading, trailing等直观表示，还有一些语义对应的(类似alert中有红色的销毁按钮），如&lt;code&gt;destructiveAction, cancellationAction, confirmationAction&lt;/code&gt;等，甚至&lt;code&gt;automaic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;工具条放到底部：ToolbarItemGroup(placement: .bottmbar){}`&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.StackNavigationViewStyle&lt;/code&gt;, 让大屏幕iPhone横屏时不去尝试左右分屏，直接铺满&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIDevice.current.userInterfaceIdiom == .pad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;环境变量：&lt;code&gt;horizontalSizeClass&lt;/code&gt;, &lt;code&gt;verticalSizeClass&lt;/code&gt;等，根据是否compact来判断布局，而不是写死的大小，以实现跨机型适配&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;layout&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lazyVGrid(columns: [GridItem(.fixed(200)), GridItem(.flexable()), GridItem())])&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;其实就是一个flex的排版&lt;/li&gt;
&lt;li&gt;横向利用所有空间，竖向尽可能小&lt;/li&gt;
&lt;li&gt;竖排，没定义，看效果是top&lt;/li&gt;
&lt;li&gt;横排，由每一个GridItem来定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lazy&lt;/code&gt;的意思是只有出现在屏幕上时，才会渲染&lt;code&gt;body&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果横向元素也自由排列呢？比如横屏15个，竖屏6个&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lazyVGrid(columns: GridItem(.adaptive(minimum: 80)))&lt;/code&gt; 只要一个item, 然后指定一个最小宽度即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同理应该有lazyHGrid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;static&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.largeTitle, .white, 其实就是静态变量: &lt;code&gt;Font.largeTitle&lt;/code&gt;, &lt;code&gt;Color.white&lt;/code&gt;，所以不要觉得代码里用&lt;code&gt;static let xxx = xxx&lt;/code&gt;很low&lt;ul&gt;
&lt;li&gt;静态方法同理，只要不需要是实例变量的，都可以staic起来，跳出初始化流程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;XCode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设置 &amp;gt; Behaviors &amp;gt; Generates output 可以设置模拟器有output时的行为，比如拉出控制台看输出&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 设置预览的设备&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;previewDevice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PreviewDevice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rawValue&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;iPhone 12&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;previewDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;iPhone 12&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;preview里面你做两个&lt;code&gt;.preferredColorScheme(.dark/.light)&lt;/code&gt;就可以同时预览两种颜色模式下的效果了&lt;/li&gt;
&lt;li&gt;其实以上在右侧面板设置会更简单，一样会在Preview里生成相应（跟手写一模一样）的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...&lt;/p&gt;</description><author>hi@imalan.cn (walker)</author><guid isPermaLink="true">/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/</guid><pubDate>Mon, 24 Oct 2022 07:00:00 +0806</pubDate></item></channel></rss>