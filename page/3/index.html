<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/66077cf5542cc50c8af36c6d25f0819c.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="walker" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/3/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/" target="_self">数据结构篇一：Array, Linked-List, Stack, Queues</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><p>前几个比较基础,只记录了些关键字和提纲</p><h1>Static and Dynamic Arrays</h1>
<p><strong>static array</strong></p><ul>
<li>fixed length</li>
<li>indexable</li>
</ul>
<p>usage:</p><ul>
<li>sequential data</li>
<li>IO routines as buffers</li>
<li>lookup tables and inverse lookup tables</li>
<li>return multiple values</li>
</ul>
<p>operation complexity:
access: O(1)
search: <code>O(n)</code>
insert: <code>O(n)</code>
append: O(1)
delet: <code>O(n)</code>
需要遍历的操作就是O(n)</p><p>Q: How to implement a dynamic array?
A:</p><ol>
<li>static array with an initial capacity</li>
<li>add new elements, keep tracking the size</li>
<li>if exceed capacity, create a new static array with <code>twice the capacity</code><ul>
<li>and copy the original elements into it</li>
</ul>
</li>
</ol>
<h2>Singly and Doubly Linked Lists</h2>
<p>单向/双向链表</p><p>sequential list of nodes that hold data which point to other nodes also containing data.</p><ul>
<li>节点序列，</li>
<li>节点拥有指向别的节点的数据（指针）</li>
<li>别的节点也拥有这种指针</li>
</ul>
<p>usage:</p><ul>
<li>many <code>List, Queue &amp; Stack</code> implementations</li>
<li>circular lists</li>
<li>model real world objects such as <code>trains</code></li>
<li>implementation of adjancy list for graphs</li>
<li>separate chaining -&gt; ?<ul>
<li>deal with hashing collisions -&gt; ?</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述两上问号后续在<code>Hash Table</code>一节里自然就解惑了</p></blockquote>
<p><strong>Terminology</strong>
Head / Tail / Pointer / Node</p><p>Singly vs Doubly</p><ul>
<li>Doubly holds a <code>next</code> and <code>prev</code> reference, which Singly has no <code>prev</code><ul>
<li>插入删除的时候需要更新所有引用</li>
</ul>
</li>
<li>both maintain a reference of <code>head</code> and <code>tail</code> for quick additions / removals</li>
</ul>
<p><strong>insertion</strong></p><ul>
<li>create a traverser and move by sepcific steps</li>
<li>create new node</li>
<li>singly:<ul>
<li>原node的next指向新node</li>
<li>新node的next指向原next的node</li>
</ul>
</li>
<li>doubly:<ul>
<li>新node的next和prev分别指向原node和下一个node</li>
<li>两个node分别用next和prev指向新node</li>
</ul>
</li>
</ul>
<p><strong>removal</strong></p><p>singly需要两个游标:</p><ul>
<li>pt1指向head, pt2指向head-&gt;next</li>
<li>pt1, pt2一起移动，直到pt2找到目标</li>
<li>pt2再向前移动一步</li>
<li>pt1位置的node用next指向pt2位置</li>
<li>now can sefely remoing the element between pt1 and pt2</li>
</ul>
<p>doubly却只需要一个：</p><ul>
<li>pointer找到目标元素</li>
<li>用prev和next找到上一个和下一个</li>
<li>下一个和下一个node分别互相指向</li>
</ul>
<p><strong>Complexity</strong>
searth: <code>O(n)</code>
insert at head/tail: O(1)
remove at head: O(1)
remove at tail: <code>O(n)</code> (singly) / O(1) (doubly)
因为即使我们知道tail在哪，在单向链表中，我们也找不到它的前一个去设置为新的tail
remove in middle: <code>O(n)</code></p><h1>Stack</h1>
<ul>
<li>one-ended linear data structure (LIFO)</li>
<li>two operation: <code>push</code> and <code>pop</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>undo mechanisms</li>
<li>compiler syntax checking for matching brackets and braces<ul>
<li>开括号压入栈内，每碰到一个闭括号，与栈顶的比较，匹配就出栈，不匹配就报错</li>
</ul>
</li>
<li>model a pile of books or plates<ul>
<li>汉诺塔(tower of hanoi)</li>
</ul>
</li>
<li>tracking previous function calls</li>
<li>DFS on a graph</li>
</ul>
<p><strong>Complexity</strong>
push/pop/peek/size: O(1)
search: <code>O(n)</code></p><p>双向链表实现一个Stack，基本上就是操作tail</p><h1>Queues</h1>
<ul>
<li>a linear data structure, model real world queues (FIFO)</li>
<li>two primary operations: <code>enqueue</code>, <code>dequeue</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>any waiting line models a queue</li>
<li>keep track of the x most recently added elements -&gt; ?</li>
<li>web server request management where you want first come first serve</li>
<li>BFS graph traversal</li>
</ul>
<p><strong>Complexity</strong></p><p>只有<code>contains, revomval</code>需要遍历，其它操作（出入列等）都是O(1)</p><p>实现一个BFS：</p><p>基本就是动态往 queue 里添加子节点,当前级别元素访问完后, 再 dequeue 出来的就是所有的下一级子节点
<figure  style="flex: 92.55319148936171" ><img width="1044" height="564" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/910285ef71036aa37402e819d06f56fc.png" alt=""/></figure></p><p>双向列表实现Queue，入列用tail，出列用head，即添加的总在尾巴，永远从头部取出。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" target="_self">全排列，递归与分治</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" target="_self">
                <time class="text-uppercase">
                    November 04 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>能够用递归和分治解决的，特征都是下一级做的事跟上一级一样（抽象），最后一层做真正的业务。比如n个数字的全排列，抽象出来就是每n-1个数字的全排列</p><p>它的难点就在于抽象，因为等于什么都没描述（我要5个数字的全排列，你就说，那好，你告诉我这4个数字的全排列，我就能告诉你5个数字的全排列）。</p><p>也就是说，尝试用n和n-1的思维（有点像归纳法，动态规划）去描述问题，而不去看能不能解决。</p><p>具体到这里，以ABCD为例，我们的请求过程应该是这样的</p><ul>
<li>A打头的话，BCD的全排列 swap(0, 0)</li>
<li>B打头的话，ACD的全排列 swap(0, 1)</li>
<li>...swap(0,2)</li>
<li>...swap(0,3)</li>
</ul>
<p>自己是可以数出来的：</p><div class="highlight"><pre><span></span>A固定，BCD的所有排列 swap<span class="o">(</span><span class="m">0</span>,0<span class="o">)</span>
  B固定，CD的所有排列 swap<span class="o">(</span><span class="m">1</span>,1<span class="o">)</span>
      C固定，D的所有排列 swap<span class="o">(</span><span class="m">1</span>,2<span class="o">)</span>（1）
      D固定，C的所有排列 swap<span class="o">(</span><span class="m">1</span>,3<span class="o">)</span>（1）
  C固定，同B（2）
  D固定，同B（2）
  计6种
B固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,1<span class="o">)</span>
C固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,2<span class="o">)</span>
D固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,3<span class="o">)</span>
结果应该是24
</pre></div>
<p>所有缩进部分都是递归，所以真正的业务代码就是一句话，交换每次比较的数组的第一个和剩下的几个的位置，然后递归下去</p><div class="highlight"><pre><span></span><span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">ctr</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="c1"># 思路是，我每次只动一个数字，然后固定住这个数字，看剩下的数字有多少种排列</span>
            <span class="c1"># 代码里每次把固定的数字挪到开头</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
</pre></div>
<p>output: 24</p><p>可能是我理解能力的问题，所有人都没有解释为什么有swap，可能是太直观吧，毕竟swap才是真正在”排列“的业务代码。我还是自己写一遍才想明白，记录一下吧。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/" target="_self">cs193p_2021_笔记_[完结]_pdf下载</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>所有笔记已导出成一篇pdf文档，已上传百度：
链接: <a href="https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g">https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g</a> 提取码: 7w1f</p><hr />
<p>本文内容：与UIKit的集成，以及学习过程中的一些tips，skills，与章节无章的notes</p><hr />
<h1>MVVM</h1>
<figure  style="flex: 89.08045977011494" ><img width="1240" height="696" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/da570de12fc64177b4e88c6429ae285b.png" alt=""/></figure><ul>
<li>viewmodel要起到gete keeper的作用，它就要把model给private起来<ul>
<li>或者private (set), 这样保护了写，但是能读</li>
<li>或者用一个计算属性把需要的model 暴露出去</li>
</ul>
</li>
<li>一个viewmodel通常要conform <code>ObservableObject</code><ul>
<li>就隐含了一个<code>var objectWillChange: ObservableObjectPublisher</code></li>
<li>model要改动前：<code>objectWillChange.send()</code></li>
<li>或者，把model改为<code>@Publisher var model</code>，会自动广播</li>
</ul>
</li>
<li>订阅者（通常就是View）就要把这个viewmodel打个可订阅的标识：<ul>
<li><code>@ObservedObject var viewModel: MyViewModel</code></li>
<li>只能是<code>var</code>，因为很明显是会变的</li>
<li>View监听到是会自动invalicate view的，就会重绘</li>
</ul>
</li>
</ul>
<h1>UIKit Integration</h1>
<p>UIKit并不是纯View的世界，大多数时候是跟ViewController一起出现的，还严重依赖<code>Delegate</code>这种机制进行跨View的事件传递（回调）。</p><h2>Representbles</h2>
<p><code>UIViewRepresentable</code>，<code>UIViewContorllerRepresentable</code>都是SwiftUI的View了，包含几个组件：</p><ol>
<li><code>makeUIView{Controller}(context: Context) -&gt; view/controller</code></li>
<li><code>updateUIView{Controller}(view/controller, context: Context) -&gt;</code></li>
<li><code>makeCoordiinator() -&gt; Coordinator</code> // handle delegate<ul>
<li>调用该方法后, <code>context.coordinator</code>就有值了</li>
</ul>
</li>
<li>a <code>Context</code> containn the coordinator, swiftui's env, animation transaction</li>
<li><code>dismantleUIView{Controller}(view/controller, coordinator: Coordinator)</code> // clean up when disappears</li>
</ol>
<h1>Tips &amp; Skills</h1>
<p>学习过程随笔记下来的一些技巧和知识点:</p><h2>basic</h2>
<ul>
<li>[0...6]是0到6，[0..&lt;6]是0到5</li>
<li>var s = struct_a; s[&quot;a&quot;] = 3, 不会改变struct_a, 因为struct永远是复制</li>
<li><code>arr.firstIndex(where: { item in item.id == myID})</code>，因为where需要的函数传递的是本身（类似map, filter)，所以可以简化为：<ul>
<li><code>arr.firstIndex(where: { $0.id == myID})</code></li>
</ul>
</li>
<li><code>typealias Card = MemoryGame&lt;String&gt;.Card</code> 别名</li>
<li><code>var a_int_array = [Int]()</code> 一种初始化方式</li>
<li>extension中的属性可以直接用，（当然也可以用<code>self.</code>）</li>
<li><code>arr.filter { isGood($0)}</code> 因为参数就是自己，还可以继续简化： `arr.filter(isGood)``<ul>
<li>同理：<code>[1...100].reduce(0, +)</code>，因为默认参数是两个，所以会自动填到+号两边，展开就是<code>{ $0 + $1 }</code></li>
</ul>
</li>
<li><code>Collection</code> protocol is for <em>immutable</em> collections<ul>
<li>mutalbe Collection protocol is <code>RangeReplaceableCollection</code></li>
<li>所以要写一个扩展，在改变集合的元素，先选对正确的protocol</li>
</ul>
</li>
<li>用<code>try</code>还是<code>try?</code>调用一个声明了<code>throw</code>的函数，取决于你是要忽略它还是处理它<ul>
<li><code>try</code>就是不处理，结果就是包含了这段代码的函数也要标上<code>throw</code></li>
<li><code>try?</code>就是忽略掉，承认<code>nil</code></li>
</ul>
</li>
<li><code>String(describing: obj)</code>: 对象的字符串表示，或字符串描述</li>
<li><code>#function</code> 程序名</li>
<li><code>@ScaleMetric var fontSize: CGFloat = 40.0</code> 固定大小的字体，用<code>@ScaleMetric</code>也能按比例缩放</li>
<li>剪贴板：<code>UIPasteboard.general.image?.jpegData(...)</code></li>
<li>safe area: <code>UIAplication.shared.windows.first?.safeAreaInsets</code></li>
<li><code>views.map{ UIHostingController(rootView: $0)}</code> 把一组View转为ViewController</li>
<li><code>timer = Timer.publish(erery: 3, on: .current, in: .common).autoconnect()</code><ul>
<li>view<code>.onReceive(timer, perform: {})</code></li>
</ul>
</li>
<li><code>Texxt(Image(systemName: &quot;video.circle&quot;)) + Text(&quot;视频&quot;)</code>: 两个知识点<ul>
<li>Text view重载了<code>+</code>操作符，省去了用<code>HStack</code></li>
<li>Image也可以作为Text的内容</li>
</ul>
</li>
<li><code>Circle + trim + stroke + rotation</code> 可以组合出一段任意角度的弧形</li>
<li>一个<code>PreferenceKey</code>用来广播属性变化的例子：</li>
</ul>
<figure class="vertical-figure" style="flex: 38.9937106918239" ><img width="1240" height="1590" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e660e659aadcd624c62b1b9102d015d5.png" alt=""/></figure>
<pre><code>* see more [https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/](https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
</code></pre>
<p>看一个简化的实例：
<figure class="vertical-figure" style="flex: 43.13868613138686" ><img width="1182" height="1370" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/01b4f14b413613c6bd36ad5b2288df9d.png" alt=""/></figure>
可以看到，其实化简化可读性更强，用for循环，再在里面做逻辑，会把直白的初衷绕进去：</p><ul>
<li><p>返回唯一一个面朝上的卡片</p></li>
<li><p>设置选定索引的卡片面朝上</p></li>
<li><p>同样， <code>Button</code>的声明是：<code>(_ title: StringProtocol, action: () -&gt; Void)</code>,</p><ul>
<li>简化后也更加直观了：<code>Button(&quot;text&quot;){ actions }</code></li>
</ul>
</li>
<li><p>给class/struct添加和使用默认的<code>description</code>有点绕，等于原生并不支持，还理解成了<code>String</code>的方法</p></li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">abc</span><span class="p">:</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">a</span><span class="p">:</span><span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">b</span><span class="p">:</span><span class="nb">Int</span>
    <span class="kd">func</span> <span class="nf">de</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span><span class="p">{</span>
        <span class="c1">// #function, file, filePaht, fileID, line, column</span>
        <span class="s">&quot;</span><span class="si">\(</span><span class="nb">String</span><span class="si">(</span><span class="n">describing</span><span class="p">:</span> <span class="kc">self</span><span class="si">))</span><span class="se">\n</span><span class="si">\(</span><span class="kc">#function</span><span class="si">)</span><span class="se">\n</span><span class="si">\(</span><span class="p">#</span><span class="n">filePath</span><span class="si">)</span><span class="s">&quot;</span>

        <span class="c1">// String(describing: obj)</span>
        <span class="c1">// 理解为用obj对象的description属性来构造字符串</span>
        <span class="c1">// 而一般人的设计思路会是：给obj对象增加一个description属性，这个属性是个string</span>
        <span class="c1">// 并且这个对象要服务 CustomStringConvertible 协议</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">:</span><span class="si">\(</span><span class="n">a</span><span class="si">)</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">b</span><span class="se">\&quot;</span><span class="s">:</span><span class="si">\(</span><span class="n">b</span><span class="si">)</span><span class="s">}&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">abc</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">88</span><span class="p">).</span><span class="n">de</span><span class="p">()</span> <span class="c1">// 输出： {&quot;a&quot;: 77, &quot;b&quot;: 88} \n de() \n myfile_path</span>
</pre></div>
<h2>view</h2>
<ul>
<li><code>var body : some View {...}</code> 意思是你自己不需要实现View，但你要返回some实现了View的（别的）对象<ul>
<li>它是一个computed var，所以跟的{}就是一个function</li>
<li>所以{}里隐含了一个return</li>
</ul>
</li>
<li><code>Text(&quot;hello&quot;).padding()</code>返回的不再是Text</li>
<li><code>ZStack(alignment: .center, content: {...})</code><ul>
<li>简化为：<code>ZStack(alignment: .center) {...}</code>，提取了方法体</li>
<li>如果<code>alignment</code>为空： <code>ZStack {...}</code></li>
<li>所以它里面也可以有局部变量</li>
</ul>
</li>
<li>多个函数参数也可以简化：<ul>
<li><code>Button(action: {...}, label: {...})</code></li>
<li><code>Button {...} label: {...}</code>省掉了第一个参数名，省掉了逗号</li>
</ul>
</li>
<li><code>Button.contextMenu{ some View}</code> 上下文菜单，内容就是some View</li>
<li><code>Menu{ some View} label: { Label }</code> 呈现为一个button，点击后会自动呈现some View组成的菜单<ul>
<li>也就是说它自己帮你封装了UI和行为（点击弹出菜单），不需要写什么<code>onTap</code>事件</li>
</ul>
</li>
<li><code>myView.sheet(isPresented: $flag) { some View}</code> 通过<code>$flag</code>就能根据<code>myView</code>的位置在合适的位置打开sheet，内容由@viewBuilder的closure提供</li>
<li><code>popover</code>也同理，还有一种popover时把对象传进去的用法：<ul>
<li><code>popover</code>与<code>sheet</code>的区别是<code>popover</code>在计算自身大小的时候是“尽可能小”，所以在包的对象里对好自己size一下</li>
</ul>
</li>
<li>alert有点不同：<code>.alert(item: $flag) { alertToShow in return Alert}</code>， 就是要返回一个<code>Alert</code>对象</li>
<li><code>myView.popover(item: $obj) {obj in ...}</code> 这一类传item做flag的用法也有广泛的使用场景</li>
<li>弹出的页面查看自己的状态，用<code>presentationMode</code>环境变量<ul>
<li><code>presentationMode.wrappedValue.isPresented</code></li>
</ul>
</li>
<li><code>NavigationView</code>里的<code>NavigationLink</code>也是一样封装了UI和行为（点击跳转）</li>
<li>toolbaritem的placement除了leading, trailing等直观表示，还有一些语义对应的(类似alert中有红色的销毁按钮），如<code>destructiveAction, cancellationAction, confirmationAction</code>等，甚至<code>automaic</code></li>
<li>工具条放到底部：ToolbarItemGroup(placement: .bottmbar){}`</li>
<li><code>.StackNavigationViewStyle</code>, 让大屏幕iPhone横屏时不去尝试左右分屏，直接铺满</li>
<li><code>UIDevice.current.userInterfaceIdiom == .pad</code></li>
<li>环境变量：<code>horizontalSizeClass</code>, <code>verticalSizeClass</code>等，根据是否compact来判断布局，而不是写死的大小，以实现跨机型适配</li>
</ul>
<h2>layout</h2>
<ul>
<li><code>lazyVGrid(columns: [GridItem(.fixed(200)), GridItem(.flexable()), GridItem())])</code><ul>
<li>其实就是一个flex的排版</li>
<li>横向利用所有空间，竖向尽可能小</li>
<li>竖排，没定义，看效果是top</li>
<li>横排，由每一个GridItem来定义</li>
<li><code>Lazy</code>的意思是只有出现在屏幕上时，才会渲染<code>body</code></li>
<li>如果横向元素也自由排列呢？比如横屏15个，竖屏6个<ul>
<li><code>lazyVGrid(columns: GridItem(.adaptive(minimum: 80)))</code> 只要一个item, 然后指定一个最小宽度即可</li>
</ul>
</li>
<li>同理应该有lazyHGrid</li>
</ul>
</li>
</ul>
<h2>static</h2>
<ul>
<li>.largeTitle, .white, 其实就是静态变量: <code>Font.largeTitle</code>, <code>Color.white</code>，所以不要觉得代码里用<code>static let xxx = xxx</code>很low<ul>
<li>静态方法同理，只要不需要是实例变量的，都可以staic起来，跳出初始化流程</li>
</ul>
</li>
</ul>
<h2>XCode</h2>
<ul>
<li>设置 &gt; Behaviors &gt; Generates output 可以设置模拟器有output时的行为，比如拉出控制台看输出</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// 设置预览的设备</span>
    <span class="p">.</span><span class="n">previewDevice</span><span class="p">(</span><span class="n">PreviewDevice</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="s">&quot;iPhone 12&quot;</span><span class="p">))</span>
    <span class="p">.</span><span class="n">previewDisplayName</span><span class="p">(</span><span class="s">&quot;iPhone 12&quot;</span><span class="p">)</span>
</pre></div>
<ul>
<li>preview里面你做两个<code>.preferredColorScheme(.dark/.light)</code>就可以同时预览两种颜色模式下的效果了</li>
<li>其实以上在右侧面板设置会更简单，一样会在Preview里生成相应（跟手写一模一样）的代码</li>
</ul>
<p>...</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/" target="_self">cs193p_2021笔记[7]_Document-Architecture</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Document Architecture</h1>
<p>所谓的Dopcument Architecture，其实就是支持把用app产生的作品保存起来，比如你创作的一幅图片，可以保存为<code>.jpg</code>，你用photoshop做的文件是<code>.psd</code>，下次用自己的app加载这个文件，能认出所有组件和模型，比如我们想为document取个名字叫<code>.emojiart</code>。</p><h2>App Architecture</h2>
<h3>App protocol</h3>
<ul>
<li>一个app里只能有一个struct服从<code>App Protocol</code></li>
<li>mark it with <code>@main</code></li>
<li>it's <code>var body</code> is <code>some Scene</code></li>
</ul>
<h3>Scene protocol</h3>
<ul>
<li>A <code>Scene</code> is a container fo a <code>top-lever</code> View that you want to show in your UI</li>
<li><code>@Environment(\.scenePhase)</code></li>
<li>three main types of Scenes:</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">WindowGroup</span> <span class="p">{</span><span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>
<span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:)</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span> <span class="p">...</span> <span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>
<span class="n">DocumentGroup</span><span class="p">(</span><span class="n">viewing</span><span class="p">:</span> <span class="n">viewer</span><span class="p">:)</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span> <span class="p">...</span> <span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>  <span class="c1">// 只读</span>
</pre></div>
<ul>
<li>后两个类似view里面的<code>ForEach</code>但不完全相同：<ul>
<li>而是：&quot;<strong>new window</strong>&quot; on Mac, &quot;<strong>splitting the screen</strong>&quot; on iPad -&gt; for create new Scene</li>
</ul>
</li>
<li><code>content</code>参数是一个返回some View的方法<ul>
<li>返回的是top-level view</li>
<li>每当新建一个窗口或窗口被分割时都会被调用</li>
</ul>
</li>
</ul>
<p>当你在iPad上分屏，且两个打开同一应用，就是<code>WindowGroup</code>在管理，为每一个windows生成一个Scene(share the same parameter e.g. view model, 因为代码是同一份，除非额外为每个scene设置自己的viewmodel之类的).</p><p><code>config</code>里保存了document(即viewModel)，也保存了文件位置。</p><h3>SceneStorage</h3>
<ul>
<li>能持久化数据</li>
<li>以窗口/分屏为单位 -&gt; per-Scene basis</li>
<li>也会invalidate view</li>
<li>数据类型有严格限制，最通用的是<code>RawRepresentable</code></li>
</ul>
<p>[图片上传失败...(image-66d359-1636448439942)]</p><p>一个View里的<code>@State</code>改为<code>@SceneStorage(uniq_id)</code>后，app退出或crash了，仍然能找回原来的值。</p><p>这个时候每个Scene里的值就已经不一样了。</p><h3>AppStorage</h3>
<ul>
<li>application-wide basis</li>
<li>存在UserDefaults里</li>
<li>服从<code>@SceneStorage</code>的数据才能被存储</li>
<li>invalidate view</li>
</ul>
<h2>DocumentGroup</h2>
<p><code>DocumentGroup</code> is the document-oriented Scene-building Scene.</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">main</span>
<span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">StateObject</span> <span class="kd">var</span> <span class="nv">paletteStore</span> <span class="p">=</span> <span class="n">PaletteStore</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&quot;Default&quot;</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">WindowGroup</span> <span class="p">{</span>
            <span class="n">MyDemoView</span><span class="p">()</span>
            <span class="p">.</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">paletteStore</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V.S.</span>

<span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span><span class="n">myDocument</span><span class="p">()})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
            <span class="n">MyDemoView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="n">document</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>不再用<code>@StateObject</code>传递ViewModel，每新建一个Document都会有一个独立的ViewModel<ul>
<li>必须要服从<code>ReferenceFileDocument</code>(这样能存到文件系统以及从文件系统读取了)</li>
<li><code>config</code>参数包含了这个ViewModel（就是document)，以及document的url</li>
<li>很好理解，每一个document肯定有自己的数据（想象一个“最近打开”的功能，每一个文档都是独立的）</li>
</ul>
</li>
<li><code>newDocument</code>里自行提供一个新建document的方法</li>
<li>封装了关联的（选择document的）UI和行为</li>
<li>you <strong>MUST</strong> implement <code>Undo</code> in your application</li>
</ul>
<p>如果不去实现<code>Undo</code>，也可以直接把model存到document文件里：</p><ol>
<li>你的ViewModel要能init itself from a <code>Binding&lt;Type&gt;</code><ul>
<li>如<code>config.$document</code></li>
</ul>
</li>
<li>ViewModel由一个<code>ObservedObject</code>变成一个<code>StateObject</code><ul>
<li>这次必须服从<code>FileDocument</code></li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span><span class="n">myDocument</span><span class="p">()})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
            <span class="c1">// MyDemoView(document: config.document) // 之前的</span>
            <span class="n">MyDemoView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="err">$</span><span class="n">document</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>把<code>newDocument: {myDocument()}</code>改为<code>viewer: myDocument.self</code>，就成了一个只读的model，（你甚至不需要传入实例），如果你要开发的是一个查看别人文档的应用，这个特性就比较有用了。</p><h3>FileDocument protocol</h3>
<p>This protocol gets/puts the contents of a document from/to a file. 即提供你的document读到文件系统的能力。</p><div class="highlight"><pre><span></span><span class="c1">// create from a file</span>
<span class="kd">init</span><span class="p">(</span><span class="n">configuration</span><span class="p">:</span> <span class="n">ReadConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">configuration</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">regularFileContents</span> <span class="p">{</span>
        <span class="c1">// init yourself from data</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">CocoaError</span><span class="p">(.</span><span class="n">fileReadCorruptFile</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// write</span>
<span class="kd">func</span> <span class="nf">fileWrapper</span><span class="p">(</span><span class="n">configuration</span><span class="p">:</span> <span class="n">WriteConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">FileWrapper</span> <span class="p">{</span>
    <span class="n">FileWrapper</span><span class="p">(</span><span class="n">regularFileWithContents</span><span class="p">:</span> <span class="cm">/*my data*/</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3>ReferenceFileDocument</h3>
<ul>
<li>几乎和<code>FileDocument</code>一致</li>
<li>继承自<code>ObservableObject</code> -&gt; ViewModel only</li>
<li>唯一的区别是通过后台线程的一个<code>snapshot</code>来写入</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// 先snapshot</span>
<span class="kd">func</span> <span class="nf">snapshot</span><span class="p">(</span><span class="n">contentType</span><span class="p">:</span> <span class="bp">UTType</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Snapshot</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// my data or something</span>
<span class="p">}</span>
<span class="c1">// then write</span>
<span class="kd">func</span> <span class="nf">fileWrapper</span><span class="p">(</span><span class="n">snapshot</span><span class="p">:</span> <span class="n">Snapshot</span><span class="p">,</span> <span class="n">configuration</span><span class="p">:</span> <span class="n">WriteConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">FileWrapper</span> <span class="p">{</span>
    <span class="n">FileWrapper</span><span class="p">(</span><span class="n">regularFileWithContents</span><span class="p">:</span> <span class="cm">/* snapshpt converted to a Data */</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>流程大概是，你的model有变化之后，会先找<code>snapshot</code>方法创建一份镜像，然后再要求你给出一个<code>fileWrapper</code>来写文件。</p><h3>自定义文件类型</h3>
<p>声明能打开什么类型的文件，通过：UTType(<code>Uniform Type Identifier</code>)</p><p>可以理解为怎么定义并注册（关联）自己的扩展名，就像photoshop关联.psd一样。</p><ol>
<li>声明(Info tab)，设置<code>Exported/Imported Type Identifier</code>，所以表面上的扩展名，内里还对应了一个唯一的标识符，一般用反域名的格式</li>
</ol>
<figure  style="flex: 322.98850574712645" ><img width="1124" height="174" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6b64ff3f0d28f9e054f79ae65e4eada0.png" alt=""/></figure><ol start="2">
<li>声明拥有权，用的就是上一步标识符，而不是扩展名</li>
</ol>
<figure  style="flex: 400.0" ><img width="1136" height="142" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/86264dc076782270e53b2ea22b2eb60f.png" alt=""/></figure><ol start="3">
<li>告知系统能在<code>Files</code> app里打开这种文档<ul>
<li>info.plist &gt; Supports Document Browser &gt; YES</li>
</ul>
</li>
<li>代码里添加枚举：</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="bp">UTType</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">emojiart</span> <span class="p">=</span> <span class="bp">UTType</span><span class="p">(</span><span class="n">exportedAs</span><span class="p">:</span> <span class="s">&quot;edu.bla.bla.emojimart&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">static</span> <span class="kd">let</span> <span class="nv">readableContentTypes</span> <span class="p">=</span> <span class="p">[</span><span class="bp">UTType</span><span class="p">.</span><span class="n">emojiart</span><span class="p">]</span>
</pre></div>
<h2>Undo</h2>
<ul>
<li>use <code>ReferenceFileDocument</code> must implement Undo</li>
<li>这也是SwiftUI能自动保存的时间节点</li>
<li>by <code>UndoManager</code> -&gt; <code>@Environment(\.undoManager) var undoManager</code></li>
<li>and by register an <code>Undo</code> for it: <code>func registerUndo(withTarget: self, howToUndo: (target) -&gt; Void)</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">undoablePerform</span><span class="p">(</span><span class="n">operation</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">with</span> <span class="n">undoManager</span><span class="p">:</span> <span class="n">UndoManager</span><span class="p">?,</span> <span class="n">doit</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nv">oldModel</span> <span class="p">=</span> <span class="n">model</span>
    <span class="n">doit</span><span class="p">()</span>
    <span class="n">undoManager</span><span class="p">?.</span><span class="n">registerUndo</span><span class="p">(</span><span class="n">withTarget</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">myself</span> <span class="k">in</span>
        <span class="n">myself</span><span class="p">.</span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span>
    <span class="p">}</span>
    <span class="n">undoManager</span><span class="p">?.</span><span class="n">setActionName</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span> <span class="c1">// 给操作一个名字，如&quot;undo paste&quot;， 非必需</span>
<span class="p">}</span>
</pre></div>
<p>用`undoablyPerform(with:){} 包住的任何改变model的操作就都支持了undo</p><h2>Review</h2>
<p>回顾一下，我们把应用改造为<code>Document Architechture</code>的步骤：</p><ol>
<li>应用入口，将<code>WindowGroup</code>改为了<code>DocumentGroup</code>，并修改了相应的传递document的方式</li>
<li>实现document(即view model) comform to <code>ReferenceFileDocument</code><ul>
<li>实现snapshot, write to file (<code>FileWrapper</code>), and read from file</li>
</ul>
</li>
<li>自定义一个文件类别（扩展名，标识符，声明拥有者等）</li>
<li>此时启动应用，入口UI已经是文档选择界面了，所以我说它封装了UI和行为<ul>
<li>但此时不具备保存的功能，需要进一步实现<code>Undo</code>'</li>
</ul>
</li>
<li>通过<code>undoManager</code>把改动model的行为都包进去实现undo/redo<ul>
<li>此时document已能自动保存</li>
</ul>
</li>
<li>增加toolbar, 实现手动undo/redo</li>
<li>顺便注册文档类型，以便在Files应用内能用本app打开<ul>
<li><code>Info.plist</code> &gt; <code>Supports Document Browser</code> &gt; YES</li>
</ul>
</li>
</ol>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/" target="_self">cs193p_2021笔记[6]_Persistence</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Persistence</h1>
<p>持久化数据的方式有</p><ul>
<li>File system（FileManager）</li>
<li>Sqlite/CoreData</li>
<li>iCloud: 根据上面两种格式存储</li>
<li>CloutKit: a database in the cloud (network)</li>
<li>UserDefaults</li>
<li>Codable/JSON</li>
<li>UIDocument (UIKit feature)(与Files App集成)</li>
<li>3rd-party</li>
</ul>
<h2>UserDefaults</h2>
<ul>
<li>只能存储<code>Property List</code></li>
<li><code>Property List</code>支持String, Int, Bool, floating point, Date, Data, Array or Dictionary<ul>
<li>任何其它类型需要转成<code>Property List</code></li>
<li><code>Codable</code> converts structs into <code>Data</code> objects (and <code>Data</code> is a <code>Property List</code>).</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">defaults</span> <span class="p">=</span> <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span>
<span class="n">defaults</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">SomeKey</span><span class="err">”</span><span class="p">)</span> <span class="c1">// object must be a Property List</span>
<span class="n">defaults</span><span class="p">.</span><span class="n">setDouble</span><span class="p">(</span><span class="mf">37.5</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyDouble</span><span class="err">”</span><span class="p">)</span>

<span class="c1">// retrive</span>

<span class="kd">let</span> <span class="nv">i</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">integer</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyInteger</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="n">Data</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyData</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">u</span><span class="p">:</span> <span class="n">URL</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">url</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyURL</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">strings</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">stringArray</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyString</span><span class="err">”</span><span class="p">)</span> 
<span class="c1">// etc.</span>
<span class="c1">// Retrieving Arrays of anything but String is more complicated ...</span>
<span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyArray</span><span class="err">”</span><span class="p">)</span> <span class="c1">// will return Array&lt;Any&gt;</span>
<span class="c1">// 最好用Codable的data(forKey:)替代</span>
</pre></div>
<h2>Core Data</h2>
<p>SwiftUI进行的集成:</p><ul>
<li>创建的对象是<code>ObservableObjects</code></li>
<li>一个property wrapper <code>@FetchRequest</code></li>
<li>管理对象(context)是<code>NSManagedObjectContext</code></li>
<li>context通过<code>@Environment</code>传入</li>
</ul>
<p>demo:</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">Environnment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">context</span>
<span class="kd">let</span> <span class="nv">flight</span> <span class="p">=</span> <span class="n">Flight</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
<span class="n">flight</span><span class="p">.</span><span class="n">aircraft</span> <span class="p">=</span> <span class="err">“</span><span class="n">B737</span><span class="err">”</span> <span class="c1">// etc.</span>

<span class="kd">let</span> <span class="nv">ksjc</span> <span class="p">=</span> <span class="n">Airport</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
<span class="n">ksjc</span><span class="p">.</span><span class="n">icao</span> <span class="p">=</span> <span class="err">“</span><span class="n">KSJC</span><span class="err">”</span> <span class="c1">// etc.</span>

<span class="n">flight</span><span class="p">.</span><span class="n">origin</span> <span class="p">=</span> <span class="n">ksjc</span> <span class="c1">// this would add flight to ksjc.flightsFrom too try? context.save()</span>

<span class="kd">let</span> <span class="nv">request</span> <span class="p">=</span> <span class="bp">NSFetchRequest</span><span class="p">&lt;</span><span class="n">Flight</span><span class="p">&gt;(</span><span class="n">entityName</span><span class="p">:</span> <span class="err">“</span><span class="n">Flight</span><span class="err">”</span><span class="p">)</span> <span class="n">request</span><span class="p">.</span><span class="n">predicate</span> <span class="p">=</span>
<span class="bp">NSPredicate</span><span class="p">(</span><span class="n">format</span><span class="p">:</span> <span class="err">“</span><span class="n">arrival</span> <span class="o">&lt;</span> <span class="o">%</span><span class="p">@</span> <span class="n">and</span> <span class="n">origin</span> <span class="p">=</span> <span class="o">%</span><span class="p">@</span><span class="err">“</span><span class="p">,</span> <span class="n">Date</span><span class="p">(),</span> <span class="n">ksjc</span><span class="p">)</span> 
<span class="n">request</span><span class="p">.</span><span class="n">sortDescriptors</span> <span class="p">=</span> <span class="p">[</span><span class="bp">NSSortDescriptor</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="err">“</span><span class="n">ident</span><span class="err">”</span><span class="p">,</span> <span class="n">ascending</span><span class="p">:</span> <span class="kc">true</span><span class="p">)]</span> 

<span class="kd">let</span> <span class="nv">flights</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">context</span><span class="p">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="c1">// past KSJC flights sorted by ident</span>
<span class="c1">// flights is nil if fetch failed, [] if no such flights, otherwise [Flight]</span>
</pre></div>
<p>以上是core data部分，还是浓浓的OC的痕迹，看看Swift UI的版本。</p><p>首先，上述的<code>Flights, Airports</code>都是ViewModel。它自然拥有它的<code>Property Wrapper</code>:</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">FetchRequest</span><span class="p">(</span><span class="n">entity</span><span class="p">:</span><span class="n">sortDescriptors</span><span class="p">:</span><span class="n">predicate</span><span class="p">:)</span> <span class="kd">var</span> <span class="nv">flights</span><span class="p">:</span> <span class="n">FetchedResults</span><span class="p">&lt;</span><span class="n">Flight</span><span class="p">&gt;</span>
<span class="p">@</span><span class="n">FetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">:)</span> <span class="kd">var</span> <span class="nv">airports</span><span class="p">:</span> <span class="n">FetchedResults</span><span class="p">&lt;</span><span class="n">Airport</span><span class="p">&gt;</span>

<span class="c1">// flights and airports will continuously update as the database changes. </span>
<span class="n">ForEach</span><span class="p">(</span><span class="n">flights</span><span class="p">)</span> <span class="p">{</span> <span class="n">flight</span> <span class="k">in</span>
    <span class="c1">// UI for a flight built using flight </span>
<span class="p">}</span>

<span class="c1">// bi-binding</span>
<span class="n">_flights</span> <span class="p">=</span> <span class="n">FetchRequest</span><span class="p">(...)</span>
</pre></div>
<h2>Cloud Kit</h2>
<p>上个demo吧</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">db</span> <span class="p">=</span> <span class="bp">CKContainer</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="kd">public</span><span class="o">/</span><span class="n">shared</span><span class="o">/</span><span class="n">privateCloudDatabase</span> 
<span class="c1">// Record理解为Table</span>
<span class="kd">let</span> <span class="nv">tweet</span> <span class="p">=</span> <span class="bp">CKRecord</span><span class="p">(</span><span class="err">“</span><span class="n">Tweet</span><span class="err">”</span><span class="p">)</span>
<span class="c1">// 索引理解为Field</span>
<span class="n">tweet</span><span class="p">[</span><span class="err">“</span><span class="n">text</span><span class="err">”</span><span class="p">]</span> <span class="p">=</span> <span class="err">“</span><span class="mi">140</span> <span class="n">characters</span> <span class="n">of</span> <span class="n">pure</span> <span class="n">joy</span><span class="err">”</span>
<span class="kd">let</span> <span class="nv">tweeter</span> <span class="p">=</span> <span class="bp">CKRecord</span><span class="p">(</span><span class="err">“</span><span class="n">TwitterUser</span><span class="err">”</span><span class="p">)</span>
<span class="n">tweet</span><span class="p">[</span><span class="err">“</span><span class="n">tweeter</span><span class="err">”</span><span class="p">]</span> <span class="p">=</span> <span class="bp">CKReference</span><span class="p">(</span><span class="n">record</span><span class="p">:</span> <span class="n">tweeter</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="p">.</span><span class="n">deleteSelf</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">savedRecord</span><span class="p">:</span> <span class="bp">CKRecord</span><span class="p">?,</span> <span class="n">error</span><span class="p">:</span> <span class="bp">NSError</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// hooray!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">error</span><span class="p">?.</span><span class="n">errorCode</span> <span class="p">==</span> <span class="n">CKErrorCode</span><span class="p">.</span> <span class="n">NotAuthenticated</span><span class="p">.</span><span class="n">rawValue</span> <span class="p">{</span>
        <span class="c1">// tell user he or she has to be logged in to iCloud for this to work!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// report other errors (there are 29 different CKErrorCodes!) </span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Query</span>
<span class="c1">// 类似core data, 构造predict, request(就是query)即可</span>

<span class="kd">let</span> <span class="nv">predicate</span> <span class="p">=</span> <span class="bp">NSPredicate</span><span class="p">(</span><span class="n">format</span><span class="p">:</span> <span class="err">“</span><span class="n">text</span> <span class="bp">contains</span> <span class="o">%</span><span class="p">@</span><span class="err">“</span><span class="p">,</span> <span class="n">searchString</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">query</span> <span class="p">=</span> <span class="bp">CKQuery</span><span class="p">(</span><span class="n">recordType</span><span class="p">:</span> <span class="err">“</span><span class="n">Tweet</span><span class="err">”</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">predicate</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">perform</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">records</span><span class="p">:</span> <span class="p">[</span><span class="bp">CKRecord</span><span class="p">]?,</span> <span class="n">error</span><span class="p">:</span> <span class="bp">NSError</span><span class="p">?)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// records will be an array of matching CKRecords</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">error</span><span class="p">?.</span><span class="n">errorCode</span> <span class="p">==</span> <span class="n">CKErrorCode</span><span class="p">.</span><span class="n">NotAuthenticated</span><span class="p">.</span><span class="n">rawValue</span> <span class="p">{</span>
        <span class="c1">// tell user he or she has to be logged in to iCloud for this to work!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// report other errors (there are 29 different CKErrorCodes!) </span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>One of the coolest features of Cloud Kit is its ability to <code>send push notifications</code> on changes. All you do is register an <code>NSPredicate</code> and whenever the database changes to match it,</p><h2>File System</h2>
<p>Sandbox包含：</p><ul>
<li>Application directory — Your executable, .jpgs, etc.; not writeable.</li>
<li>Documents directory — Permanent storage created by and always visible to the user.</li>
<li>Application Support directory — Permanent storage not seen directly by the user.</li>
<li>Caches directory — Store temporary files here (this is not backed up).</li>
<li>Other directories (see documentation)</li>
<li>...</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">url</span><span class="p">:</span> <span class="n">URL</span> <span class="p">=</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">url</span><span class="p">(</span>
    <span class="k">for</span> <span class="n">directory</span><span class="p">:</span> <span class="n">FileManager</span><span class="p">.</span><span class="n">SearchPathDirectory</span><span class="p">.</span><span class="n">documentDirectory</span><span class="p">,</span> <span class="c1">// for example </span>
    <span class="k">in</span> <span class="n">domainMask</span><span class="p">:</span> <span class="p">.</span><span class="n">userDomainMask</span> <span class="c1">// always .userDomainMask on iOS</span>
    <span class="n">appropriateFor</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="c1">// only meaningful for “replace” file operations</span>
    <span class="n">create</span><span class="p">:</span> <span class="kc">true</span> <span class="c1">// whether to create the system directory if it doesn’t already exist</span>
 <span class="p">)</span>
</pre></div>
<p>Examples of SearchPathDirectory values :</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">documentDirectory</span><span class="p">,</span> 
<span class="p">.</span><span class="n">applicationSupportDirectory</span><span class="p">,</span> 
<span class="p">.</span><span class="n">cachesDirectory</span><span class="p">,</span> 
<span class="n">etc</span><span class="p">.</span>
</pre></div>
<p>再列些常用api：</p><div class="highlight"><pre><span></span><span class="c1">// URL</span>

<span class="kd">func</span> <span class="nf">appendingPathComponent</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">URL</span>
<span class="kd">func</span> <span class="nf">appendingPathExtension</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">URL</span> <span class="c1">// e.g. “jpg”</span>
<span class="kd">var</span> <span class="nv">isFileURL</span><span class="p">:</span> <span class="nb">Bool</span> <span class="c1">// is this a file URL (whether file exists or not) or something else? </span>
<span class="kd">func</span> <span class="nf">resourceValues</span><span class="p">(</span><span class="k">for</span> <span class="n">keys</span><span class="p">:</span> <span class="p">[</span><span class="n">URLResourceKey</span><span class="p">])</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">URLResourceKey</span><span class="p">:</span><span class="nb">Any</span><span class="p">]?</span> 
<span class="c1">// Example keys: .creationDateKey, .isDirectoryKey, .fileSizeKey</span>

<span class="c1">// Data</span>

<span class="c1">// retrive binary data</span>
<span class="c1">// option almost always []</span>
<span class="kd">init</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="n">URL</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Data</span><span class="p">.</span><span class="n">ReadingOptions</span><span class="p">)</span> <span class="kr">throws</span> 
<span class="c1">// write</span>
<span class="c1">// The options can be things like .atomic (write to tmp file, then swap) or .withoutOverwriting.</span>
<span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">to</span> <span class="n">url</span><span class="p">:</span> <span class="n">URL</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Data</span><span class="p">.</span><span class="n">WritingOptions</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>

<span class="c1">// FileManager</span>
<span class="n">fileExists</span><span class="p">(</span><span class="n">atPath</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>
<span class="c1">// Can also create and enumerate directories; move, copy, delete files; etc.</span>
</pre></div>
<h2>Codable</h2>
<ul>
<li>保留一个对象所有的var（变量）的机制</li>
<li>如果一个Struct它的成员变是Codable的，那么Swift会帮你把这个Struct实现Codable，比如没有associated data的Enum。</li>
<li>帮你实现不代表不要显式声明</li>
<li>基础类型基本上都实现了Codable</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">object</span><span class="p">:</span> <span class="n">MyType</span> <span class="p">=</span> <span class="p">...</span>
<span class="c1">// encode</span>
<span class="kd">let</span> <span class="nv">jsonData</span><span class="p">:</span> <span class="n">Data</span><span class="p">?</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>

<span class="c1">// write file</span>
<span class="k">try</span> <span class="n">jsonData</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>

<span class="c1">// deocde as string</span>
<span class="kd">let</span> <span class="nv">jsonString</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">!,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span>

<span class="c1">// decode as object</span>
<span class="kd">let</span> <span class="nv">myObject</span><span class="p">:</span> <span class="n">MyType</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">MyType</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">!)</span>
<span class="c1">// 从字符串到对象没有一步到位的办法，只能先string-&gt;Data</span>
<span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">jsstring</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="c1">// 再把data传到上术方法里</span>
</pre></div>
<p>encode, decode是会throw的，注意try_catch相应的Error，比如<code>.keyNotFound, .dataCorrupted...</code></p><h3>CodingKeys</h3>
<p>json与对象相互进行转化有一个通用的需求，就是键的映射，这更常用在外部API与本地类的映射中，比如userId，别人叫guestId，等等，Swift中，用一个叫<code>CodingKeys</code>的枚举来实现这个映射：</p><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uid</span> <span class="p">=</span> <span class="s">&quot;user_id&quot;</span>
    <span class="k">case</span> <span class="n">someDate</span> <span class="p">=</span> <span class="s">&quot;some_date&quot;</span>
    <span class="k">case</span> <span class="n">pname</span> <span class="p">=</span> <span class="s">&quot;panme&quot;</span> <span class="c1">// 表示在JSON中也叫这个名字 </span>
    <span class="k">case</span> <span class="n">sku</span> <span class="c1">// 如果名字一样的话，可以这么简写 </span>
    <span class="c1">// 但是不写的话，序列化的时候就不会序列这个字段了</span>
    <span class="c1">// 解码时会有 KeyNotFound 类的错误</span>
<span class="p">}</span>

<span class="c1">// 结合起来，用在init中</span>
<span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
    <span class="c1">// container是切入点，要弄清楚</span>
    <span class="c1">// 如果没有手写键的映射表，那么keydBy就是自己</span>
    <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
    <span class="n">someDate</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">Date</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">someDate</span><span class="p">)</span> 
    <span class="c1">// 从json中加载.someDate对应的键的值，尝试解码成Date</span>
    <span class="c1">// other vars (每种case必须全部都有)</span>
<span class="p">}</span>
</pre></div>
<h3>Enum</h3>
<p>序列化枚举有点复杂：</p><ol>
<li>简单枚举应该怎么序列化？ 其实是序列化成case对应的名字和表示空JSON的<code>{}</code>组成的键值对，比如<code>{&quot;math&quot;:{}}</code></li>
<li>有关联数据的枚举呢？ 那就得自己提供<code>encoder</code>:<ul>
<li><code>case url: try container.encode(url, forKey: .url)</code> 即对相应的枚举值进行相应的encode</li>
</ul>
</li>
<li>并且自行decode，但是与struct（为每一个key填值）不同，因为枚举变量只是一个值，所以是依次尝试，解码成功就认定是那一个枚举值</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">url</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">URL</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">...</span> <span class="c1">// 别的尝试</span>

<span class="c1">// 此句的作用是根据.url对应的键名，取出值，反射成URL对象，如果成功，那么这个枚举值是.url无疑</span>
<span class="c1">// 而且关联数据就是反射的结果</span>
<span class="c1">// 如果失败，继续换一个键名，将对应的值转成对应的类型，依次类推</span>
</pre></div>
<ol start="4">
<li>那么如何手动decode一个原始的枚举呢？<ul>
<li>我们知道上述实践是为了反射出关联数据，并且根据能够成功反射关联数据来判断枚举类型</li>
<li>原始枚举需要encode哪个值呢？-&gt; 目前我只能做一个空<code>struct</code>来实现序列化成<code>{}</code>的目的 -&gt; 为了跟默认形态保持一致<ul>
<li>事实上你是可以encode成任意值的（比如100，&quot;hello&quot;，因为我们只关心有没有这个键，有的话，就是这个枚举类型，只是<code>{}</code>拥有可读性</li>
<li>你encode成什么值，decode的时候对对应的键尝试去反射回这个值就行了</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>最后，思考题：</p><blockquote>
<p>上面说了，原生枚举序列化成： <code>{&quot;math&quot;:{}}</code>，也说了，如果，键对应的值对原生枚举序列化是没意义的，可以是任何值，那么对于<code>{&quot;math&quot;:100}</code>，能否顺序序列化回其枚举形态<code>.math</code>呢？</p></blockquote>
<p>答案：</p><ol>
<li>值为100报错了</li>
<li>于是我改为&quot;&quot;或&quot;other“等字符串或空字符串，解码的结果是<code>nil</code></li>
</ol>
<p>也就是说，默认的decode只认<code>{}</code></p><figure  style="flex: 82.77310924369748" ><img width="1182" height="714" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c3a4240a7582937166f9300c35b4e868.png" alt=""/></figure><p>而前面我们知道了，如果是自己手写，它可以是任何值，它的意义仅仅是个标识，并不会取它的值。验证：</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">NormEnum</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">history</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">geometry</span>

    <span class="kd">private</span> <span class="kd">enum</span> <span class="nc">keyMap</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span><span class="p">{</span>
        <span class="k">case</span> <span class="n">history</span>  <span class="p">=</span> <span class="s">&quot;HIST&quot;</span>
        <span class="k">case</span> <span class="n">math</span>     <span class="p">=</span> <span class="s">&quot;MATH&quot;</span>
        <span class="k">case</span> <span class="n">geometry</span> <span class="p">=</span> <span class="s">&quot;GEOM&quot;</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="n">encoder</span><span class="p">:</span> <span class="n">Encoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">encoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">keyMap</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">switch</span> <span class="kc">self</span><span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">history</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">history</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">math</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">math</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">geometry</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">keyMap</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">history</span><span class="p">)</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">history</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">math</span><span class="p">)</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">math</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">geometry</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>上面的代码中，我将三个字段全部用空字符串编码，并且给了三个不同的键名，现在，我真入任意值，比如<code>&quot;HAHA&quot;</code>，解码看看：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">js2</span> <span class="p">=</span> <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">MATH</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\&quot;</span><span class="s">HAHA</span><span class="se">\&quot;</span><span class="s">}&quot;</span>
<span class="kd">let</span> <span class="nv">js2d</span> <span class="p">=</span> <span class="n">js2</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">myobj2</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">NormEnum</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">js2d</span><span class="p">!)</span>
</pre></div>
<p>结果成功认出myobj2是一个<code>.math</code>。原理当然是我的代码里在尝试转成一个字符串，而没有限定是什么字符串。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/" target="_self">cs193p_2021笔记[5]_Property-Wrapper</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Property Wrappers</h1>
<p>C#中的<code>Attributes</code>，python中的<code>Decorators</code>, Java的<code>Annonations</code>，类似的设计模式。</p><ul>
<li>A property wrapper is actually a <code>struct</code>.</li>
<li>这个特殊的<code>struct</code>封装了一些模板行为应用到它们wrap的vars上：<ol>
<li>Making a var live in the heap (<code>@State</code>)</li>
<li>Making a var publish its changes (<code>@Published</code>)</li>
<li>Causing a View to redraw when a published change is detected (<code>@ObservedObject</code>)</li>
</ol>
</li>
</ul>
<p>即能够分配到堆上，能够通知状态变化和能重绘等，可以理解为<code>语法糖</code>。</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">Published</span> <span class="kd">var</span> <span class="nv">emojiArt</span><span class="p">:</span> <span class="n">EmojiArt</span> <span class="p">=</span> <span class="n">EmojiArt</span><span class="p">()</span>

<span class="c1">// ... is really just this struct ...</span>
<span class="kd">struct</span> <span class="nc">Published</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="n">EmojiArt</span>
    <span class="kd">var</span> <span class="nv">projectedValue</span><span class="p">:</span> <span class="n">Publisher</span><span class="p">&lt;</span><span class="n">EmojiArt</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;</span>  <span class="c1">// i.e. $</span>
<span class="p">}</span>

<span class="c1">// `projected value`的类型取决于wrapper自己，比如本例就是一个`Publisher`</span>

<span class="c1">// 我理解为一个属性和一个广播器</span>

<span class="c1">// ... and Swift (approximately) makes these vars available to you ...</span>
<span class="kd">var</span> <span class="nv">_emojiArt</span><span class="p">:</span> <span class="n">Published</span> <span class="p">=</span> <span class="n">Published</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="n">EmojiArt</span><span class="p">())</span> 
<span class="kd">var</span> <span class="nv">emojiArt</span><span class="p">:</span> <span class="n">EmojiArt</span> <span class="p">{</span>
     <span class="kr">get</span> <span class="p">{</span> <span class="n">_emojiArt</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">}</span>
     <span class="kr">set</span> <span class="p">{</span> <span class="n">_emojiArt</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
<p>把get,set直接通过<code>$emojiArt</code>(即projectedValue)来使用</p><p>当一个<code>Published</code>值发生变化：</p><ul>
<li>It publishes the change through its <em>projectedValue</em> (<code>$emojiArt</code>) which is a <code>Publisher</code>.</li>
<li>It also invokes <code>objectWillChange.send()</code> in its enclosing <code>ObservableObject</code>.</li>
</ul>
<p>下面列的几种<code>Property wrapper</code>，我们主要关心最核心的两个概念，<code>wrappedValue</code>和<code>projectedValue</code>是什么就行了:</p><h2>@State</h2>
<p>这是第二次提到了，在<code>Property Observers</code>一节里预告过，基本上点<code>@</code>的，大都为<code>Property Wrapper</code>的内容。</p><ul>
<li>The wrappedValue is: <code>anything</code> (but almost certainly a value type).</li>
<li>What it does:<ul>
<li>stores the wrappedValue in the heap;</li>
<li>when it changes, <code>invalidates</code> the <code>View</code>.</li>
</ul>
</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to that <em>value in the heap</em>).</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span>
<span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_foo</span> <span class="p">=</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">initiaValue</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>注意<code>_</code>和<code>$</code>的区别。</p><h2>@StateObject &amp; @ObservedObject</h2>
<ul>
<li>The wrappedValue is: <code>anything</code> that implements the <code>ObservableObject</code> protocol (ViewModels).</li>
<li>What it does:<ul>
<li><code>invalidates</code> the <code>View</code> when wrappedValue does <em>objectWillChange.send()</em>.</li>
</ul>
</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to the vars of the wrappedValue (a <em>ViewModel</em>)).</li>
</ul>
<blockquote>
<p><strong>@StateObject V.S. @State</strong></p></blockquote>
<ul>
<li>一个类型是<code>ObservableObject</code>s， 一个是value type</li>
</ul>
<blockquote>
<p><strong>@StateObject V.S. @ObservedObject</strong></p></blockquote>
<ul>
<li>@StateObject is a &quot;source of truth&quot;，也就是说可以直接赋值：<code>@StateObject var foo = SomeObservableObject()</code></li>
<li>能用在<em>View, APP, Scene</em>等场景</li>
<li>如果用在View里，生命周期与View一致</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">@</span><span class="n">main</span>
<span class="kd">struct</span> <span class="nc">EmojiArtApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="c1">// stateObject, source of truth</span>
    <span class="c1">// defined in the app</span>
    <span class="p">@</span><span class="n">StateObject</span> <span class="kd">var</span> <span class="nv">paletteStore</span> <span class="p">=</span> <span class="n">PaletteStore</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&quot;default&quot;</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
    <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span> <span class="n">EmojiArtDocument</span><span class="p">()</span> <span class="p">})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
        <span class="n">EmojiArtDocumentView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="n">document</span><span class="p">)</span>
            <span class="p">.</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">paletteStore</span><span class="p">)</span>  <span class="c1">// passed by environment</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>@Binding</h2>
<ul>
<li>The wrappedValue is: <code>a value</code> that is bound to something else.</li>
<li>What it does:<ul>
<li>gets/sets the value of the wrappedValue from <code>some other source</code>.</li>
<li>when the bound-to value changes, it <code>invalidates</code> the <code>View</code>.</li>
<li>Form表单典型应用场景，有UI变化的控件</li>
<li>手势过程中的State, 或drag时是否targted</li>
<li>模态窗口的状态</li>
<li>分割view后共享状态</li>
<li>总之，数据源只有一个(source of the truth)的场景，就不需要用两个@State而用@Binding,</li>
</ul>
</li>
<li>Projected value (i.e. $): a Binding (self; i.e. the Binding itself)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">MyView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">State</span> <span class="kd">var</span> <span class="nv">myString</span> <span class="p">=</span> <span class="err">“</span><span class="n">Hello</span><span class="err">”</span>               <span class="c1">// 1</span>
      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">OtherView</span><span class="p">(</span><span class="n">sharedText</span><span class="p">:</span> <span class="err">$</span><span class="n">myString</span><span class="p">)</span>        <span class="c1">// 2</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">struct</span> <span class="nc">OtherView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">Binding</span> <span class="kd">var</span> <span class="nv">sharedText</span><span class="p">:</span> <span class="n">string</span>             <span class="c1">// 3</span>
      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">Text</span><span class="p">(</span><span class="n">sharedText</span><span class="p">)</span>                        <span class="c1">// 4</span>
          <span class="n">TextField</span><span class="p">(</span><span class="s">&quot;shared&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="err">$</span><span class="n">sharedText</span><span class="p">)</span>  <span class="c1">// 5 _myString.projectValue.projectValue</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>_myString</code>是实际变量，包含一个<code>wrappedValue</code>，一个<code>projectedValue</code></li>
<li><code>myString</code>就是<code>_myString.wrappedValue</code></li>
<li><code>$myString</code>是<code>_myString.projectedValue</code>，<ul>
<li>是一个<code>Binding&lt;String&gt;</code>，传值和接值用的就是它</li>
<li>所以传<code>$myString</code>的地方也可以用<code>_myString.projectedValue</code>代替，学习阶段的话</li>
</ul>
</li>
<li>要把<code>projectedValue</code>层层传递下去，并不是用同一个<code>projectedValue</code>，而是设计成了<code>Binding&lt;T&gt;</code><ul>
<li>参考上面代码块的第5条</li>
</ul>
</li>
</ol>
<p>其它</p><ul>
<li>也可以绑定一个常量：<code>OtherView(sharedText: .constant(“Howdy”))</code></li>
<li>computed binding: <code>Binding(get:, set:).</code></li>
</ul>
<p>比如你的view是一个小组件，里面有一个<code>Binding var user: User</code>，那么在preview里面怎么传入这个User呢？用常量：</p><div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kd">var</span> <span class="nv">preview</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
    <span class="n">myView</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="n">User</span><span class="p">(...)))</span>
<span class="p">}</span>
</pre></div>
<h2>@EnvironmenetObject</h2>
<ul>
<li>The wrappedValue is: <code>ObservableObject</code> obtained via .environmentObject() sent to the View.</li>
<li>What it does: <code>invalidates</code> the View when wrappedValue does objectWillChange.send().</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to the vars of the wrappedValue (a ViewModel)).</li>
</ul>
<p>与<code>@ObservedObject</code>用法稍有点不同，有单独的赋值接口：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myView</span> <span class="p">=</span> <span class="n">MyView</span><span class="p">().</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">theViewModel</span><span class="p">)</span>
<span class="c1">// 而@ObservedObject是一个普通的属性</span>
<span class="kd">let</span> <span class="nv">myView</span> <span class="p">=</span> <span class="n">MyView</span><span class="p">(</span><span class="n">viewModel</span><span class="p">:</span> <span class="n">theViewModel</span><span class="p">)</span>

<span class="c1">// Inside the View ...</span>
<span class="p">@</span><span class="n">EnvironmentObject</span> <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModelClass</span> 
<span class="c1">// ... vs ...</span>
<span class="p">@</span><span class="n">ObservedObject</span> <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModelClass</span>
</pre></div>
<ul>
<li>visible to all views in your body (except modallay presented ones)</li>
<li>多用于多个view共享ViewModel的时候</li>
</ul>
<h2>@Environment</h2>
<ul>
<li>与<code>@EnvironmentObject</code>完全不是同一个东西</li>
<li>这是<code>Property Wrapper</code>不只有两个变量（warped..., projected...）的的一个应用</li>
<li>通过<code>keyPath</code>来使用：<code>@Environment(\.colorScheme) var colorScheme</code></li>
<li>wrappedValue的类型是通过<code>keyPath</code>声明时设置的</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">view</span><span class="p">.</span><span class="n">environment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">,</span> <span class="p">.</span><span class="n">dark</span><span class="p">)</span>
</pre></div>
<p>so:</p><ul>
<li>The wrappedValue is: the value of some var in <code>EnvironmentValues</code>.</li>
<li>What it does: gets/sets a value of some var in <code>EnvironmentValues</code>.</li>
<li>Projected value (i.e. $): none.</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// someView pop 一个 modal 的 myView,传递 environment</span>
<span class="n">someView</span><span class="p">.</span><span class="n">sheet</span><span class="p">(</span><span class="n">isPresented</span><span class="p">:</span> <span class="n">myCondition</span><span class="p">){</span>
    <span class="n">myView</span><span class="p">(...</span><span class="kd">init</span><span class="p">...)</span>
    <span class="p">.</span><span class="n">enviroment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">,</span> <span class="n">colorScheme</span><span class="p">)</span> 
<span class="p">}</span>
</pre></div>
<p>除了深色模式，还有一个典型的应用场景就是编辑模式<code>\.editMode</code>，比如点了编辑按钮后。</p><blockquote>
<p><code>EditButton</code>是一个封装了UI和行为的控件，它只做一件事，就是更改<code>\.editmode</code>这个环境变量(的<code>isEditing</code>)</p></blockquote>
<h2>@Publisher</h2>
<p>It is an object that <code>emits values</code> and possibly a <code>failure object</code> if it fails while doing so.</p><div class="highlight"><pre><span></span><span class="n">Publisher</span><span class="p">&lt;</span><span class="n">Output</span><span class="p">,</span> <span class="n">Failure</span><span class="p">&gt;</span>
</pre></div>
<ul>
<li>Failure需要实现<code>Error</code>，如果没有，可以传<code>Never</code></li>
</ul>
<h3>订阅</h3>
<p>一种简单用法，<code>sink</code>:</p><div class="highlight"><pre><span></span><span class="n">cancellable</span> <span class="p">=</span> <span class="n">myPublisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span>
    <span class="n">receiveCompletion</span><span class="p">:{</span><span class="n">resultin</span><span class="p">...},</span> <span class="c1">//result is a Completion&lt;Failure&gt; enum</span>
        <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">thingThePublisherPublishes</span> <span class="k">in</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">}</span>
  <span class="p">)</span>
</pre></div>
<p>返回一个<code>Cancellable</code>，可以随时<code>.cancel()</code>，只要你持有这个<code>cancellable</code>，就能随时用这个sink</p><p>View有自己的订阅方式：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="n">publisher</span><span class="p">)</span> <span class="p">{</span> <span class="n">thingThePublisherPublishes</span> <span class="k">in</span>
    <span class="c1">// do whatever you want with thingThePublisherPublishes </span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>.onReceive</code> will automatically <code>invalidate</code> your View (causing a redraw).</li>
<li>既然参数是publisher，所以是一个binding的变量，即带<code>$</code>使用：</li>
</ol>
<div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="err">$</span><span class="n">aBindData</span><span class="p">)</span> <span class="p">{</span> <span class="n">bind_data</span> <span class="k">in</span> 
    <span class="c1">// my code</span>
<span class="p">}</span>
</pre></div>
<p>publisher来源：</p><ol>
<li><code>$</code> in front of vars marked <code>@Published</code><ul>
<li>还记得$就是取的projectedValue吗？</li>
<li>一般的projectedValue是一个<em>Binding</em>，Published的是是个<em>Publisher</em></li>
</ul>
</li>
<li>URLSession’s <code>dataTaskPublisher</code> (publishes the Data obtained from a URL)</li>
<li><code>Timer</code>’s publish(every:) (periodically publishes the current date and time as a Date)</li>
<li><code>NotificationCenter</code>’s publisher(for:) (publishes notifications when system events happen)</li>
</ol>
<blockquote>
<p>如果你有一个<code>ObservedObject</code>(Document)，它里面有一个<code>@Publisher</code>(background)，那么注意以下两者的区别：</p></blockquote>
<ul>
<li>document.<code>$</code>background: 是一个publisher</li>
<li><code>$</code>document.background: 是一个binding</li>
</ul>
<blockquote>
<p><code>.onReceive</code>只能接收<code>Publisher</code>的推送，而事实上，<code>onChange</code>（一般用于接收ObservedObject或State)同样也能接收Publisher。</p></blockquote>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/" target="_self">cs193p_2021笔记[4]_Color_Image_Gesture</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Color, UIColor &amp; CGColor</h1>
<p>Color:</p><ul>
<li>Is a color-specifier, e.g., <code>.foregroundColor(Color.green)</code>.</li>
<li>Can also act like a <code>ShapeStyle</code>, e.g., <code>.fill(Color.blue)</code>.</li>
<li>Can also act like a <code>View</code>, e.g., Color.white can appear <code>wherever</code> a View can appear.（可以当作view）</li>
</ul>
<p>UIColor:</p><ul>
<li>Is used to <code>manipulate</code> colors.（主打操控）</li>
<li>Also has many <code>more</code> built-in <code>colors</code> than <code>Color</code>, including “system-related” colors.(颜色更多)</li>
<li>Can be interrogated and can convert between color spaces.</li>
</ul>
<p>For example, you can get the RGBA values from a UIColor.
Once you have desired UIColor, employ <code>Color(uiColor:)</code> to use it in one of the roles above.</p><p>CGColor:</p><ul>
<li>The fundamental color representation in the Core Graphics drawing system</li>
<li><code>color.cgColor</code></li>
</ul>
<h1>Image V.S. UIImage</h1>
<p>Image:</p><ul>
<li>Primarily serves as a View.(主要功能是View)</li>
<li>Is <code>not</code> a type for vars that <code>hold an image</code> (i.e. a jpeg or gif or some such). That’s UIImage.</li>
<li>Access images in your Assets.xcassets (in Xcode) by name using <code>Image(_ name: String)</code>.</li>
<li>Also, many, many system images available via <code>Image(systemName:)</code>.</li>
<li>You can control the size of system images with <code>.imageScale()</code> View modifier.</li>
<li>System images also are affected by the .font modifier.</li>
<li>System images are also very useful <code>as masks</code> (for gradients, for example).</li>
</ul>
<p>UIImage</p><ul>
<li>Is the type for actually <code>creating/manipulating</code> images and <code>storing</code> in vars.</li>
<li>Very powerful representation of an image.</li>
<li>Multiple file formats, transformation primitives, animated images, etc.</li>
<li>Once you have the UIImage you want, use Image(uiImage:) to display it.</li>
</ul>
<h1>Multithreading</h1>
<ul>
<li>多线程其实并不是同时运行，而是前后台非常快速地切换</li>
<li><code>Queue</code>只是有顺序执行的代码，封装了<code>threading</code>的应用</li>
<li>这些“代码”用<code>closure</code>来传递</li>
<li><strong>main queue</strong>唯一能操作UI的线程<ul>
<li>主线程是单线程，所以不能执行异步代码</li>
</ul>
</li>
<li><strong>background queues</strong>执行任意：<em>long-lived, non-UI</em> tasks<ul>
<li>可以并行运行(running in parallel) -&gt; even with main UI queue</li>
<li>可以手动设置优先级，服务质量(<code>QoS</code>)等</li>
<li>优先级永远不可能超过main queue</li>
</ul>
</li>
<li>base API: GCD (<code>Grand Central Dispatch</code>)<ol>
<li>getting access to a queue</li>
<li>plopping a block of code on a queue</li>
</ol>
</li>
</ul>
<p>A: Creating a Queue</p><p>There are numerous ways to create a queue, but we’re only going to look at two ...</p><div class="highlight"><pre><span></span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span> <span class="c1">// the queue where all UI code must be posted</span>
<span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:</span> <span class="n">QoS</span><span class="p">)</span> <span class="c1">// a non-UI queue with a certain quality of service qos (quality of service) is one of the following ...</span>
    <span class="p">.</span><span class="n">userInteractive</span>    <span class="c1">// do this fast, the UI depends on it!</span>
    <span class="p">.</span><span class="n">userInitiated</span>  <span class="c1">// the user just asked to do this, so do it now</span>
    <span class="p">.</span><span class="n">utility</span>    <span class="c1">// this needs to happen, but the user didn’t just ask for it</span>
    <span class="p">.</span><span class="n">background</span> <span class="c1">// maintenance tasks (cleanups, etc.)</span>
</pre></div>
<p>B: Plopping a Closure onto a Queue</p><p>There are two basic ways to add a closure to a queue ...</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span> <span class="c1">//or</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:)</span> 
<span class="n">queue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span> <span class="cm">/* code to execute on queue */</span> <span class="p">}</span>
<span class="n">queue</span><span class="p">.</span><span class="n">sync</span> <span class="p">{</span> <span class="cm">/* code to execute on queue */</span> <span class="p">}</span>
</pre></div>
<p>主线程里永远不要<code>.sync</code>, 那样会阻塞UI</p><div class="highlight"><pre><span></span><span class="n">DispatchQueue</span><span class="p">(</span><span class="n">global</span><span class="p">:</span> <span class="p">.</span><span class="n">userInitiated</span><span class="p">).</span><span class="k">async</span> <span class="p">{</span>
    <span class="c1">// 耗时代码</span>
    <span class="c1">// 不阻塞UI，也不能更新UI</span>
    <span class="c1">// 到主线程去更新UI</span>
    <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// UI code can go here! we’re on the main queue! </span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h1>Gestures</h1>
<p>手势是iOS里的一等公民</p><div class="highlight"><pre><span></span><span class="c1">// recognize</span>
<span class="n">myView</span><span class="p">.</span><span class="n">gesture</span><span class="p">(</span><span class="n">theGesture</span><span class="p">)</span> <span class="c1">// theGesture must implement the Gesture protocol</span>

<span class="c1">// create</span>
<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">TapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">// double tap</span>
<span class="p">}</span>

<span class="c1">// discrete gestures</span>
<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">TapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 其实就是：</span>
<span class="kd">func</span> <span class="nf">theGesture</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
    <span class="n">tapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// “convenience versions”</span>
<span class="n">myView</span><span class="p">.</span><span class="n">onTapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span> 
<span class="n">myView</span><span class="p">.</span><span class="n">onLongPressGesture</span><span class="p">(...)</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>

<span class="c1">// non-discrete gestures</span>

<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
      <span class="n">DragGesture</span><span class="p">(...)</span>
<span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* do something */</span> <span class="p">}</span>
</pre></div>
<p>non-discrete手势里传递的<code>value</code>是一个state:</p><ul>
<li>For a <code>DragGesture</code>, it’s a struct with things like the <code>start and end location</code> of the fingers.</li>
<li>For a <code>MagnificationGesture</code> it’s the <code>scale</code> of the magnification (how far the fingers spread out).</li>
<li>For a <code>RotationGesture</code> it’s the <code>Angle</code> of the rotation (like the fingers were turning a dial).</li>
<li>还可以跟踪一个state: <code>@GestureState var myGestureState: MyGestureStateType = &lt;starting value&gt;</code></li>
</ul>
<p>唯一可以更新这个<code>myGestureState</code>的机会：</p><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
     <span class="n">DragGesture</span><span class="p">(...)</span>
        <span class="p">.</span><span class="n">updating</span><span class="p">(</span><span class="err">$</span><span class="n">myGestureState</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">myGestureState</span><span class="p">,</span> <span class="n">transaction</span> <span class="k">in</span> 
            <span class="n">myGestureState</span> <span class="p">=</span> <span class="cm">/* usually something related to value */</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* do something */</span> <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
<p>注意<code>$</code>的用法</p><p>如果不需要去计算一个<code>gestureState</code>传出去的话，有个<code>updating</code>用简版：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onChanged</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
<span class="cm">/* do something with value (which is the state of the fingers) */</span>
<span class="p">}</span>
</pre></div>
<p>事实上，目前来看<code>gestureState</code>只做了两件事：</p><ol>
<li>把实时手势对应的值保存起来</li>
<li>在手势结束时复原（对于缩放，变为1，对于移动，变为0）</li>
<li>同时，它是只读的，只在<code>.updating</code>方法里有更新的机会</li>
</ol>
<p>所以，如果你的UI和动画逻辑，用到了手势结束时的值（即需要它复原），那么你也可以直接在<code>.onEnded</code>方法里手动把它设回去，等同于你也实现了你的<code>gestureState</code>，并且没有它那些限制。</p><h2>Drag and Drop</h2>
<h3>Item Provider</h3>
<ul>
<li>The heart of drag nad drop is the <code>NSItemProvider</code> class.</li>
<li>It facilitates the transfer of data between processes (via drag and drop, for example)</li>
<li>It facilitates the transfer of a number of data types in iOS, for example:<ul>
<li>NSAttributedString and NSString</li>
<li>NSURL</li>
<li>UIImage and UIColor</li>
</ul>
</li>
<li>pre-Swift，所以需要bridging，比如：<code>String as NSString</code></li>
</ul>
<p>结合几个要点，一句话就能让你的元素能被拖动(drag)：</p><div class="highlight"><pre><span></span><span class="n">Text</span><span class="p">(</span><span class="n">emoji</span><span class="p">).</span><span class="n">onDrag</span><span class="p">{</span> <span class="bp">NSItemProvider</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="n">emoji</span> <span class="k">as</span> <span class="bp">NSString</span><span class="p">)}</span>
</pre></div>
<p>而接收(drop)则要复杂很多：</p><div class="highlight"><pre><span></span><span class="n">otherView</span><span class="p">.</span><span class="n">onDrop</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="p">[.</span><span class="n">plainText</span><span class="p">],</span> <span class="n">isTarget</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span><span class="n">providers</span><span class="p">,</span> <span class="n">location</span> <span class="k">in</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
</pre></div>
<ul>
<li>参接收的类型由<code>of</code>参数指定，这里假定是文本</li>
<li>方法里最终要返回一个bool值，表示成功接收与否，我返了个false，意思是你能让物体拖动，但是一松开手指就复原了</li>
</ul>
<p>从<code>itemprovider</code>里加载对象有模板代码：</p><div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">Array</span> <span class="k">where</span> <span class="n">Element</span> <span class="p">==</span> <span class="bp">NSItemProvider</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">loadObjects</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">ofType</span> <span class="n">theType</span><span class="p">:</span> <span class="n">T</span><span class="p">.</span><span class="kr">Type</span><span class="p">,</span> <span class="n">firstOnly</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span> <span class="n">using</span> <span class="n">load</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="bp">NSItemProviderReading</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">provider</span> <span class="p">=</span> <span class="bp">first</span><span class="p">(</span><span class="k">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">canLoadObject</span><span class="p">(</span><span class="n">ofClass</span><span class="p">:</span> <span class="n">theType</span><span class="p">)})</span> <span class="p">{</span>
      <span class="n">provider</span><span class="p">.</span><span class="n">loadObject</span><span class="p">(</span><span class="n">ofClass</span><span class="p">:</span> <span class="n">theType</span><span class="p">)</span> <span class="p">{</span> <span class="n">object</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">T</span> <span class="p">{</span>
          <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
              <span class="n">load</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

<span class="c1">// and</span>
<span class="c1">// where T: _ObjectiveCBridgeable, T._ObjectiveCType: NSItemProviderReading</span>
</pre></div>
<ol>
<li>提供了两段代码，可以看到其实就是对要加载的对象的约束不同，提供了对OC的兼容</li>
<li>模板代码演示了</li>
</ol>
<p>稳健地从拖拽对象加载内容（canload -&gt; load)
3. 真正的业务逻辑其实就是为拖进来的这个view选择一个位置存放（或读取它携带的数据）
4. <code>T.Type</code>传的是类别的<code>.self</code>，比如<code>String.self</code></p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/" target="_self">cs193p_2021笔记[3]_Animation_Transition</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Animation</h1>
<ul>
<li>One way to do animation is by animating a Shape.</li>
<li>The other way to do animation is to animate Views via their <code>ViewModifiers</code>.</li>
<li>Only <code>changes</code> can be animated<ul>
<li>ViewModifier arguments (not all, i.e. fonts)</li>
<li>Shapes</li>
<li>the <em>existance</em> of a View in the UI<ul>
<li>比如if-else和ForEach</li>
</ul>
</li>
</ul>
</li>
<li>You can only animate changes to Views in <em>containers that are already on screen</em> (<code>CTAAOS</code>).</li>
</ul>
<p>两个golden rule:</p><ol>
<li>要有view modifier的属性变化</li>
<li>要在屏幕上</li>
</ol>
<p>才会触发动画（其实就是上面的最后两条）</p><ul>
<li>课程的动画例子里，用了if-else来生成view，这样导致了新生成的view不会触发动画</li>
<li>比如点开两张牌，新点开的那张牌由于之前牌的内容并没有出现在屏幕上，导致动画没有触发</li>
<li>所以把view的结构由if-else的生成和销毁机制，变成了透明度切换机制<ul>
<li>即正面和反面都在屏幕上，只不过透明度相反，以在视觉上要么是正面要么是反面</li>
<li>本以为透明度为0就会销毁视图(UIKit？)，看样子并不是这样的，大胆用opacity就好了</li>
</ul>
</li>
</ul>
<h2>隐式调用</h2>
<div class="highlight"><pre><span></span><span class="n">Text</span><span class="p">(</span><span class="err">“👻</span> <span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">opacity</span><span class="p">(</span><span class="n">scary</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>                             <span class="c1">// 普通modifier, 即如果没有动画，也需要的状态（即代码也不会删）</span>
    <span class="p">.</span><span class="n">rotationEffect</span><span class="p">(</span><span class="n">Angle</span><span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">upsideDown</span> <span class="p">?</span> <span class="mi">180</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span>    <span class="c1">// 动画modifier，即定制的动画效果，不需要动画的时候，就不需要这一行</span>
    <span class="p">.</span><span class="n">animation</span><span class="p">(</span><span class="n">Animation</span><span class="p">.</span><span class="n">easeInOut</span><span class="p">)</span>                         <span class="c1">// 触发</span>
</pre></div>
<ul>
<li>上述所有<code>ViewModifier</code>都会被动画<ul>
<li><code>scary, upsideDown</code>等值改变时也会触发动画</li>
</ul>
</li>
<li>隐式调用会冒泡（所以不要对一个container view做<code>.animation</code>，还有定位的问题)</li>
<li>animation的参数就是一个struct： duration, delay, repeat, curve...</li>
</ul>
<p>对于不能动画的modifier，看一下这个实例（上为修改前，下为修改后）
<figure  style="flex: 51.452991452991455" ><img width="1204" height="1170" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4804373fb223c0a4333d720331093521.png" alt=""/></figure></p><ol>
<li>把font设为常量，把缩放变成一个geometric effect</li>
<li>同时也说明<code>.animation()</code>不止作用于它前面的</li>
</ol>
<h2>显式调用</h2>
<div class="highlight"><pre><span></span><span class="n">withAnimation</span><span class="p">(.</span><span class="n">linear</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// do something that will cause ViewModifier/Shape arguments to </span>
<span class="n">change</span> <span class="n">somewhere</span> <span class="p">}</span>
</pre></div>
<ul>
<li>It will appear in closures like <code>.onTapGesture</code>.</li>
<li>显式动画不会覆盖掉隐式动画</li>
<li>很少有处理用户手势而不包<code>.withAnimation</code>的</li>
</ul>
<h1>Transition</h1>
<ul>
<li>转场，主要用于view的出现和消失</li>
<li>一对<code>ViewModifier</code>，一个<code>before</code>, 一个<code>after</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="n">ZStack</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">isFaceUp</span> <span class="p">{</span>
        <span class="n">RoundedRectangle</span><span class="p">()</span> <span class="c1">// default .transition is .opacity </span>
        <span class="n">Text</span><span class="p">(</span><span class="err">“👻</span> <span class="err">”</span><span class="p">).</span><span class="n">transition</span><span class="p">(.</span><span class="n">scale</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mi">10</span><span class="p">).</span><span class="n">transition</span><span class="p">(.</span><span class="n">identity</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Unlike .animation(), .transition() does not get redistributed to a container’s content Views. So putting .transition() on the ZStack above only works if the entire ZStack came/went.</p><p>(Group and ForEach do distribute .transition() to their content Views, however.)</p><p>意思是<code>.transition</code>并不会向下传递，如果对<code>ZStack</code>做转场，只会把整个容器进行转场而不是里面的view（见实例二）</p><ul>
<li>转场只是一个声明，并没有触发动画（其实就是设置了<code>ViewModifier</code>）</li>
<li>所以转场没有隐式调用</li>
<li>只对CTAAOS有用</li>
</ul>
<p><code>.onAppear</code>或<code>.onDisappear</code>时，container必然是在屏幕上的，所以这是一个写<code>.transition</code>的好地方（记得要<code>withAnimation</code>)</p><p>built-in transitions:</p><ul>
<li>AnyTransition.opacity: 通过<code>.opacity</code> modifier来实现淡入淡出</li>
<li>AnyTransition.scale: 通过<code>.frame</code> modifier来实现缩放</li>
<li>AnyTransition.offset(CGSize): 通过<code>.offset</code>来实现移动</li>
<li>AnyTransition.modifier(active:identity:): 你提供两个<code>ViewModifier</code></li>
</ul>
<p>通过<code>AnyTransition.animation</code>(Animation`)来定制动画细节：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">transition</span><span class="p">(.</span><span class="n">opacity</span><span class="p">.</span><span class="n">animation</span><span class="p">(.</span><span class="n">linear</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="mi">20</span><span class="p">)))</span>
</pre></div>
<h1>动画机制</h1>
<p>其实就是给出一系列的数据点，系统会根据这些数据点把时间切分，你给的数据点越多，切的时间块也就越多，而且系统会根据你的线性函数来决定是平均还是怎样去切分这些时间块：</p><ul>
<li>the animation system divides the animation duration up into little pieces.</li>
<li>The animation system then tells the Shape/ViewModifier the current piece it should show.</li>
<li>And the Shape/ViewModifier makes sure that its code always reflects that.</li>
</ul>
<p>系统通知变量当前的值，UI根据这个值实时绘制当前的View，不断销毁重建，就是动画的过程。</p><p>系统是用一个变量来通知这个进度的：<code>Animatable</code> protocol的唯一成员变量：<code>animatableData</code>:</p><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">animatableData</span><span class="p">:</span> <span class="kr">Type</span>
</pre></div>
<ul>
<li>Type只需要满足<code>VectorArithmetic</code>协议，其实就是一个可以被细分的值，基本上是Float, Double, CGFloat，以及<code>AnimatablePair</code>(其实就是两个<code>VectorArithmetic</code>)</li>
<li>想要支持动画的<code>Shape</code>, <code>ViewModifier</code>，只需要实现<code>Animatable</code>协议即可（即提供一个<code>animatableData</code>属性）</li>
</ul>
<p>Because it’s communicating both ways, this animatableData is a <code>read-write</code> var.</p><ul>
<li>The <code>setting</code> of this var is the animation system telling the Shape/VM which piece to draw.</li>
<li>The <code>getting</code> of this var is the animation system getting the <code>start/end</code> points of an animation.</li>
</ul>
<p><strong>实例一</strong></p><figure  style="flex: 73.625" ><img width="1178" height="800" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/10d0bb779b10383a36d23d581f2fadb9.png" alt=""/></figure><ul>
<li>view modifier里面有一个变量<code>rotation</code>（ZStack, content, rotation3DEffect)</li>
<li>那么外层在<code>withAnimation{}</code>的时候，我们是期望rotation的值能动起来的<ul>
<li>内置的viewmodifier当然会自己动，如<code>opacity</code>等</li>
</ul>
</li>
<li>那么我们首先就要让<code>Cardify</code> conform to <code>Animatable</code>（例子中的AnimatableModifer = Animatable + ViewModifer)</li>
<li>然后我们就要实现<code>animatableData</code>, 因为系统事实上就是不断去更新这个data值</li>
<li>教材里把它进行了封装（当然你也可以直接用它），这只是思维方式上的区别</li>
<li><code>animatedData</code>会随时间变化，自然会不断invalidate view，然后rebuild view，动画就产生了。</li>
</ul>
<p><strong>实例二</strong></p><p>课程里有这么个需求：卡片由<code>LazyVGrid</code>提供布局，且卡片出现和消失的时候都要有动画。</p><p>出现和消失？那当然就是<code>Transition</code>的事了:</p><div class="highlight"><pre><span></span><span class="n">Card</span><span class="p">()</span>
  <span class="p">.</span><span class="n">transition</span><span class="p">(</span><span class="n">AnyTransition</span><span class="p">.</span><span class="n">asymmetric</span><span class="p">(</span><span class="n">insertion</span><span class="p">:</span> <span class="p">.</span><span class="n">scale</span><span class="p">,</span> 
                                         <span class="n">removal</span><span class="p">:</span> <span class="p">.</span><span class="n">opacity</span><span class="p">)))</span>
</pre></div>
<p>运行时发现消失的时候有动画，出现的动画却没有。原因是<code>transition</code>只会在<em>出现和消失</em>时触发，而我们的卡片是包在grid容器里的，所以grid出现在屏幕上的时候，就带着卡片一起出现了，transition并不会向下传递（前文也已经说过了，这里刚好印证）。</p><ol>
<li>所以解决方法当然可以“延迟”呈现这些卡片</li>
<li>课程里用了另一种方法，机制当然也是延迟，但不是那么地直白：</li>
</ol>
<figure  style="flex: 82.95774647887323" ><img width="1178" height="710" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e7e3ef2ac16296fabf73162c1fc678fa.png" alt=""/></figure><ul>
<li>就是利用了<code>.onAppear</code>来阻断容器和卡片的连续生成，而改用容器呈现后，再逐个“添加”的方式，让每一张卡片都有一个单独出现的机会</li>
<li>同时也必须利用<code>@State</code>, 让每添加一张卡片都会invalidate view一次</li>
<li>也能看出，animate能animate的就是属性和transition</li>
</ul>
<blockquote>
<p>当然，课程最后改成了“发牌”的机制，手动添加卡片，彻底阻断了卡片和容器一起出现的场景。</p></blockquote>
<p>这就带我们来到了实例三，同一个view在不同容器间的动画，怎么计算各自尺度下同一个view的位置：<code>matchedGeometryEffect</code></p><p><strong>实例三</strong></p><figure  style="flex: 73.45679012345678" ><img width="1190" height="810" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/08935bf9006d072875c203895aff17b7.png" alt=""/></figure><ul>
<li>想要有牌一张张发出去的效果，自然会想到添加延时</li>
<li>实现成了同时做动画，只不过越到后面的牌，延时越长（动作越慢），而不是我们想象的先后触发</li>
</ul>
<p>为了让不同的牌发出去时有立体效果，还以index为依据设置了<code>zIndex</code>，最终效果：</p><figure class="vertical-figure" style="flex: 24.608819345661452" ><img width="346" height="703" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c16a9ce3d925f64e63cdc14ebd2b5f59.gif" alt=""/></figure></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/" target="_self">cs193p_2021_笔记[2]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>本文涉及内容：<code>ViewModifier, Property Observers, Layout</code></p><hr />
<h1>ViewModifier</h1>
<p><code>.aspectRatio(2/3)</code> is likely something like <code>.modifier(AspectModifier(2/3))</code> AspectModifier can be <code>anything</code> that conforms to the <code>ViewModifier</code> protocol ...</p><p>它只有一个body方法：</p><div class="highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">ViewModifier</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">Content</span> <span class="c1">// this is a protocol’s version of a“don’t care” </span>
    <span class="kd">func</span> <span class="nf">body</span><span class="p">(</span><span class="n">content</span><span class="p">:</span> <span class="n">Content</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">some</span> <span class="n">View</span> <span class="n">that</span> <span class="n">represents</span> <span class="n">a</span> <span class="n">modification</span> <span class="n">of</span> <span class="n">content</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>对一个view调用<code>.modifier</code>就是把这个view传成了上述body方法的content</li>
<li>而从<code>.modifer</code>变成<code>.cardify</code>，不过是用了<code>extension</code>：</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">modifier</span><span class="p">(</span><span class="n">Cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="n">isFaceUp</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h1>Property Observers</h1>
<ul>
<li>语法长得像<code>computed var</code>, 但完全不是一回事 （get, set之于willSet, didSet）</li>
<li>willSet, didSet，对应newValue, oldValue</li>
</ul>
<h2>@State</h2>
<p>your view is <strong>Read Only</strong>,</p><p>为什么？</p><blockquote>
<p>因为view的生命周期足够短，基本上是不断地生成和销毁，根本不需要”被改变“</p></blockquote>
<ul>
<li>所以永远用<code>let</code></li>
<li>所以是<code>stateles</code>的</li>
</ul>
<p>这样的结构很简单，任何view的变化其实就是重绘。</p><p>仍然有些时候需要状态：</p><ul>
<li>编辑表单</li>
<li>模态窗口或通知窗口等临时窗口</li>
<li>动画需要追踪动画进度</li>
</ul>
<p>声明：</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">somethingTemporary</span><span class="p">:</span> <span class="n">SomeType</span> <span class="c1">// this can be of any type</span>
</pre></div>
<ul>
<li>private 表示别人访问不到</li>
<li>@State的的变化会在<strong>必要时</strong>引起重绘 （相当于一个<code>@ObservedObject</code>）</li>
<li>view会不断销毁和重建 -&gt; 指针会永远指向新的内存地址</li>
<li>而state是在堆上分配的空间</li>
<li>所以销毁和重建view并不会丢失state</li>
<li>后文<code>property wrapper</code>详述</li>
</ul>
<h1>Layout</h1>
<ol>
<li><code>Container</code>提供空间</li>
<li><code>Views</code>确定自身的大小</li>
<li><code>Container</code>提供<code>View</code>的位置</li>
<li><code>Container</code>确定自身大小（等同于#2)</li>
</ol>
<h2>HStack and VStack</h2>
<p>横/纵向排列元素(View)，并提供“尽可能小”的空间，根据元素性质，有三种场景：</p><ol>
<li><code>inflexble</code> view: <code>Image</code>，fixed size</li>
<li>slightly more flexible view: <code>Text</code>，适应文字的合适大小</li>
<li>very flexible view: <code>RoundedRectangle</code>: 占满空间 -&gt; 基本上<code>Shape</code>都会有多少空间占多少</li>
</ol>
<ul>
<li>一旦元素确定了size，多余的空间就会给下一个元素，最后<code>very flexible view</code>平均分配剩下的空间</li>
<li>所有元素大小确定，容器大小也就确定了，如果有<code>very flexible</code>的，那么容易本身也是<code>very flexible</code>的</li>
</ul>
<p>remark：</p><ul>
<li><code>Spacer(minLength: CGFloat)</code> 空格, draw nothing, 占尽可能多的空间</li>
<li><code>Divider()</code> 画条分隔线，占尽可能小的空间</li>
<li><code>.layoutPriority(100)</code> 用优先级来表示分配空间的顺序，默认值为0。后分配者如果没有空间了会用省略号表示</li>
<li><code>HStack(alignment: .leading)</code>用来控制元素的对齐</li>
</ul>
<blockquote>
<p>List, Form, OutlineGroup 其实就是 <code>really smart VStacks</code>，即本质上就是一个纵向排列的布局。</p></blockquote>
<h2>LazyHStack and LazyVStack</h2>
<ul>
<li><em>Lazy</em>的意思是如果元素对应的位置没有出现在屏幕上，就不会构建View.</li>
<li>they also size themselves to fit their views</li>
<li>前两条加一起，得出这个容器不会尽可能多的占用空间，即使含有very flexible的view -&gt; 尽可能小的空间</li>
<li>显然，它最多出现在<code>ScrollView</code>里（只有在有限窗口里滚动，才有可见不可见的差别）</li>
</ul>
<h2>Scrollview</h2>
<ul>
<li>给多少空间占多少空间</li>
</ul>
<h2>LazyHGrid and LazyVGrid</h2>
<ul>
<li>一个方向view数量固定，另一个方向动态增减（scroll）的H/V stack，以竖向的<code>LazyVGrid</code>为例：</li>
<li>确定每行元素个数，多少行由元素总数决定</li>
<li>或者确定元素大小，在行方向铺满后，再往下一行铺</li>
<li>HGrid方向则是先纵向铺满，再水平铺</li>
</ul>
<h2>ZStack</h2>
<ul>
<li>sizes itself to fit its children</li>
<li>can be very flexible (if one children is)</li>
</ul>
<p>两个modifier其实也是用的ZStack:</p><ul>
<li><code>.background</code>，插入一个view在底层，stack起来: <code>Text(&quot;hello&quot;).background(Rectangle().foregroundColor(.red))</code></li>
<li><code>.overlay</code>，覆盖到表层的zstack: <code>Circle().overlay(Text(&quot;hello&quot;), alignment:.center)</code></li>
</ul>
<p>More：</p><ul>
<li>一个view是可以选择任意size的，哪怕比给它的空间更大(产生裁剪)</li>
<li><code>.aspectRatio(2/3, contentMode: .fit)</code>如果是在HStack里，<ul>
<li>则是把元素横向排列后得到宽度，根据宽度计算出高度，得到元素大小</li>
<li><code>.fit</code>表示完整显示图片（就长边），短边部分补成黑色，<code>.fill</code>应该是就短边，长边部分就裁剪了</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">HStack</span> <span class="p">{</span>
    <span class="n">ForEach</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span> <span class="p">{</span> <span class="n">card</span> <span class="k">in</span>
        <span class="n">CardView</span><span class="p">(</span><span class="n">card</span><span class="p">).</span><span class="n">aspectRatio</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">contentMode</span><span class="p">:</span> <span class="p">.</span><span class="n">fit</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
    <span class="p">.</span><span class="n">foregroundColor</span><span class="p">(.</span><span class="n">orange</span><span class="p">)</span>
    <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
<ol>
<li>在能够分配的空间里，四边各减10 -&gt; padding(10)</li>
<li>减10后的空间里，根据aspectRation确定一个size</li>
<li>这个size应用给CardView</li>
<li>组合成HStack的size</li>
</ol>
<p>总大小就是HStack的size四边各加10</p><p>而View们如何知道能占多少空间？-&gt; <code>GeometryReader</code></p><h2>GeometryReader</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
    <span class="n">GeometryReader</span> <span class="p">{</span> <span class="n">geometry</span> <span class="k">in</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>参数<code>geometry</code>是一个<code>GeometryProxy</code>:</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">GeometryProxy</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">CGSize</span>
    <span class="kd">var</span> <span class="nv">safeAreaInsets</span><span class="err">：</span> <span class="n">EdgeInsets</span>
    <span class="kd">func</span> <span class="nf">frame</span><span class="p">(</span><span class="k">in</span><span class="p">:</span> <span class="n">CoordinateSpace</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">CGRect</span>
<span class="p">}</span>
</pre></div>
<ul>
<li><code>size</code>表示被提供了多少的空间（by its container)</li>
<li>并且不包含safe area（如刘海）</li>
<li>如果需要绘制到safe area里去: <code>ZStack{...}.edgesIgnoringSafeArea([.top])</code></li>
</ul>
<figure  style="flex: 127.6086956521739" ><img width="1174" height="460" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/aa2a99b80008d002cfc2521af182c43d.png" alt=""/></figure><p>图中演示的是设置卡片字体的大小，希望尽可能地填充卡片，<code>geometry.size</code>能给出运行时数据，而无需硬编码。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/" target="_self">cs193p_2021_笔记[1]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>2020年看了一遍，后来学深度学习去了，然后发现2021也出来了，仍然是视频授课（对我们没区别），看完后整理了两年课程的笔记。</p><p>本文涉及内容：<code>struct, enum, optional, protocol, viewbuilder, shape</code></p><h1>struct and class</h1>
<p>拥有差不多的结构</p><ul>
<li>stored vars</li>
<li>computed vars</li>
<li>constant lets</li>
<li>functions</li>
<li>initializers</li>
</ul>
<p>differents:
struct | class
-------|------
Value type | Reference type
Copied when passed or assigned | Passed around via pointers 
Copy on write | Automatically reference counted 
Functional programming | Object-oriented programming 
No inheritance | Inheritance (single) 
“Free”（缺省） init initializes ALL vars | “Free” init initializes NO vars 
Mutability must be explicitly stated | Always mutable (即使用let, 只表示不会改变指针)
Your “go to” data structure | Used in specific circumstances
Everything you’ve seen so far is a struct (except View which is a protocol) | The ViewModel in MVVM is always a class (also, UIKit (old style iOS) is class-based)</p><h1>泛型，函数类型,闭包</h1>
<ul>
<li>允许未知类型，但swift是强类型，所以用类型占位符，用作参数时参考.net的泛型</li>
<li>函数也是一种类型，可以当作变量，参数，出现在变量，参数的位置</li>
<li>in-line风格的函数叫<code>closure</code>(闭包)</li>
</ul>
<h1>enum</h1>
<ul>
<li>枚举是值类型</li>
<li>枚举的每个state都可以有<code>associated data</code>（等于是把每个state看成一个class/struct，associated data就可以理解为<strong>属性</strong>)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">FastFoodMenuItem</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">hamburger</span><span class="p">(</span><span class="n">numberOfPatties</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">fries</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">FryOrderSize</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">drink</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">ounces</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="c1">// the unnamed String is the brand, e.g. “Coke”</span>
    <span class="k">case</span> <span class="n">cookie</span> <span class="p">}</span>

<span class="kd">enum</span> <span class="nc">FryOrderSize</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">large</span>
    <span class="k">case</span> <span class="n">small</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">menuItem</span><span class="p">:</span> <span class="n">FastFoodMenuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="n">patties</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">otherItem</span><span class="p">:</span> <span class="n">FastFoodMenuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">cookie</span>
<span class="kd">var</span> <span class="nv">yetAnotherItem</span> <span class="p">=</span> <span class="p">.</span><span class="n">cookie</span> <span class="c1">// Swift can’t figure this out</span>
</pre></div>
<ol>
<li>FryOrderSize同时又是一个枚举</li>
<li>状态drink拥有两个“属性”，而且其中一个还<strong>未命名</strong></li>
</ol>
<h2>break and fall through/defaults</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">menuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">cookie</span>
<span class="k">switch</span> <span class="n">menuItem</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">:</span> <span class="k">break</span>  <span class="c1">// break</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">fries</span><span class="err">”</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">other</span><span class="err">”</span><span class="p">)</span> <span class="c1">// default</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>如果把drink写上，但没有方法体，则叫<code>fall through</code>，只会往后面一个state fall through</li>
<li>如果漏写了drink，则会匹配到default项（cookie同理）</li>
</ol>
<h2>with associated data</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">menuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="err">“</span><span class="n">Coke</span><span class="err">”</span><span class="p">,</span> <span class="n">ounces</span><span class="p">:</span> <span class="mi">32</span><span class="p">)</span>
  <span class="k">switch</span> <span class="n">menuItem</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="kd">let</span> <span class="nv">pattyCount</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="n">burger</span> <span class="n">with</span> <span class="err">\</span><span class="p">(</span><span class="n">pattyCount</span><span class="p">)</span> <span class="n">patties</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">(</span><span class="kd">let</span> <span class="nv">size</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="err">\</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fries</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="kd">let</span> <span class="nv">brand</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">ounces</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="err">\</span><span class="p">(</span><span class="n">ounces</span><span class="p">)</span><span class="n">oz</span> <span class="err">\</span><span class="p">(</span><span class="n">brand</span><span class="p">)</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">cookie</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="n">cookie</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
 <span class="p">}</span>
</pre></div>
<h2>可以拥有方法</h2>
<p>这就可以扩展出computed vars</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">FastFoodMenuItem</span> <span class="p">{</span> <span class="p">...</span>
      <span class="kd">func</span> <span class="nf">isIncludedInSpecialOrder</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
          <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="kd">let</span> <span class="nv">pattyCount</span><span class="p">):</span> <span class="k">return</span> <span class="n">pattyCount</span> <span class="p">==</span> <span class="n">number</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">,</span> <span class="p">.</span><span class="n">cookie</span><span class="p">:</span> <span class="k">return</span> <span class="kc">true</span> <span class="c1">// a drink and cookie in every special order </span>
            <span class="k">case</span> <span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="kc">_</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">ounces</span><span class="p">):</span> <span class="k">return</span> <span class="n">ounces</span> <span class="p">==</span> <span class="mi">16</span> <span class="c1">// &amp; 16oz drink of any kind</span>
 <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>Iterable</h2>
<p>conform <code>CaseIterable</code>协议就能被遍历，因为增加了一个<code>allCases</code>的静态变量：</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">TeslaModel</span><span class="p">:</span> <span class="n">CaseIterable</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">X</span>
      <span class="k">case</span> <span class="n">S</span>
      <span class="k">case</span> <span class="n">Three</span>
      <span class="k">case</span> <span class="n">Y</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">model</span> <span class="k">in</span> <span class="n">TeslaModel</span><span class="p">.</span><span class="n">allCases</span> <span class="p">{</span>
    <span class="n">reportSalesNumbers</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">reportSalesNumbers</span><span class="p">(</span><span class="k">for</span> <span class="n">model</span><span class="p">:</span> <span class="n">TeslaModel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">model</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>SwiftUI实例， <code>LazyVGrid</code>中：</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">GridItem</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kd">enum</span> <span class="nc">Size</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">adaptive</span><span class="p">(</span><span class="n">minimum</span><span class="p">:</span> <span class="n">CGFloat</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="p">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">fixed</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">flexible</span><span class="p">(</span><span class="n">minimum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="p">.</span><span class="n">infinity</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>associated data</code>还能带默认值</li>
<li>核心作用是告诉系统griditem的size是采用哪种方案（枚举），顺便设置了这种方案下的参数。所以这种场景在swift下完全可以用枚举做到</li>
</ol>
<h1>Optionals</h1>
<p>可靠类型其实就是一个<code>Enum</code></p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">Optional</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span> <span class="c1">// a generic type, like Array&lt;Element&gt; or MemoryGame&lt;CardContent&gt; </span>
    <span class="k">case</span> <span class="kr">none</span>
    <span class="k">case</span> <span class="n">some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1">// the some case has associated value of type T }</span>
</pre></div>
<p>它只有两个状态，要么是none，要么就是is set的状态，具体的值其实是绑定到了<code>associate data</code>里去了</p><p>所以你现在知道了有一种取法其实就是从<code>some</code>里面来取了。</p><h2>语法糖</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="err">“</span><span class="n">hello</span><span class="err">”</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="c1">// 其实是：</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="kr">none</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="kr">none</span>
</pre></div>
<p>使用：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
<span class="bp">print</span><span class="p">(</span><span class="n">hello</span><span class="p">!)</span> 
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="c1">// raise an exception (crash) </span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">safehello</span> <span class="p">=</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">safehello</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// do something else</span>
<span class="p">}</span>
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// do something else } </span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 还有一种：</span>

<span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">x</span> <span class="p">??</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span>
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="n">y</span> <span class="p">=</span> <span class="n">data</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>所以用<code>!</code>来解包是会报错的原理在此</li>
<li><code>guard</code>的原理同样是<code>switch</code></li>
<li>默认值的原理你应该也能猜到了</li>
<li>三个语法糖，对应的底层就是一句switch，其实就是<code>.none</code>时的三种处理方案</li>
</ol>
<p>当然，还可以<code>chain</code>起来
let x: String? = ...
let y = x?foo()?bar?.z</p><p>// 尝试还原一下：</p><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xval</span><span class="p">)::</span>
        <span class="k">switch</span> <span class="n">xval</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xfooval</span><span class="p">):</span>
                <span class="k">switch</span> <span class="n">xfooval</span><span class="p">.</span><span class="n">bar</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
                    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xfbarval</span><span class="p">):</span>
                        <span class="n">y</span> <span class="p">=</span> <span class="n">xfbarval</span><span class="p">.</span><span class="n">z</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>记住每一个句号对应一个switch，然后在<code>.none</code>的状态下安全退出就是<code>?</code>的用法了。</p><h1>@ViewBuilder</h1>
<ol>
<li>任意<code>func</code>或<code>只读的计算属性</code>都可以标识为<code>@ViewBuilder</code>，一旦标识，它里面的内容将会被解析为<code>a list of Views</code>（也仅仅是这个，最多再加上if-else来选择是“哪些view”，不能再定义变量和写其它代码了）<ul>
<li>一个典型例子就是View里面扣出来的代码(比如子view)做成方法，这个方法是需要加上@ViewBuilder的</li>
<li>或者改语法</li>
<li>或者只有一个View，就不会产生语法歧义，也是可以不加@ViewBuilder的</li>
</ul>
</li>
<li>所以不需要return，而如果你不打标，也是可以通过return来构建view的<ul>
<li>但是就不支持默认返回list或通过if-else返view list的语法了</li>
</ul>
</li>
<li><code>@ViewBuilder</code>也可以标识为方法的参数，表示需要接受一个返回views的函数</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">init</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="p">[</span><span class="n">Item</span><span class="p">],</span> <span class="p">@</span><span class="n">ViewBuilder</span> <span class="n">content</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">Item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ItemView</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
<p>同时也注意一下<code>@escaping</code>，凡是函数返回后才可能被调用的闭包（逃逸闭包）就需要，而我们的view是在需要的时候才创建，或反复移除并重建（重绘）的，显然符合逃逸闭包的特征。</p><blockquote>
<p>viewbuilder支持的控制流程代码指的是<code>if-else</code>和<code>ForEach</code>, 所以<code>for...in...</code>是不行的。</p></blockquote>
<h1>Protocol</h1>
<p>接口，协议，约束... 使用场景：</p><ul>
<li>用作类型(Type):<ul>
<li>func travelAround(using moveable: Moveable)</li>
<li>let foo = [Moveable]</li>
</ul>
</li>
<li>用作接口:<ul>
<li>struct cardView: View</li>
<li>class myGame: ObservableObject</li>
<li>behaviors: Identifiable, Hashable, ... Animatable</li>
</ul>
</li>
<li>用作约束：
  struct Game<Content> <code>where</code> Content: Equtable   // 类
  extension Array <code>where</code> Element: Hashable {...}  // 扩展
  init(data: Data) <code>where</code> Data: Collection, Data.Element: Identifiable // 方法</li>
<li>OC里的delegate</li>
<li>code sharing (by <code>extension</code>)<ul>
<li><code>extension</code> to a protocol</li>
<li>this is how Views get forecolor, font and all their other modifiers</li>
<li>also `firstIndex(where:) get implemented</li>
<li>an <code>extension</code> can add <em>default implementation</em> for a func or a var<ul>
<li>that's how <code>objectWillChange</code> comes from</li>
</ul>
</li>
<li><code>extension</code>可以作用到所有服从同一协议的对象<ul>
<li>func filter(_ isIncluded: (Element) -&gt; Bool) -&gt; Array<Element></li>
<li>只为<code>Sequence</code> protocol写了一份filter的扩展代码，但能作用于Array, Range, String, Dictionary</li>
<li>等一切conform to the <code>Sequence</code> protocol的类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SwiftUI的<code>View</code> protocol非常简单，conform 一个返回<code>some view</code>的<code>body</code>方法就行了，但是又为它写了无数<code>extension</code>，比如<code>foregroundColor</code>, <code>padding</code>, etc. 示意图：</p><figure  style="flex: 146.20253164556962" ><img width="924" height="316" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/9bfb49031e316c1d1d1bc4a5d6b57427.png" alt=""/></figure><h2>Generics(泛型)</h2>
<p>举例：</p><div class="highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">Identifiable</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">ID</span><span class="p">:</span> <span class="nb">Hashable</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="n">ID</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>不像struct，protocol并不是用<code>Identifiable&lt;ID&gt;</code>来表示泛型，而是在作用域内定义</li>
<li>上例中，ID既定义了类别别名，还规范了约束</li>
</ol>
<ul>
<li>所以你Identifiable的类, 是需要有一个Hashable的ID的</li>
<li>而Hashable的对象，又是需要Equatable的(因为hash会碰撞出相同的结果，需要提供检查相等的方法)</li>
<li>-&gt; <code>protocol inheritancee</code></li>
</ul>
<h1>Shape</h1>
<ul>
<li>Shape is a <code>protocol</code> that inherits from <code>View</code>.</li>
<li>In other words, all Shapes are also Views.</li>
<li>Examples of Shapes already in SwiftUI: RoundedRectangle, Circle, Capsule, etc.</li>
<li>by default, Shapes draw themselfs by <code>filling</code> with the current foreground color.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">fill</span><span class="p">&lt;</span><span class="n">S</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">whatToFillWith</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">view</span> <span class="k">where</span> <span class="n">S</span><span class="p">:</span> <span class="n">ShapeStyle</span>
</pre></div>
<p><code>ShapeStyle</code> protocol turns a <code>Shape</code> into a <code>View</code>: Color, ImagePaint, AngularGradinet, LinearGradient</p><p>自定义shape最好用path(系统的已经通过extension实现好了view的body)：</p><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">path</span><span class="p">(</span><span class="k">in</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Path</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="n">Path</span> 
<span class="p">}</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/page/2/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/4/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 walker</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>