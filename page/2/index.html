<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/66077cf5542cc50c8af36c6d25f0819c.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="walker" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/2/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">理解Core-Graphics的Clipping和填充模式</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">
                <time class="text-uppercase">
                    November 28 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>先来看一个例子
<figure class="vertical-figure" style="flex: 38.76146788990825" ><img width="338" height="436" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d5fdc49bd6037d399e4685d3cf9d72bf.png" alt=""/></figure>
画一个箭头，其中箭尾有分叉，一般来说，是画一个三角，画一个矩形（实心矩形一般也直接用很粗的线条），最后再叠一个三角（with <code>CGBlendModel.clear</code>)，这里就不多介绍了：</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>       
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">()</span>
    <span class="c1">// shaft</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">lineWidth</span> <span class="p">=</span> <span class="mi">20</span>
    <span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>

    <span class="c1">// point</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>

    <span class="c1">// snip</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">with</span><span class="p">:</span><span class="n">CGBlendMode</span><span class="p">.</span><span class="n">clear</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>我们来看看<code>clipping</code>怎么用</p><ol>
<li>fill三角箭头（出于堆叠上目的可以最后画）</li>
<li>找到箭尾的三个顶点<ul>
<li>用<code>boundingBoxOfClipPath</code>来创建整个画板大小的矩形</li>
<li>应用<code>clipping</code>把小三角挖掉</li>
</ul>
</li>
</ol>
<p>3，画一根黄色箭柄粗细的线（从底向上）
    * 因为小三角区域被clipping掉了，结果就成了图示的模样</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// obtain the current graphics context</span>
        <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>

        <span class="c1">// punch triangular hole in context clipping region</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">90</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">90</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">closePath</span><span class="p">()</span>
        <span class="c1">// 添加整个区域为rect</span>
        <span class="c1">// 然后再clip设定为不渲染的区域</span>
        <span class="c1">// 后续的渲染全会避开这个区域</span>
        <span class="c1">// 我们后面把这个rect设为蓝色试试(顺便改为一个小一点的rect)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">con</span><span class="p">.</span><span class="n">boundingBoxOfClipPath</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">using</span><span class="p">:.</span><span class="n">evenOdd</span><span class="p">)</span>
<span class="c1">//        con.fillPath()</span>

        <span class="c1">// draw the vertical line</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setStrokeColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">19</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">strokePath</span><span class="p">()</span>

        <span class="c1">// draw the red triangle, the point of the arrow</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">120</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
    <span class="p">}</span>
</pre></div>
<p>能够完美run起来，但是我对clipping的机制还是有点不理解，一些关键点的讲解，和我的问题，一条条过：</p><ol>
<li>我们用构建了箭尾的三角形，然后<code>closePath</code>，那是因为我们只画了两条线，如果事实上第三条线连回了原点，那么这个<code>closePath</code>就不需要了</li>
</ol>
<ul>
<li>（图一）演示了不close的话就直接只有两条线了</li>
</ul>
<ol start="2">
<li>我想看看clipping到底发生了啥，于是注释掉了clip的那一行，得到了（图二）</li>
</ol>
<ul>
<li>之所以长那样是因为随后设置了stroke的参数（20像素的黄色）</li>
<li>stroke时，画板上有三个元素：一个三角，一个矩形，一条线段，全部用20宽的黄线描边了，一切如预期</li>
</ul>
<ol start="3">
<li>于是我尝试添加rect时只取了中间一小块，并涂成蓝色，不clip试试，得到（图三）。</li>
<li>知道了新rect的位置，把clip加回来，发现箭尾有了，箭头却没了（图四）</li>
<li>rect与clip的关系已经出来了，尝试把红三角的y通通加50，移到了蓝矩形范围内，得到证明（图五）</li>
</ol>
<figure  style="flex: 58.108108108108105" ><img width="774" height="666" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/83a72f77f3c1af59c2e83c0616699ca5.png" alt=""/></figure><p>那么clipping到底能对哪些起作用呢？是上面的rect吗？<strong>当然不是</strong>！</p><p>在clip方法被调用的时候，画布里有多少封闭元素，就会被应用clip。由于我们选择的是<code>evenOdd</code>模式，那么就会简单计数，某像素覆盖奇数次显示，偶数次则不显示。</p><p>上例中，<code>con.clip(using:)</code>方法调用时，画布里有两个封闭元素，一个三角，一个矩形，三角包在矩形里，那么计数为2，就不予显示了。</p><blockquote>
<p>事实上，判定奇偶的依据是该点向外做无限长的射线，判定有几条边与射线相交。同时，同样的设定可以用来解释<code>.winding</code>模式，即不但与相交的边有交，还与相交时，那条边是顺时针方向绘制的（+1）还是逆时针方向绘制的（-1）,总结果为0则不填充。<a href="https://www.jianshu.com/p/5cf8048b083b">参考</a></p></blockquote>
<p>那就玩一玩验证下吧</p><ol>
<li>把矩形改成了圆圈，线宽也改小一点，得到（图一）<em>绿色三角形是我后加的，因为被黄实线盖住了</em></li>
<li>再在里面添加了一个小圆，得到（图二）</li>
<li>这时候按照奇偶原则，小圆里的像素是偶数，而小圆里的三角则是奇数了，那么应该就只有大圆减掉小圆的部分，和小圆内的三角会被渲染了（图三），与预期一致</li>
</ol>
<figure  style="flex: 137.00564971751413" ><img width="970" height="354" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/84aa194f6e13d2f92fe6e9929e5c7110.png" alt=""/></figure><p>现在再来回顾书上先套一个画布大小的矩形，再画一个三角形，你大概应该知道目的了（凑奇偶），我们矩形区域过小时绘制不了红色三角，纯粹也是因为奇数，往下移到矩形区域内，立马变偶数了。(当然，要在原位置渲染我们可以先中止clip:<code>con.resetClip()</code>再绘图）</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Thread-in-iOS/" target="_self">Programming iOS 14 - Threading</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Thread-in-iOS/" target="_self">
                <time class="text-uppercase">
                    November 26 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第25章</p><hr />
<h1>Thread</h1>
<p>Thread在开发过程中基本上线程是隐形的，你感知不到，因为大多数情况下，程序只（需要）跑在主线程上，这是没有问题的：</p><ul>
<li>你的代码事实上执行得非常快，你感知不到</li>
<li>响应逻辑过程锁死UI，是安全的操作</li>
</ul>
<p>原生的后台线程：</p><ul>
<li>动画：The Core Animation framework is running the animation and updating the presentation layer on a background thread.</li>
<li>网络：A web view’s fetching and loading of its content is asynchronous</li>
<li>影音：Sounds are played asynchronously. Loading, preparation, and playing of movies happens asynchronously.</li>
<li>存盘：UIDocument saves and reads on a background thread.</li>
</ul>
<p>但所有的<code>complete functions / delegations / notification</code> 都是在主线程被调用的</p><p>多线程的问题</p><ul>
<li>调用时机/顺序不可控，次数也不可控，随时可能被执行</li>
<li>数据的线程安全，不得不借助“锁”的机制来保证（race condition）<ul>
<li>a lock is an <code>invitation</code> to <em>forget</em> to use the lock, or to <em>forget</em> to remove the lock after you’ve set it.</li>
</ul>
</li>
<li>The lifetime of a thread is independent of the lifetimes of other objects in your app.<ul>
<li>一个对象的退出不能保证有后台线程将来会调用它 -&gt; 闪退或Zombie</li>
</ul>
</li>
<li>Hard to debug.</li>
</ul>
<p>XCode对debug的支持：</p><ul>
<li>Debug navigator</li>
<li><code>NSLog / os_log / Logger</code> outputs</li>
<li>Instruments &gt; Time Profiler</li>
<li>Thread Sanitizer, Main Thread Checker (项目配置 &gt; Diagnostics)</li>
</ul>
<p>执行后台线程的方法：</p><h2>Manual Threading</h2>
<p><code>performSelector(inBackground:with:)</code></p><ul>
<li>只能传一个参数，多个参数要打包</li>
<li>手动管理内存 -&gt; wrap every thing in an autorelease pool</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
        <span class="c1">// 这里打包参数为一个字典</span>
        <span class="kd">let</span> <span class="nv">d</span> <span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">]</span> <span class="p">=</span>
            <span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">:</span><span class="n">center</span><span class="p">,</span> <span class="s">&quot;bounds&quot;</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="s">&quot;zoom&quot;</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">inBackground</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">reallyDraw</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">}</span>
<span class="c1">// trampoline, background thread entry point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">reallyDraw</span><span class="p">(</span><span class="kc">_</span> <span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// 手动控制内存</span>
    <span class="n">autoreleasepool</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGPoint</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;bounds&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGRect</span><span class="p">,</span>
            <span class="n">zoom</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;zoom&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGFloat</span><span class="p">)</span>
        <span class="c1">// 手动回调主线程</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">onMainThread</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">allDone</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
            <span class="n">waitUntilDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>

<span class="p">}</span>
<span class="c1">// called on main thread! background thread exit point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">allDone</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>即便如此，还是没有解决不同线程使用同一个实例变量（如<code>bitmapContext</code>）造成程序非常脆弱的问题，得进一步使用<code>lock</code>等机制。</p><h2>Operation</h2>
<ul>
<li>将<code>thread</code>封装成<code>task</code>，表示成<code>Operation</code> 通过 <code>OperationQueue</code>来操作。</li>
<li>回调机制变成了通知机制（或<code>KVO</code>）</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">queue</span> <span class="p">:</span> <span class="n">OperationQueue</span> <span class="p">=</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
    <span class="c1">// ... further configurations can go here ...</span>
    <span class="k">return</span> <span class="n">q</span>
<span class="p">}()</span>

<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="c1">// 也可以用 BlcokOperation</span>
    <span class="c1">// 来执行你的耗时操作</span>
    <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">MyMandelbrotOperation</span><span class="p">(</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 通知/回调</span>
    <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
        <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">operationFinished</span><span class="p">),</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
    <span class="c1">// 结合起来</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>而一个<code>Operation</code>子类包含两个部分：</p><ol>
<li>A designated initializer<ul>
<li>你可以把需要的参数设计成对应的属性，并初始化好它</li>
</ul>
</li>
<li>A main method<ul>
<li>耗程序真正执行的地方，OperationQueue执行到这个Operation的时候就会被自动执行</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">MyMandelbrotOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">mandelOpFinished</span> <span class="p">=</span> <span class="n">Notification</span><span class="p">.</span><span class="n">Name</span><span class="p">(</span><span class="s">&quot;mandelOpFinished&quot;</span><span class="p">)</span>

    <span class="c1">// 1. params -&gt; arguments</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">center</span> <span class="p">:</span> <span class="n">CGPoint</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">:</span> <span class="n">CGRect</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">zoom</span> <span class="p">:</span> <span class="n">CGFloat</span>
    <span class="kd">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">bitmapContext</span> <span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span> <span class="p">=</span> <span class="kc">nil</span>  <span class="c1">// 封装成了类属性，不再线程共享</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">center</span> <span class="n">c</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span> <span class="n">b</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span> <span class="n">z</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">c</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span> <span class="p">=</span> <span class="n">z</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// 1.1 logic</span>
    <span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
    <span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>

    <span class="c1">// 2. main</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 首先要检查isCancelled</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span><span class="p">}</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="p">{</span>
            <span class="c1">// 完成通知，也可以用KVO机制</span>
            <span class="c1">// 主线程接收到后要立即处理，因为OpearationQueue将会立即释放这个Operation</span>
            <span class="c1">// 此外，接收通知可能也不在主线程，-&gt; GCD</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 3. observer</span>
<span class="c1">// 就是前面在主线程里注册监听消息的方法</span>
<span class="c1">// warning! called on background thread</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">operationFinished</span><span class="p">(</span><span class="kc">_</span> <span class="n">n</span><span class="p">:</span><span class="n">Notification</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">MyMandelbrotOperation</span> <span class="p">{</span>
        <span class="c1">// 1. 主线程（GCD）</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="c1">// 2. 移除通知监听</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">op</span><span class="p">.</span><span class="n">bitmapContext</span>  <span class="c1">// 传回这个之前是线程共享的变量</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>注意<code>bitmapContext</code>这个之前主线程设置，然后后台线程共享的变量，现在由Operation这个类自己持有，结束时才赋值回主线程。</p><p>此外，还能限制并发数量：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
<span class="n">q</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="p">=</span> <span class="mi">1</span>
</pre></div>
<p>This turns the OperationQueue into a <code>serial queue</code>.</p><p>最后，解决最后一个问题，即你的调用者都没了，比如ViewController没了，调用者没了，后台任务也理应取消（下载、存盘类不需要UI交互的除外）</p><div class="highlight"><pre><span></span><span class="kd">deinit</span><span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">cancelAllOperations</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>至此，前面提到的一些多线程会带来的问题如调用时机和数量不可控，跨线程数据安全，以及生命周期等问题，<code>Operation</code>都完美解决并封装了。</p><p>设置优先级，QoS, 依赖等一些进阶示例：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">backgroundOperation</span> <span class="p">=</span> <span class="bp">NSOperation</span><span class="p">()</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">queuePriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">Low</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">qualityOfService</span> <span class="p">=</span> <span class="p">.</span><span class="n">Background</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">backgroundOperation</span><span class="p">)</span>

<span class="c1">// dependence</span>
<span class="kd">let</span> <span class="nv">networkingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="kd">let</span> <span class="nv">resizingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="n">resizingOperation</span><span class="p">.</span><span class="n">addDependency</span><span class="p">(</span><span class="n">networkingOperation</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="c1">// 虽然resizing添加了network为依赖，但是还是需要全部加到队列里</span>
<span class="c1">// 不要以为加了尾部operation就能把依赖全加进去</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperations</span><span class="p">([</span><span class="n">networkingOperation</span><span class="p">,</span> <span class="n">resizingOperation</span><span class="p">],</span> <span class="n">waitUntilFinished</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
</pre></div>
<h2>Grand Central Dispatch</h2>
<p>可以认为GCD是更底层的Operation，它甚至直接嵌入了操作系统，能被任何代码执行而且非常高效。调用过程也与Operation差不多:</p><ul>
<li>表示一个task</li>
<li>加入一个queue<ul>
<li>GCD Queue也被表示成了<em>dispatch queue</em></li>
<li>a lightweight opaque pseudo-object consisting essentially of <code>a list of functions</code> to be executed.</li>
<li>如果自定义这个queue，它默认状态下是<code>serial queue</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
<span class="kd">var</span> <span class="nv">bitmapContext</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">draw_queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;com.neuburg.mandeldraw&quot;</span><span class="p">)</span>

<span class="c1">// 改造一个返回前述跨线程变量的方法</span>
<span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">CGContext</span> <span class="p">{</span>
    <span class="c1">// ... as before ...</span>
    <span class="kd">let</span> <span class="nv">context</span> <span class="p">=</span> <span class="n">CGContext</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">),</span> <span class="n">height</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
        <span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bytesPerRow</span><span class="p">:</span> <span class="n">bitmapBytesPerRow</span><span class="p">,</span>
        <span class="n">space</span><span class="p">:</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">prem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">!</span>
<span class="p">}</span>
<span class="c1">// 相应方法增加这个context参数，而不是从环境里取</span>
<span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span><span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... as before, but we refer to local context, not self.bitmapContext</span>
<span class="p">}</span>

<span class="c1">// 剩下的，一个block搞定：</span>
<span class="c1">// UI触发的事件</span>
<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// 下面两行代码虽然用到了self，但是它们没有改变任何属性，是线程安全的</span>
        <span class="kd">let</span> <span class="nv">bitmap</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">bitmap</span><span class="p">)</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">bitmap</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>可以看到，相比Operation把代码结构都改了，GCD几乎只是包了一层block，代码变动非常少。（唯一的发动就是把所有执行代码的变量都需要通过参数机制传进去）。</p><p>同时， <em>center, bounds</em>等参数，直接从环境里取，这是block机制带来的便利；同样的机制也被用在了线程共享的变量传回主线程时，因为对第二层block而言，第一层block就是它的<code>higher surrounding scope</code>，是能看到它的<em>bitmap</em>变量的。 -&gt; 我们并没有从头到尾retrive一个<code>self.bitmap</code>变量，也就不存在data sharing。</p><p>不像Operation把耗时操作写在别处，GCD的方式易读性更高。</p><p>除了有<code>.async(execute:)</code>，还有<code>asyncAfter(deadline:execute:)</code>和<code>sync(execute:)</code>，望文生义，就不多介绍了。</p><h3>Dispatch Groups</h3>
<p>group提供了监听(wait)一组后台线程全部执行结束的功能：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">outerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;outer&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">innerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;inner&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">group</span> <span class="p">=</span> <span class="n">DispatchGroup</span><span class="p">()</span>
<span class="n">outerQueue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">series</span> <span class="p">=</span> <span class="s">&quot;123456789&quot;</span>
    <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">series</span> <span class="p">{</span>
        <span class="n">group</span><span class="p">.</span><span class="n">enter</span><span class="p">()</span>  <span class="c1">// flag 1</span>
        <span class="n">innerQueue</span><span class="p">.</span><span class="n">asyncAfter</span><span class="p">(</span>
            <span class="n">deadline</span><span class="p">:.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">milliseconds</span><span class="p">(</span><span class="nb">Int</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="k">in</span><span class="p">:</span> <span class="mf">1.</span><span class="p">..</span><span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">terminator</span><span class="p">:</span><span class="s">&quot;&quot;</span><span class="p">)</span>
                <span class="n">group</span><span class="p">.</span><span class="n">leave</span><span class="p">()</span> <span class="c1">// flag 2</span>
        <span class="p">}</span> 
        <span class="n">group</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>  <span class="c1">// 一旦加了这句话，这9个线程就变成线性的了，注释掉，就是9个线程随机先后执行</span>
    <span class="p">}</span>
    <span class="c1">// 可见这个notify等同于wait_all</span>
    <span class="c1">// 当enter次数与leave次数一致时触发</span>
    <span class="n">group</span><span class="p">.</span><span class="n">notify</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">done&quot;</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<h3>One-Time Execution</h3>
<p>Objective-C中实现单例的<code>dispatch_once</code>其实就是GCD的内容，而在Swift中这个方法就没有了，也没用GCD去实现了:</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">globalOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in a lifetime&quot;</span><span class="p">)</span> <span class="c1">// once, at most</span>
<span class="p">}()</span>
</pre></div>
<p>这个print只会打印一次。而如果是用在对象中，可以声明为<code>lazy</code>：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
        <span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">instanceOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in an instance&quot;</span><span class="p">)</span> <span class="c1">// once per instance, at most</span>
        <span class="p">}()</span>
<span class="c1">// ... }</span>
</pre></div>
<p><code>instanceOnce</code>这个变量也只会初始化一次。</p><p><strong>Bonus</strong></p><div class="highlight"><pre><span></span><span class="c1">// 并发</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;queue&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">:</span> <span class="p">.</span><span class="n">concurrent</span><span class="p">)</span>
<span class="c1">// 条件， check the queue</span>
<span class="n">dispatchPrecondition</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="p">.</span><span class="n">onQueue</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">))</span>
</pre></div>
<h2>App Backgrounding</h2>
<ul>
<li>应用进入后台时，iOS系统会给应用<code>小于5秒</code>的时间来结束当前的任务</li>
<li>可以用<code>UIApplication.shared.beginBackgroundTask(expirationHandler:)</code>来申请更长的时间（<code>不超过30秒</code>），返回一个identifier<ul>
<li><code>expirationHandler</code>是一个超时还没处理完的话，系统会调的方法，</li>
</ul>
</li>
<li>任务执行完后需要调用<code>UIApplication.shared.endBackgroundTask(_:)</code>方法来结束后台时间的申请<ul>
<li><code>expirationHandler</code>里同样需要显式<code>endBackgroundTask</code></li>
<li>所以正常方法体和超时方法体都会有endBackgroundTask的调用</li>
</ul>
</li>
</ul>
<p>把这个特性直接封装到一个operation里去：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">BackgroundTaskOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">whatToDo</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kd">var</span> <span class="nv">cleanup</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="kd">var</span> <span class="nv">bti</span> <span class="p">:</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="p">=</span> <span class="p">.</span><span class="n">invalid</span>
        <span class="n">bti</span> <span class="p">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">beginBackgroundTask</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cleanup</span><span class="p">?()</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// cancellation</span>
        <span class="p">}</span>
        <span class="k">guard</span> <span class="n">bti</span> <span class="o">!=</span> <span class="p">.</span><span class="n">invalid</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">whatToDo</span><span class="p">?()</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// completion</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 调用</span>
<span class="kd">let</span> <span class="nv">task</span> <span class="p">=</span> <span class="n">BackgroundTaskOperation</span><span class="p">()</span>
<span class="n">task</span><span class="p">.</span><span class="n">whatToDo</span> <span class="p">=</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">myQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
<p>这样，</p><ul>
<li>正常情况下会执行<code>whatToDo()</code></li>
<li>如果应用被挂到后台，因为注册过后台任务，有小于30秒的时间跑完任务</li>
<li>如果顺利跑完，你把应用切到前台，会发现UI已经更新了</li>
<li>超时也没跑完，就会进入超时的block里去取消任务了，UI上也得不到结果</li>
</ul>
<blockquote>
<p>最后，要知道所谓的申请时长，并不是在<em>didEnterBackground</em>之类的方法里去做的，而是做任务的时候就直接注册了，是不是很麻烦？</p></blockquote>
<h2>Background Processing</h2>
<p>相比向系统申请少得可怜的后台挂起时间，iOS 从13开始引入了后台任务机制，方便你执行一些用户不需要感知的任务，比如下载，或数据清理：</p><ul>
<li>路径：target &gt; Signing &amp; Capabilities &gt; Background processing</li>
<li>use <code>Background Task framework</code>, need to import <code>BackgroundTasks</code></li>
<li><em>Info.plist</em> &gt; add &quot;Permitted background task schedule identifiers&quot; key (<code>BTTaskSchedulerPermittedIdentifiers</code>), 任意标识字符串，比如反域名</li>
<li>在<code>appDelegate</code>里面去实现需要后台执行的方法</li>
</ul>
<p>涉及到两个类:</p><ul>
<li><code>BGProcessingTaskRequest</code><ul>
<li>在<code>didEnterBackground</code>方法里调用</li>
<li>需要match <em>plist.info</em>里的id</li>
<li>注册是否通电/有网/延迟执行（ExternalPower / Network / earliestBeginDate）</li>
</ul>
</li>
<li><code>BGTaskScheduler</code><ul>
<li><code>application(_:didFinishLaunchingWithOptions:)</code>里执行</li>
<li><code>register(forTaskWithIdentifier:using:launchHandler:)</code>方法<ul>
<li>id: matching plist.info</li>
<li>using: dispatch queue</li>
<li>handler: <code>BGTask</code> object</li>
</ul>
</li>
<li>在<code>BGTask</code>的超时方法里，和正常执行的代码里，均需调用<code>setTaskCompleted(_:bool)</code>方法</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">taskid</span> <span class="p">=</span> <span class="s">&quot;com.neuburg.matt.lengthy&quot;</span>
<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">,</span>
    <span class="n">didFinishLaunchingWithOptions</span> <span class="n">launchOptions</span><span class="p">:</span>
    <span class="p">[</span><span class="bp">UIApplication</span><span class="p">.</span><span class="n">LaunchOptionsKey</span> <span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
<span class="p">}</span>
<span class="c1">// let v = MyView()</span>
<span class="kd">let</span> <span class="nv">ok</span> <span class="p">=</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">forTaskWithIdentifier</span><span class="p">:</span> <span class="n">taskid</span><span class="p">,</span>
    <span class="n">using</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:</span> <span class="p">.</span><span class="n">background</span><span class="p">))</span> <span class="p">{</span> <span class="n">task</span> <span class="k">in</span>
        <span class="n">task</span><span class="p">.</span><span class="n">expirationHandler</span> <span class="p">=</span> <span class="p">{</span>
            <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//... my task logic</span>
        <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// might check `ok` here</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">applicationDidEnterBackground</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// might check to see whether it&#39;s time to submit this request</span>
    <span class="kd">let</span> <span class="nv">req</span> <span class="p">=</span> <span class="bp">BGProcessingTaskRequest</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">taskid</span><span class="p">)</span>
    <span class="k">try</span><span class="p">?</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3>Debug</h3>
<ol>
<li>打满<em>print</em>和断点</li>
<li>设备上，把应用送到后台再拉到前台</li>
<li>Xcode上暂停app</li>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟launching<ul>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟超时</li>
</ul>
</li>
<li>控制台输入<code>continue</code>, 运行task function</li>
<li>当<code>task.setTaskComplete(success: true)</code> 被调用，控制台输出：“Marking simulated task complete,”</li>
</ol>
<h3>BGAppRefreshTaskRequest</h3>
<p>not mentioned</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Thread-in-iOS/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">数据结构篇九：Indexed Priority Queue</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">
                <time class="text-uppercase">
                    November 17 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Indexed Priority Queue</h1>
<ul>
<li>a traditional priority queue variant</li>
<li>top node supports <code>quick update and deletions of key-value paris</code></li>
</ul>
<figure  style="flex: 77.8894472361809" ><img width="1240" height="796" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5e238bf5e89b7b2188cfb748c4e5990e.png" alt=""/></figure><p>观察这个图，数据是Anna, Bella...等等，</p><ul>
<li>首先，为这一堆数据进行任意排序，得到一堆索引(0,1,...)</li>
<li>然后组一个binary heap，这样每个元素又获得一个索引，就是在heap上的序号（<code>Position Map</code>）</li>
</ul>
<p>通过两组索引迅速找到key（就是人名）在堆中的位置，比如：</p><ul>
<li>George，ki = 6, pm = 1</li>
<li>kelly, ki = 10, pm = 10</li>
<li>...</li>
</ul>
<p>现在能迅速找到数据源在堆上的位置了，那么如果反过来呢？比如堆上索引3是数据源的谁？</p><ul>
<li>pm = 3 -&gt; ki = 8 -&gt; Issac <strong>BINGO!!!</strong></li>
</ul>
<p>但神奇的事发生了，有人希望复用ki这个自然数序列（闲的蛋疼？），于是多做了一个数组，把ki定义为heap上的索引，与元素原来的ki进行映射（<code>Inverse Map</code>）:IM
<figure  style="flex: 68.88888888888889" ><img width="1240" height="900" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/71be1add8c1a0cde72e08fc72adbd071.png" alt=""/></figure></p><p>可以看到，这张图上张个ki到im的映射，与pm到ki的映射其实是一样的，也就是说重定义了一下，并没有引入新的东西。(pm表里找到3，对应的第一行ki表里就是8）</p><p>这个时候，我们直接用ki的3就能找到im的8，继而找到数据源的<em>Issac</em>了。</p><h2>Insertion</h2>
<p>上面的数组，我们往里面添加第12条数据试试:</p><ul>
<li>{ki:12, pm: 12, im:12, value:2}</li>
<li>显然违反了binary heap的 invariant，向上冒泡，也就是跟{ki:12, pm:5, im:2, value:4}的节点互换</li>
<li>此时，数据源肯定不会变，但是节点变了，pm的值就要交换（5， 12 互换）</li>
<li>pm变了，把pm当成ki的映射表im也要变（12， 11互换）</li>
</ul>
<figure  style="flex: 224.63768115942028" ><img width="1240" height="276" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/47da2e700214e5e2de16aa42f5b92fb3.png" alt=""/></figure><p>仔细观察图片，搞清楚第一行ki在两次互换时的身份就明白了</p><ul>
<li>pm的互换是直观的，就是节点的位置</li>
<li>知道pm互换的依据后（2，5），在第一行找2，5对应的im值互换，因为在这个映射里，相当于pm与原ki的映射，pm此时是（2，5）了。</li>
</ul>
<p>同样逻辑继续冒泡就是了。</p><p>pseudo code:</p><div class="highlight"><pre><span></span><span class="c1"># Inserts a value into the min indexed binary </span>
<span class="c1"># heap. The key index must not already be in </span>
<span class="c1"># the heap and the value must not be null. </span>
<span class="n">function</span> <span class="n">insert</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># ‘sz’ is the current size of the heap</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz</span>  <span class="c1"># 对应上图，意思就第一行索引器是ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="n">ki</span>  <span class="c1"># 对应上图，意思就是一行索引器是pm</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span>     <span class="c1"># 这里传进去的pm，即heap上节点的索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 添加成功，size加1</span>
</pre></div>
<p>理论上，添加元素到最后一个, sz和ki应该是相等的（因为都是尾巴上）</p><div class="highlight"><pre><span></span><span class="c1"># Swims up node i (zero based) until heap </span>
<span class="c1"># invariant is satisfied.</span>
<span class="n">function</span> <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 比父节点小就冒泡，注意入参i是节点上的索引，即pm</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)):</span> 
        <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># 所以这里传的也是pm</span>
        <span class="n">i</span><span class="o">=</span><span class="n">p</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">function</span> <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> 
    <span class="c1"># 我们交换了节点，需要交换pm表里的值，和im表里的值</span>
    <span class="c1"># 交换pm的值需要数据源的索引，即ki，而ki能从im表里用pm算出来</span>
    <span class="c1"># 所以ki = im[pm] 这里i,j是pm，所以im[i]自然就是i对应ki</span>
    <span class="c1"># pm[ki]当然就是pm[im[i]]了：</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
    <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">function</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
<p>还是那句话，理解清楚那三行映射表里第一行的动态含义，就不会有问题。</p><ul>
<li>pm表要key index来索引</li>
<li>im表要node index来索引</li>
</ul>
<p>在操作时，只需要知道传入的是哪种索引，及时转化就行了。</p><p>有了索引，lookup的时间复杂度就是常量时间了：O(1)</p><h2>Polling and Removals</h2>
<p>没有什么特殊的,仍然是找到节点,与最后一个交换,移除最后一个节点,然后再看最后一个在堆里是上升还是下降.
仍然是记得每一步交换,相应的几个索引值也需要随之交换.(polling 其实就是移除第1个节点,本质上还是 removal)
<figure class="vertical-figure" style="flex: 36.70811130846655" ><img width="1240" height="1689" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/581b8563020c36307eae7a9bf618a7e0.png" alt=""/></figure></p><p>pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Deletes the node with the key index ki</span>
<span class="c1"># in the heap. The key index ki must exist </span>
<span class="c1"># and be present in the heap.</span>
<span class="n">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">ki</span><span class="p">):</span>
    <span class="c1"># 注意，这里送进来的是ki，而不是node index(pm)</span>
    <span class="c1"># 说明业务需求一般是操作数据源，而不是操作堆</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>    <span class="c1"># 转成节点索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># 与最后一个元素交换，用size来做节点索引</span>

    <span class="c1"># 下面三个子函数送入的就是节点索引了</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> 
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span>  <span class="c1"># 数据源对应的值置空，所以用ki</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 数据源对应的节点置空，所以用ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 反查表用节点索引，此处size就是最后一个节点的索引</span>
</pre></div>
<p>sink pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Sinks the node at index i by swapping </span>
<span class="c1"># itself with the smallest of the left </span>
<span class="c1"># or the right child node.</span>
<span class="n">function</span> <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 这是堆操作,传入的索引也是节点索引,没问题</span>
    <span class="c1"># sink是下沉，但不是跟BTS一样找左侧最大右则最小那种直接换</span>
    <span class="c1"># 而是一层层往下换</span>
    <span class="c1"># 即一次while只跟左右子级比大小，确实比子级还小的话，就替换，然后再跟下一层比较</span>
    <span class="k">while</span> <span class="n">true</span><span class="p">:</span>
        <span class="c1"># 利用二叉树特性算出子节点</span>
        <span class="c1"># 默认左边最小，然后再看右边是不是更小</span>
        <span class="n">left</span> <span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">left</span>
    <span class="c1"># 右边不越界，且小于左边，就设右边</span>
    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sz</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">right</span>
    <span class="c1"># 左侧都越界了，或已经比最小值大了，说明不需要下沉了</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">sz</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">smallest</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="c1"># 只要没有break，说明能交换，然后把交换后的作为下一个循环的起点</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">smallest</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">smallest</span>
</pre></div>
<h2>Updates</h2>
<p>更新节点要简单的多:</p><ul>
<li>用ki找到value，把值更新</li>
<li>然后根据新value实际情况上浮或下沉</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># Updates the value of a key in the binary </span>
<span class="c1"># heap. The key index must exist and the</span>
<span class="c1"># value must not be null.</span>
<span class="n">function</span> <span class="n">update</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<h2>Decrease and Increase key</h2>
<p>不好说，先看代码吧：</p><div class="highlight"><pre><span></span><span class="c1"># For both these functions assume ki and value </span>
<span class="c1"># are valid inputs and we are dealing with a</span>
<span class="c1"># min indexed binary heap.</span>
<span class="n">function</span> <span class="n">decreaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]):</span> 
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">swim</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>

<span class="n">function</span> <span class="n">increaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">],</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">sink</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
</pre></div>
<p>代码里是跟一个固定值比较，只要ki对应的值比它大(desreaseKey)或小(increaseKey），就用这个固定值来替换它，并且在value改变后根据实际情况上浮或下沉。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/" target="_self">数据结构篇八：Balanced Binary Search Trees(BBST)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/" target="_self">
                <time class="text-uppercase">
                    November 17 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Balanced Binary Search Trees (BBST)</h1>
<ul>
<li>满足low (logarithmic) height for fast insertions and deletions</li>
<li>clever usage of a <code>tree invairant</code> and <code>tree rotation</code></li>
</ul>
<h2>AVL Tree</h2>
<p>一种BBST，满足O(log n)的插入删除和查找复杂度，也是第一种BBST，后续出现的更多的：2-3 tree, AA tree, scapegoat tree, red-black tree(avl的最主要竞争对手)</p><p>能保持平衡的因子：Balance Factor (<code>BF</code>)</p><ul>
<li>BF(node) = H(node.right) - H(node.left)</li>
<li>H(x) = height of node = # of edges between (x, furthest leaf)</li>
<li>平衡就是左右平均分配，所以要么均分，要么某一边多一个，BF其实就是(-1, 0, 1)里的一个了 &lt;- avl tree invariant</li>
</ul>
<p>一个node需要存：</p><ul>
<li>本身的(comparable) value</li>
<li>balance factor</li>
<li>the <code>height</code> of this node</li>
<li>left/right pointer</li>
</ul>
<p>使树保持左右平衡主要是靠rotation，极简情况下（三个node），我们有两种基本情况（left-left, right-right），有其它情况就旋转一次变成这两种情况之一：
<figure  style="flex: 87.44710860366713" ><img width="1240" height="709" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/3b702bd1d181c924971298b096c7c548.png" alt=""/></figure></p><h2>Insertion</h2>
<p>一次插入需要考虑的是，插在哪边，以及插入后对bf, height和balance的破坏
<figure  style="flex: 60.546875" ><img width="1240" height="1024" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/7aec7390101d933c2d50971e2733effe.png" alt=""/></figure></p><p>其中修复平衡就是上图中几个基本结构的转换</p><h2>Removal</h2>
<p>avl树就是一棵BST，删除节点分两步：</p><ol>
<li>按照bst的方法查找节点，即小的在左边找，大的在右边找</li>
<li>也按bst的原则删除元素，即找到元素后，把左边的最大值或右边的最小值拿过来补上删除的位置</li>
<li>这一步是多出来的，显然是要更新一下节点的bf和height，及重新balance一次了。</li>
</ol>
<p>前两部分参考BST一章，流程伪代码：</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="o">...</span>
    <span class="c1"># Code for BST item removal here</span>
    <span class="o">...</span>
    <span class="c1"># Update balance factor</span>
    <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="c1"># Rebalance tree</span>
    <span class="k">return</span> <span class="n">balance</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">数据结构篇七：Suffix Array, Longest Common Prefix (LCP) array</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">
                <time class="text-uppercase">
                    November 16 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Suffix Array</h1>
<ul>
<li>字符串的所有子字符串后缀组成数组</li>
<li>对子串根据首字母进行排序</li>
<li>排序后原有的index就被打乱了</li>
<li>这个乱序的indices就是<code>Suffix Array</code></li>
</ul>
<p>做尾缀子串的时候通常是从单个字母开始越找越多，这就有了一个原生顺序，然后用首字母排序后，这个顺序就被打乱了</p><p>提供了一种<code>compressd representation</code> of sorted suffixes而无需真的把这些子串存起来。</p><ul>
<li>A space efficient alternative to a <code>suffix tree</code><ul>
<li>a compressd version of a <code>trie</code>?</li>
</ul>
</li>
</ul>
<p>能做所有<code>suffix tree</code>能做的事，并加添加了<code>Longest Common Prefix</code>(LCP) array</p><h1>Longest Common Prefix (LCP) array</h1>
<p>继续上面的Suffix Array，字母排序后，我们一个个地用每一个元素同上一个元素比，标记相同前缀的字母个数，这个数字序列就是<code>LCP</code></p><p>比如adc, adfgadc, 前缀<code>ab</code>是相同的，那就是2。</p><p>第一个元素没有“上一个”去比，所以LCP数组第1位永远是0？（是的，其实是undefined，但一般设0）</p><p>衡量的是相邻的suffix array元素的前缀间有多少个字母相同。</p><p>当前也可以和下一个元素比（这样最后一个元素的LCP肯定是0了，原理同上）</p><h2>Find unique substrings</h2>
<p>找到（或计数）一个数组的所有（不重复的）子元素。可以逐个substring遍历，$O(n^2)$，下面看看更快也更省空间的LCP方案。</p><p>找“AZAZA”的不重复子串:
A,AZ,AZA,AZAZ,AZAZA,Z,ZA,ZAZ,ZAZA,<code>A,AZ,AZA,Z,AZ,A</code>，把重复的标注了出来。
LCP是这样的：
LCP|Sorted Suffixes|
-|-
0|A
1|AZA
3|AZAZA
0|ZA
2|ZAZA</p><p>我们知道第一列指的是“重复个数”，也就是说，如果按我们手写的那样去遍历，至少有这么多重复的子串，重复的既是“个数”，也是“组合方式”。</p><p>所以如果我们只需要计数的话，把右边的数出来就知道有会有多少个重复的了，此例为6.</p><p>$$\tt unique\ count = \underbrace{\frac{n(n+1)}{2}}_{substr\ count} - \underbrace{\sum_{i=1}^n LCP[i]}_{duplicates}$$</p>
<p>这是LCP的应用之一，利用了LCP本身就是在数重复次数的特征。</p><h2>K common substring problem</h2>
<p>n个字符串，找出一个子串，它至少是k个字符串的子串，求最大子串。$2\leq k \leq n$</p><p>即如果有k=2，那么这个子串只需要是其中两个的子串就行了，如果k=n，那么就需要是每一个字符串的子串。</p><p>直接上图
<figure  style="flex: 50.4885993485342" ><img width="1240" height="1228" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/b7cb01449aa00a46b95ca35f28751a33.png" alt=""/></figure></p><ul>
<li>图1演示k=3时，找到了<code>ca</code>，即3个串里都有的是<code>ca</code></li>
<li>图2演示k=2时，找到了<code>bca</code>，即<code>bca</code>存在2个串里</li>
<li>图3演示的是用了size=4的滑窗才包含了3个字符串，以及最大匹配是<code>AG</code></li>
</ul>
<p>步骤：</p><ol>
<li>首先，用几个分隔符把字符串拼接起来<ul>
<li>分隔符字符串里不会出现</li>
<li>分隔符的排序要小于所有字符</li>
</ul>
</li>
<li>图中染色的依据是prefix是哪个串里的就染成什么颜色</li>
<li>开始滑窗比较<ul>
<li>滑窗必须要能包含k种颜色</li>
<li>所以滑窗大小不是固定的，有时候相邻几个都是来自同一个字符串</li>
<li>滑窗里除0外的最小值，就是符合条件的最大共同长度，如图3，最大匹配长度是2</li>
<li>课程里动画演示滑窗其实不是用滑的，而是用的爬行<ul>
<li>即下界往下，包含了所有颜色之后，上界也往下，这样蠕行前进，每一步判断滑窗里的内容</li>
</ul>
</li>
</ul>
</li>
<li>额外需要一个hash table来保存切片与颜色的映射关系。<ul>
<li>如果是例子这么简单，我可以直接检查第一个出现的分隔符，是#就是绿色，出现$就是蓝色，%就是红色</li>
</ul>
</li>
</ol>
<p>核心就是：</p><ul>
<li>取子串是从后向前取的</li>
<li>但比较是从前向后比的</li>
<li>前面的元素可能来自任何一个子串（只要足够长）</li>
<li>从前面排序，客观上就把来自不同字符串的相同字母打头的子串给排到一起了</li>
</ul>
<p>这就是为什么在<code>Suffix</code> Array的内容里面出现Longest Common <code>Prefix</code>的内容的原因了.</p><p>聪明。</p><h2>Longest Repeated Substring (LRS)</h2>
<figure  style="flex: 72.68464243845251" ><img width="1240" height="853" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ef47276f994f76ccabc2c60900227916.png" alt=""/></figure><p>这个比暴力遍历要简单太多，直接找LCP最大值即可</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">数据结构篇六：Fenwick Tree (Binary Indexed Tree)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">
                <time class="text-uppercase">
                    November 15 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Fenwick Tree (Binary Indexed Tree)</h1>
<p>树状数组</p><p><strong>Motivation</strong></p><figure  style="flex: 118.0952380952381" ><img width="1240" height="525" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2591209692305dbd9d640a53765581e1.png" alt=""/></figure><ul>
<li>计算数组里任意连续片段的和，最直观的方案当然是累加：线性时间O(n)</li>
<li>但是如果你有一个记录了每个节点到当前位置时的累加和的数组（<code>prefix sum</code>），立刻变成了常量时间</li>
<li>问题是更新数据变成了线性时间（后续所有的求和都要改一遍）<ul>
<li>great for <code>static arrays</code></li>
</ul>
</li>
</ul>
<p>所以引入了:
<code>Fenwick Tree</code> is an efficient data structure for performing range/point queries/updates.(即在上面的动机上，还考虑了update的效率)</p><p>前面的例子在update时效率不高，所以Fenwick Tree用了一种聪明的方式，不是累加所有的值，而是分段累加，具体实现看下图：
<figure  style="flex: 67.24511930585683" ><img width="1240" height="922" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/eb45cb86abbe7a62cd8cc8d3fc2a8f06.png" alt=""/></figure></p><ul>
<li>把索引值用二进制表示</li>
<li><code>LSB</code>的解释看图，实际应用上，就是看从低位到高位第一个1的右边有几个0，假设为<code>n</code>个</li>
<li>那么该cell上存的值就是前$2^n$个cell的值的和</li>
</ul>
<p>图中例子是索引10，不直观，我们换成12， 二进制是1100， 最右边有2个零，那么它保存它$2^2=4$个位置的和。
也就是说，如果你要求和，如果用了cell 12位置的值的话，至少可以省掉3次累加。</p><p>当然，它还有更牛逼的特性，结合range query一起来看吧：
<figure  style="flex: 67.3913043478261" ><img width="1240" height="920" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/0a9944a0140262760c9fb4a45cb3d75e.png" alt=""/></figure></p><p>蓝线表示的是当然位置上累加了前几个位置的值，已经很有规律了</p><p>假如计算前11个值的和，过程是：</p><ol>
<li>11的索引是1011，右边没有0，所以当前的和为A[11]</li>
<li>根据$2^0$来移位，来到10。<ul>
<li>右边一个0，所以它管$2^1$个presum，目前A[11] + A[10]</li>
<li>下一个索引自然要减2了，来到8</li>
</ul>
</li>
<li>8是1000，3个零，所以它存了$2^3=8$个值的和，那就是全部了</li>
</ol>
<p>所以：sum = A[11] + A[10] + A[8]</p><ul>
<li>心算sum(0,7)巩固一下</li>
<li>用sum(11,15)演示子区间，其实就是多减1次，至于是减到10还是减到11，看描述，比如这里11是要参与计算的，那就是把前10个减掉就行了。</li>
</ul>
<p>上面演示的都是<code>worst</code>的情况，即首位为1，除了这种情况，别的位都至少存了前$2^n$个元素的值（比如16，直接得到16个元素的和）</p><blockquote>
<p>这里都没讲你是怎么做这个tree的，而是怎么使用它。先弄清楚使用场景再谈构建。</p></blockquote>
<h2>Point Update</h2>
<p>复习一下<code>LSB</code>，虽然可以直接数最右边的零的个数，但数学其实是：</p><ul>
<li>13 = 1101 ($2^3 + 2^2 + 2^0 \Rightarrow 10^3 + 10^2 + 10^0 $)</li>
<li>减去最右边的1和0 =&gt; 1100 （$2^3+2^2=12$) 所以下一个数是12</li>
<li>减去最右边的1和0 =&gt; 1000 就是8了</li>
<li>再减就是0了</li>
</ul>
<p>而按$2^n$来计算个数的话就是这样的：</p><ul>
<li>13 = 1101, 没有0，就是移1位，变成12</li>
<li>12 = 1100， 2个0， 就是移4位，变成8</li>
<li>8 = 1000， 3个0， 移8位，变成0</li>
</ul>
<p>现在来讲update，前面知道，update会级联影响到所以把该cell考虑进去的节点，因此，它需要反着往上找（极端情况当然是找到最后一个元素，通常这个元素就是整个数组的值，所以任何元素的更改，肯定都会影响到它）</p><p>前面找下一个节点用的是减法，现在就要用加法了，比如我更新了cell 9, 用以上两种任意一种方法来计算：</p><ul>
<li>$9 = 2^3 + 1 \Rightarrow 10^3 + 1 = 1001, +1 = 1010 = 10$</li>
<li>1010 + 10 = 1100 = 12</li>
<li>1100 + 100 = 10000 = 16 到顶了，</li>
</ul>
<p>所以需要把9, 10, 12, 16分别应用这个point的更新，也就是说只有这几个cell把9计算进去了。</p><figure  style="flex: 66.59505907626209" ><img width="1240" height="931" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/57cf2e654121e8c54e9f6cd1eeb60d9b.png" alt=""/></figure><p>当然，可以看一下左边的示意图，更直观</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> 
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> 
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<p>代码非常简单，就是不断通过LSB找下一个位置去更新就行了。</p><h2>Construction</h2>
<p>现在来讲构建</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">construct</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">length</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># Clone the values array since we’re # doing in place operations</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">deepCopy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
<p>几乎就一句话，就是把元素按原数据摆好（即不加别的节点）后，每次找到当前元素影响的上一级（不再向上冒泡）</p><ul>
<li>比如1，把1算进去的有2，虽然上面还有4， 8， 16，但只把1更新到2</li>
<li>到2的上一级是4 (2 + lsb(2) = 4), 把节点2的现值（已经加了节点1）加到4去</li>
<li>所以核心算法始终只有两个变量，i，j代表最近的包含关系</li>
</ul>
<p><strong>一些算法换成位运算</strong></p><ul>
<li>lsb(i): <code>i &amp; -i</code></li>
<li>i -= lsb(i) =&gt; <code>i &amp;= ~lsb(i)</code></li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/" target="_self">数据结构篇五：Hash Tables</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/" target="_self">
                <time class="text-uppercase">
                    November 15 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Hash Tables</h1>
<ul>
<li>key-value pair</li>
<li>using <code>Hashing</code> technique</li>
<li>often used tracking item frequencies</li>
</ul>
<p>what's <em>hash function</em>?</p><ul>
<li>maps a key <code>x</code> to a whole number in a fixed <code>range</code>.<ul>
<li>e.g. $H(x) = (x^2 - 6x + 9) % 10$ maps (0, 9)</li>
<li>这个方程会为不同的x产生一样的y -&gt; <code>hash collision</code></li>
</ul>
</li>
<li>can hash arbitrary objects like string, list, tuple...</li>
<li>must be <code>deterministic</code>(确定的x产生确定的y)<ul>
<li>因此key的应该是<code>immutable</code>的类型</li>
</ul>
</li>
</ul>
<p>关键词是<code>range</code>，你设计的function总要mod一下，将结果限制在一个范围内。这里你应该暂时能推测出hashtable的key可能就是数字吧？</p><p><strong>hash collision</strong></p><ul>
<li><code>separate chaining</code></li>
</ul>
<p>用一种数据结构（通常是链表）保留所有冲突的值</p><ul>
<li><code>open addressing</code></li>
</ul>
<p>为冲突的值选择一个offset（地址/值）保存 -&gt; <code>probing sequence P(x)</code></p><p>不管是怎么解决冲突，<strong>worst</strong>的情况下，hash table的操作时间也会由O(1)变成O(n)</p><p>怎么用HT来查找呢？不是把hash后的结果拼到原数据上，而是每次查询前，对key进行一次hash function，就能去查询了。</p><h2>Open Addressing</h2>
<p><strong>probing sequences</strong></p><ul>
<li>linear probing: P(x) = ax + b</li>
<li>quadratic probing: p(x) = $ax^2 + bx + c$</li>
<li>double hashing: p(k, x) = $x * H_2(k)$ 双重hash</li>
<li>pseudo random number generator: p(k, x) = x * rng(H(k), x) 用H(k)(即hash value)做种的随机数</li>
</ul>
<p>总之就是在这样一个序列里找下一个位置</p><p>假设一个table size 为N的HT，使用开放寻址的伪代码：</p><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">keyHash</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>   <span class="c1"># 直接计算出来的hash value</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">keyHash</span>  <span class="c1"># 偏移过后存在HT里的index</span>

<span class="k">while</span> <span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyHash</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">%</span> <span class="n">N</span>  <span class="c1"># 加上偏移，考虑size（N）</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 游标加1</span>

<span class="c1"># now can insert (k,v) at table[index]</span>
</pre></div>
<h3>Chaos with cycles</h3>
<p><strong>Linear Probling (LP)</strong></p><p>LP中，如果你<em>运气不好</em>，产生的序列的下一个值永远是occupied的状态（一般是值域小于size），就进入死循环了。</p><p>假设p(x) = 3x, H(k) = 4, N = 9
那么H(k)+P(x) % N 只会产生{4,7,1}，如果这三个位置被占用，那就陷入了永远寻找下一个的无限循环中。</p><p>一般是限制probing function能返回刚好N个值。</p><blockquote>
<p>当p(x)=ax的a与size的N互质，即没有公约数，<code>GCD(a, N) = 1</code>一般能产生刚好N个值。(Greatest Common Denominator)</p></blockquote>
<blockquote>
<p>注意，为了性能和效率的平衡，有<code>load factor</code>的存在，所以到了阈值，size就要加倍，N的变化，将会使得<code>GCD(a, N) = 1</code>的a的选择有变化，而且之前对N取模，现在取值也变发生变化，这时候需要重新map</p></blockquote>
<p>重新map不再按元素当初添加的顺序，而是把现有HT里的值按索引顺序重新map一遍。比如第一个是k6, 即第6个添加进来的，但是现在第一个就重新计算它的值，填到新的HT里面去。</p><p><strong>Quadratic Probing （QP）</strong></p><p>QP 同样有chaos with cycles的问题，通用解决办法，三种：</p><ol>
<li>p(x) = $x^2$, size选一个 prime number &gt; 3, and $\alpha \leq \frac{1}{2}$</li>
<li>p(x) = $(x^2 + x) / 2$, keep the size a power of 2 （不需要是素数了）</li>
<li>p(x)= $(-1^x) \times x^2$, make size prime N $\equiv 3$ mod 4 ???</li>
</ol>
<p><strong>Double Hashing</strong></p><p>Double Hashing: P(x) = $x \times H_2(k)$可见仍然类似一个一次的线性方程，$H_2(k)$就类似于ax中的a，设为$\delta$，相比固定的a, 这里只是变成了动态的，这样不同的key的待选序列就是不一样的（可以理解为系数不同了）</p><p>解决chaos:</p><ol>
<li>size N to be a prime number</li>
<li>calculate: $\delta = H_2(k)$ mod N<ul>
<li>$\delta=0$ 时offset就没了，所以需要人为改为1</li>
<li>$1 \leq \delta \lt N$ and GCD($\delta$, N) = 1</li>
</ul>
</li>
</ol>
<p>可见，虽然系数是“动态”的了，但是取值还是（1，N）中的一个而已，hash只是让其动起来的一个原因，而不是参与计算的值。</p><p>我们本来就是在求hash value，结果又要引入另一个hash function，显然这个$H_2$不能像外层这样复杂，一般是针对常见的key类型(string, int...-&gt; fundamental data type)的<code>universal hash functions</code></p><blockquote>
<p>因为N要是一个素数，所以在double size的时候，还要继续往上找直到找到一个素数为止，比如N=7, double后，N=14，那么最终，N=17</p></blockquote>
<figure  style="flex: 67.68558951965065" ><img width="1240" height="916" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/cbae1de97a3f72ae84ea59804293ec56.png" alt=""/></figure><h3>Issues with removing</h3>
<p>因为冲突的hash value需要probing，probing的依据是从序列里依次取出下一个位置，检查这个位置<strong>有没有被占用</strong>，那么问题就来了，如果一个本被占用的位置，因为元素需要删除，反而变成没有占用了，这有点类似删除树节点，不但要考虑删除，还要考虑这个位置怎么接续。</p><p><strong>lazy deletion</strong>
但HT机制比树要复杂，为了避免反复应用probing函数重新摆放后续所有节点，干脆就在删除的位置放置一个预设的标识，我们称为墓碑(<code>tombstone</code>)，而不是直接置空，然后所有的查找和添加加上这一条规则，就能快速删除又无需重新排序。</p><p>大量删除会造成空间浪费，但无需立即处理：</p><ol>
<li>添加元素允许添加到墓碑位置</li>
<li>到达阈值容量需要倍增的时候有一次重排，这个时候就可以移除所有的墓碑</li>
</ol>
<p>如果查找一个hash value，连续3个都是墓碑，第4个才是它，这是不是有点浪费时间？
确实，所以还可以优化，当你查找过一次之后，就可以把它移到第一个墓碑的位置，这样，<strong>下次</strong>查询的时候速度就会快很多了。</p><p>整个机制，叫<code>lazy deletion</code></p><figure class="vertical-figure" style="flex: 29.61816305469556" ><img width="1148" height="1938" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a935a20b4bc9641962766872aace8306.png" alt=""/></figure></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/" target="_self">数据结构篇四：Binary Trees and Binary Search Trees (BST)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/" target="_self">
                <time class="text-uppercase">
                    November 14 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<p>Tree: 满足以下定义的<code>undirected graph</code>(无向图)</p><ul>
<li>An acyclic(非循环的) connected graph</li>
<li>N nodes and N-1 edges</li>
<li>有且只有一条路径连接<em>任意</em>两个顶点</li>
</ul>
<blockquote>
<p>任意一个节点都可以被理解为root</p></blockquote>
<p><strong>Binary Tree</strong>
拥有最多两个节点的Tree</p><p><strong>Binary Search Tree</strong>
服从以下特性的<code>binary tree</code></p><ul>
<li>左子树的元素小于右子树</li>
</ul>
<p>拥有重复元素是允许的，但多数情况下我们只研究不重复的元素</p><p>这是一个有效的BST吗？
<figure  style="flex: 57.83582089552239" ><img width="1240" height="1072" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d9ca27993e1a1228a3ffcadf9ed86aba.png" alt=""/></figure></p><p>是的（对于单链下来的，几乎会直接就满足右边比左边大）</p><p><strong>Usage</strong></p><ul>
<li>BSTs<ul>
<li>implementation of some map and set ADTs</li>
<li>red black trees</li>
<li>AVL trees</li>
<li>splay trees</li>
<li>...</li>
</ul>
</li>
<li>binary heaps</li>
<li>syntax trees (by compiler and calculators)</li>
<li>Treap - a probabilistic DS (uses a randomized BST)</li>
</ul>
<p><strong>Complexity</strong>
增删查平均为O(log n)，但最差情况下都为O(n)，即线性时间</p><h2>Adding elements to a BST</h2>
<ul>
<li>第一个为root</li>
<li>每一个新数，比顶点大，放右边，比顶点小，放左边，顺序下行<ul>
<li>不是从左到右摆满再做subtree</li>
<li>比如3,6,9, 会得一棵全部数字摆在右边的数，而不是顶3左6右9的三角形</li>
<li>这也是为什么极端情况下，时间复杂度是<code>O(n)</code>，因为就是一条线到底</li>
<li>这也是<code>balanced binary search trees</code>被引入的原因</li>
</ul>
</li>
</ul>
<h2>Removing elements from a BST</h2>
<ul>
<li>find<ul>
<li>从root开始，小的走左右，大的走右边</li>
</ul>
</li>
<li>replace (to maintain the BST invariant)</li>
</ul>
<p>找继任者的时候，如果删除元素没有子节点，只有左或右子节点，都很好办，但如果它有两个子节点，那么应该用哪个来接续呢？</p><p>原则仍然是要服从左边的比右边的小，所以你其实有两种选择：</p><ul>
<li>把左边最大的数选出来 或</li>
<li>把右边最小的数选出来</li>
</ul>
<p>因为它们的“来源”，肯定是能保证bst invariant的
    * 这个数是要替换这个节点的，所以要比这个节点左边的数都大，及比右边所有的数都小，显然就是左边的最大数，或右边的最小数了。
    * 只是把找到的元素复制过去后，多了的那个怎么办呢？</p><ul>
<li>递归</li>
</ul>
<p>新找到的元素当然要从原来的位置删除，这时又根据它是否叶节点，单子节点还是全节点，来反复进行前面的操作，最终总是可以退出的
<figure  style="flex: 57.83582089552239" ><img width="1240" height="1072" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/511db0d1a3889dca35b02ce18318c787.png" alt=""/></figure></p><figure  style="flex: 68.69266055045871" ><img width="1198" height="872" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/85b0081fb572f97bd8fb1a93c9ca3d90.png" alt=""/></figure><h2>Tree Traversals</h2>
<p>(Preorder, Inorder, Postorder &amp; Level order)
<figure  style="flex: 92.67563527653213" ><img width="1240" height="669" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/731be06981a3a58193e3d1ea54d7fd22.png" alt=""/></figure></p><ul>
<li>preorder，在遍历左侧元素的时候，每次已经先取到元素了（最顶层）</li>
<li>inorder里，遍历元素的时候，直到所有的left走完了，才取到第一个元素（最底层的）</li>
<li>postorder里，也是遍历到最底层，但是下一步就是取兄弟节点了</li>
</ul>
<figure  style="flex: 99.51845906902086" ><img width="1240" height="623" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/47fe26cb82c30df966d2cbb9f8bd3ee8.png" alt=""/></figure><p>inorder一个重要特征：它是从小到大排好序的！
<figure  style="flex: 97.79179810725552" ><img width="1240" height="634" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/730f8d00e817c006cb9c33171da53386.png" alt=""/></figure>
preorder 和 postorder没什么特征，举一个post的例子观察下</p><p>而levelorder则是一<code>层</code>一层地取的：</p><figure  style="flex: 91.58050221565732" ><img width="1240" height="677" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/483fae0876dbf6b3d954f86b6341ecf5.png" alt=""/></figure>
这就是广度优先了（<code>Breadth First Searth</code>)BFS<p>实现BFS</p><ol>
<li>每处理一个parent的时候，把parent加到结果数组里</li>
<li>parent的子节点加到队列里</li>
<li>每次从队列里取出一个值加到结果数组里（步骤1）</li>
<li>该值的child加到队列里（步骤2）</li>
</ol>
<p>其实就是步骤1，2的重复，比如：
<figure  style="flex: 70.7516339869281" ><img width="866" height="612" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/80ff2df354c0700753943e83fd5cd17a.png" alt=""/></figure></p>
<pre><code>[11], [6, 15] 处理第1个数11， 队列里多了两个元素6， 15
[11, 6], [15, 3, 8] 从队列里取出6， 加入结果，它的子元素(3, 8)加入队列
[11, 6, 15], [3, 8, 13, 17]
[11, 6, 15, 3], [8, 13, 17, 1, 5]
[11, 6, 15, 3, 8], [13, 17, 1, 5] 这一步，8没有子节点了，队列变短了
[11, 6, 15, 3, 8, 13], [17, 1, 5, 12, 14]
[11, 6, 15, 3, 8, 13, 17], [1, 5, 12, 14, 19] 17只有一个child
[11, 6, 15, 3, 8, 13, 17, 1, 5, 12, 14, 19] 剩下的都没child了，全部拼进去
</code></pre>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/" target="_self">数据结构篇三：Union Find</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/" target="_self">
                <time class="text-uppercase">
                    November 14 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Union Find</h1>
<ul>
<li>keep track of elements in different sets</li>
<li>primary operations: <code>find</code> and <code>union</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>Kruskal's <code>minimum spanning tree</code> algorithm</li>
<li>Grid percolation</li>
<li>Network connectivity</li>
<li>Least common ancestor in trees</li>
<li>Image processing</li>
</ul>
<p><strong>Complexity</strong></p><ul>
<li>construction: O(n)</li>
<li>union/join/size/check connected/: $\alpha$(n) :接近常量时间</li>
<li>count: O(1)</li>
</ul>
<p>给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树(<code>Spanning Tree</code>)。如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, <code>Minimum Spanning Tree</code>)。
-&gt; 用最少的边连接所有的顶点</p><ul>
<li>sort edges by ascending edge weight</li>
<li>walk through edges<ul>
<li>检查顶点，如果两个顶点都已经unified，就忽略<ul>
<li>其实就是这两个点分别被别的边连过了</li>
</ul>
</li>
<li>否则就添加edge，并且unify顶点</li>
</ul>
</li>
</ul>
<p>看到这里，首先想知道什么是unified，看实现，也就是在一个集合里(component)
<figure class="vertical-figure" style="flex: 42.622950819672134" ><img width="1040" height="1220" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/475d857d18dc3fe4749139b896e6f68a.png" alt=""/></figure></p><ul>
<li>观察C_J，因为C和J已经在一个组里了，这条边就不需要了</li>
<li>观察D_E，一旦连上后，紫色和绿色其实就是一个组了</li>
</ul>
<figure class="vertical-figure" style="flex: 36.810730253353206" ><img width="988" height="1342" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a3a52e1b62a1b105bc18f817ba801011.png" alt=""/></figure><ul>
<li>观察D_H，一旦连上后，紫色和红色也成为了一个组</li>
<li>连接B_C，所有顶点就全部连上了，并且只有一条紫线</li>
</ul>
<p>Find: 找元素在哪个component里，然后找到它的root
Union: 找两个元素分别在哪个component里，然后找到它们的root，如果不是同一个root，就让其中一个成为另一个的parent</p><ul>
<li>component的个数与root的个数一致</li>
<li>root的个数只减不增（因为通常只合并而不拆分）</li>
</ul>
<p>union find里</p><ul>
<li>为每个元素分配一个索引，每个元素指向自己（即初始是n个root，n个component)</li>
<li>描述两两之间的关系，以任一元素为parent （谁来描述？）</li>
<li>有一个元素已经属于别的component里的，就将它也加到那个component里去<ul>
<li>如果这个元素也是别的component里的顶点，就把整个组指向另一个组的root</li>
</ul>
</li>
</ul>
<h2>Path Compression Union Find</h2>
<figure class="vertical-figure" style="flex: 36.48111332007952" ><img width="734" height="1006" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5bac1a63885746047c532e2362b8ead9.png" alt=""/></figure><p>由一层层找到root改为所有顶点直接指向顶点（星形结构），实现路径压缩</p><p>这段代码演示的是，查找p的root节点，在查找的过程中，顺便进行了路径压缩
<figure  style="flex: 102.99003322259136" ><img width="1240" height="602" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6de31545897b5731ee7c6916033393a1.png" alt=""/></figure></p><p>合并的逻辑就是比较谁的元素多就把谁当作root，另一个component的root的parent设为元素多的组的root<br />
合并完成后组数就少了1
<figure  style="flex: 71.1825487944891" ><img width="1240" height="871" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1b52c2255e8963040253701946bae7d8.png" alt=""/></figure></p><p>看代码，这一步里面并没有路径压缩，也就是小组里面的元素并没有<strong>进一步</strong>再星状地指向新的parent，仍然指向的是老的组的root。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/" target="_self">数据结构篇二：Priority Queues (PQs) with an interlude on Heaps</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/" target="_self">
                <time class="text-uppercase">
                    November 13 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><p>优先队列和堆的插曲，在优先队列里引入了heap只是个插曲而不算正式介绍，但其实讲得差不多了。</p><hr />
<h1>Priority Queues (PQs) with an interlude on heaps</h1>
<ul>
<li>A priority queue is an <code>Abstract Data Type</code> (ADT)</li>
<li>except each element has a certain priority<ul>
<li>determine the order (removed from the PQ)</li>
</ul>
</li>
<li>need <code>comparable data</code></li>
</ul>
<p>每次取出最小（或最大）的-&gt;pool，添加到PQ，如何得知极值呢？-&gt; heap</p><h2>Heap</h2>
<ul>
<li>a tree based data structure</li>
<li>statisfies the <code>heap invariant</code>(heap property):<ul>
<li>if A is a parent node of B then A is <code>ordered with respect ot B</code> for all nodes A, B in the heap</li>
<li>说人话，A是B的父节点，如果A比B大，那么比B的所有子节点都大，vice versa</li>
</ul>
</li>
</ul>
<p>Priority Queue有时候也被叫做Heap，因为它只是一个ADT，当然它也可以用别的数据结构实现。</p><p>以下四个，都是heap
<figure class="vertical-figure" style="flex: 45.29616724738676" ><img width="1040" height="1148" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ca1ec5da989f79cdabb15eaf7cc6c092.png" alt=""/></figure></p><p>这些就不是
<figure  style="flex: 141.57608695652175" ><img width="1042" height="368" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a2a4acdc3e610752ca81c063f3b7b01f.png" alt=""/></figure></p><p><strong>Usage</strong></p><ul>
<li>certain implementations of <code>Dijkstra's Shortest Path algorithm</code></li>
<li>anytime you need the <em>dynamically</em> fetch the <strong>next</strong> <code>best</code> or <code>worst</code> element</li>
<li><code>Huffman coding</code> -&gt; lossless data compression</li>
<li>BFS，PQs <code>continuously grab the next</code> most promising node</li>
<li><code>Minimum Spaning Tree</code> (MST) algorithm</li>
</ul>
<p>可见是很多算法的基础</p><p><strong>Complexity</strong></p><ul>
<li>Binary Heap construction: O(n)</li>
<li>Polling: O(log n)</li>
<li>Peeking: O(1)</li>
<li>Adding: O(log n)</li>
<li>原生删除：O(n)<ul>
<li>with hash table: O(log n)</li>
</ul>
</li>
<li>原生contains: O(n)<ul>
<li>with hash table: O(1)</li>
</ul>
</li>
</ul>
<p><strong>Turning Min PQ into Max PQ</strong></p><p>大多数编程语言标准库只提供了min PQ。</p><ol>
<li>在构建min pq的时候，把比较标准从<code>x&gt;=y</code>变成<code>x&lt;=y</code>（operator重载）</li>
<li>在构建min pq的时候，把x变成<code>-x</code>，取出的时候再取反一次</li>
</ol>
<p>原则都是取巧，而且，第二种方法，存在pq里的，并不是你要使用（和本想存储）的对象，所以取出的时候需要处理。</p><h2>Priority Queue with Binary Heap</h2>
<p>实现了<code>heap invariant</code>的binary tree.</p><p>除了Binary Heap，还有很多</p><ul>
<li>Fibonacci Heap</li>
<li>Binomial Heap</li>
<li>Paring Heap</li>
<li>...</li>
</ul>
<p>都能实现一个PQ</p><p><strong>Adding Elements to Binary Heap</strong></p><ul>
<li>从尾部(last leaf)添加</li>
<li>如果违反了heap invairant(即比parent大)，则交换</li>
<li>向上冒泡</li>
</ul>
<p><strong>Removing Elements From a  Binary Heap</strong></p><ol>
<li>Poll()</li>
</ol>
<ul>
<li>因为root总是优先级最高的元素，<code>poll</code>移掉的就是root</li>
<li>root当然不能直接移，所以先跟最后一个元素swap</li>
<li>swap后原root就没有children了，直接移除</li>
<li>最低优先级的元素到了top，所以要向下冒泡<ul>
<li>先左后右，先低再高</li>
<li>即如果两个子级优先级一样，那么直接与左边交换</li>
<li>否则哪个优先级最低就与哪个子级交换</li>
<li>子级优先级都比它低，就完成了pool()</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Remove(m) 即删除一个特定元素</li>
</ol>
<ul>
<li>linear scan，找到元素位置</li>
<li>与last node交换，然后移除</li>
<li>last node用先上向下的原则冒泡<ul>
<li>即先看能不能往上冒泡，不能的话再看往下冒泡</li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong>
Pool(): O(log n)
Remove(): O(n) (最坏情况下，可能要删的元素在最后一个)</p><p>用hashtable优化remove</p><ul>
<li>hashtable为lookup和update提供constant time</li>
<li>因为为Index和value建立了映射，这样不需要通过遍历，直接通过映射就能找到元素<ul>
<li>如果两个node拥有同样的value呢？</li>
<li>直接把每个value对应的n个索引全部存起来(set)</li>
<li>但我应该remove哪一个呢？<ul>
<li>随便，只要最终satisfy the heap variant</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/3/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 walker</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>