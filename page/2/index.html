<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/d69e93fb6d600dd3092b98eaebaa4bce.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="AlanDecode" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/2/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">数据结构篇七：Suffix Array, Longest Common Prefix (LCP) array</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">
                <time class="text-uppercase">
                    November 16 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Suffix Array</h1>
<ul>
<li>字符串的所有子字符串后缀组成数组</li>
<li>对子串根据首字母进行排序</li>
<li>排序后原有的index就被打乱了</li>
<li>这个乱序的indices就是<code>Suffix Array</code></li>
</ul>
<p>做尾缀子串的时候通常是从单个字母开始越找越多，这就有了一个原生顺序，然后用首字母排序后，这个顺序就被打乱了</p><p>提供了一种<code>compressd representation</code> of sorted suffixes而无需真的把这些子串存起来。</p><ul>
<li>A space efficient alternative to a <code>suffix tree</code><ul>
<li>a compressd version of a <code>trie</code>?</li>
</ul>
</li>
</ul>
<p>能做所有<code>suffix tree</code>能做的事，并加添加了<code>Longest Common Prefix</code>(LCP) array</p><h1>Longest Common Prefix (LCP) array</h1>
<p>继续上面的Suffix Array，字母排序后，我们一个个地用每一个元素同上一个元素比，标记相同前缀的字母个数，这个数字序列就是<code>LCP</code></p><p>比如adc, adfgadc, 前缀<code>ab</code>是相同的，那就是2。</p><p>第一个元素没有“上一个”去比，所以LCP数组第1位永远是0？（是的，其实是undefined，但一般设0）</p><p>衡量的是相邻的suffix array元素的前缀间有多少个字母相同。</p><p>当前也可以和下一个元素比（这样最后一个元素的LCP肯定是0了，原理同上）</p><h2>Find unique substrings</h2>
<p>找到（或计数）一个数组的所有（不重复的）子元素。可以逐个substring遍历，$O(n^2)$，下面看看更快也更省空间的LCP方案。</p><p>找“AZAZA”的不重复子串:
A,AZ,AZA,AZAZ,AZAZA,Z,ZA,ZAZ,ZAZA,<code>A,AZ,AZA,Z,AZ,A</code>，把重复的标注了出来。
LCP是这样的：
LCP|Sorted Suffixes|
-|-
0|A
1|AZA
3|AZAZA
0|ZA
2|ZAZA</p><p>我们知道第一列指的是“重复个数”，也就是说，如果按我们手写的那样去遍历，至少有这么多重复的子串，重复的既是“个数”，也是“组合方式”。</p><p>所以如果我们只需要计数的话，把右边的数出来就知道有会有多少个重复的了，此例为6.</p><p>$$\tt unique\ count = \underbrace{\frac{n(n+1)}{2}}_{substr\ count} - \underbrace{\sum_{i=1}^n LCP[i]}_{duplicates}$$</p>
<p>这是LCP的应用之一，利用了LCP本身就是在数重复次数的特征。</p><h2>K common substring problem</h2>
<p>n个字符串，找出一个子串，它至少是k个字符串的子串，求最大子串。$2\leq k \leq n$</p><p>即如果有k=2，那么这个子串只需要是其中两个的子串就行了，如果k=n，那么就需要是每一个字符串的子串。</p><p>直接上图
<figure  style="flex: 50.4885993485342" ><img width="1240" height="1228" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/b7cb01449aa00a46b95ca35f28751a33.png" alt=""/></figure></p><ul>
<li>图1演示k=3时，找到了<code>ca</code>，即3个串里都有的是<code>ca</code></li>
<li>图2演示k=2时，找到了<code>bca</code>，即<code>bca</code>存在2个串里</li>
<li>图3演示的是用了size=4的滑窗才包含了3个字符串，以及最大匹配是<code>AG</code></li>
</ul>
<p>步骤：</p><ol>
<li>首先，用几个分隔符把字符串拼接起来<ul>
<li>分隔符字符串里不会出现</li>
<li>分隔符的排序要小于所有字符</li>
</ul>
</li>
<li>图中染色的依据是prefix是哪个串里的就染成什么颜色</li>
<li>开始滑窗比较<ul>
<li>滑窗必须要能包含k种颜色</li>
<li>所以滑窗大小不是固定的，有时候相邻几个都是来自同一个字符串</li>
<li>滑窗里除0外的最小值，就是符合条件的最大共同长度，如图3，最大匹配长度是2</li>
<li>课程里动画演示滑窗其实不是用滑的，而是用的爬行<ul>
<li>即下界往下，包含了所有颜色之后，上界也往下，这样蠕行前进，每一步判断滑窗里的内容</li>
</ul>
</li>
</ul>
</li>
<li>额外需要一个hash table来保存切片与颜色的映射关系。<ul>
<li>如果是例子这么简单，我可以直接检查第一个出现的分隔符，是#就是绿色，出现$就是蓝色，%就是红色</li>
</ul>
</li>
</ol>
<p>核心就是：</p><ul>
<li>取子串是从后向前取的</li>
<li>但比较是从前向后比的</li>
<li>前面的元素可能来自任何一个子串（只要足够长）</li>
<li>从前面排序，客观上就把来自不同字符串的相同字母打头的子串给排到一起了</li>
</ul>
<p>这就是为什么在<code>Suffix</code> Array的内容里面出现Longest Common <code>Prefix</code>的内容的原因了.</p><p>聪明。</p><h2>Longest Repeated Substring (LRS)</h2>
<figure  style="flex: 72.68464243845251" ><img width="1240" height="853" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ef47276f994f76ccabc2c60900227916.png" alt=""/></figure><p>这个比暴力遍历要简单太多，直接找LCP最大值即可</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">数据结构篇六：Fenwick Tree (Binary Indexed Tree)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">
                <time class="text-uppercase">
                    November 15 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Fenwick Tree (Binary Indexed Tree)</h1>
<p>树状数组</p><p><strong>Motivation</strong></p><figure  style="flex: 118.0952380952381" ><img width="1240" height="525" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2591209692305dbd9d640a53765581e1.png" alt=""/></figure><ul>
<li>计算数组里任意连续片段的和，最直观的方案当然是累加：线性时间O(n)</li>
<li>但是如果你有一个记录了每个节点到当前位置时的累加和的数组（<code>prefix sum</code>），立刻变成了常量时间</li>
<li>问题是更新数据变成了线性时间（后续所有的求和都要改一遍）<ul>
<li>great for <code>static arrays</code></li>
</ul>
</li>
</ul>
<p>所以引入了:
<code>Fenwick Tree</code> is an efficient data structure for performing range/point queries/updates.(即在上面的动机上，还考虑了update的效率)</p><p>前面的例子在update时效率不高，所以Fenwick Tree用了一种聪明的方式，不是累加所有的值，而是分段累加，具体实现看下图：
<figure  style="flex: 67.24511930585683" ><img width="1240" height="922" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/eb45cb86abbe7a62cd8cc8d3fc2a8f06.png" alt=""/></figure></p><ul>
<li>把索引值用二进制表示</li>
<li><code>LSB</code>的解释看图，实际应用上，就是看从低位到高位第一个1的右边有几个0，假设为<code>n</code>个</li>
<li>那么该cell上存的值就是前$2^n$个cell的值的和</li>
</ul>
<p>图中例子是索引10，不直观，我们换成12， 二进制是1100， 最右边有2个零，那么它保存它$2^2=4$个位置的和。
也就是说，如果你要求和，如果用了cell 12位置的值的话，至少可以省掉3次累加。</p><p>当然，它还有更牛逼的特性，结合range query一起来看吧：
<figure  style="flex: 67.3913043478261" ><img width="1240" height="920" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/0a9944a0140262760c9fb4a45cb3d75e.png" alt=""/></figure></p><p>蓝线表示的是当然位置上累加了前几个位置的值，已经很有规律了</p><p>假如计算前11个值的和，过程是：</p><ol>
<li>11的索引是1011，右边没有0，所以当前的和为A[11]</li>
<li>根据$2^0$来移位，来到10。<ul>
<li>右边一个0，所以它管$2^1$个presum，目前A[11] + A[10]</li>
<li>下一个索引自然要减2了，来到8</li>
</ul>
</li>
<li>8是1000，3个零，所以它存了$2^3=8$个值的和，那就是全部了</li>
</ol>
<p>所以：sum = A[11] + A[10] + A[8]</p><ul>
<li>心算sum(0,7)巩固一下</li>
<li>用sum(11,15)演示子区间，其实就是多减1次，至于是减到10还是减到11，看描述，比如这里11是要参与计算的，那就是把前10个减掉就行了。</li>
</ul>
<p>上面演示的都是<code>worst</code>的情况，即首位为1，除了这种情况，别的位都至少存了前$2^n$个元素的值（比如16，直接得到16个元素的和）</p><blockquote>
<p>这里都没讲你是怎么做这个tree的，而是怎么使用它。先弄清楚使用场景再谈构建。</p></blockquote>
<h2>Point Update</h2>
<p>复习一下<code>LSB</code>，虽然可以直接数最右边的零的个数，但数学其实是：</p><ul>
<li>13 = 1101 ($2^3 + 2^2 + 2^0 \Rightarrow 10^3 + 10^2 + 10^0 $)</li>
<li>减去最右边的1和0 =&gt; 1100 （$2^3+2^2=12$) 所以下一个数是12</li>
<li>减去最右边的1和0 =&gt; 1000 就是8了</li>
<li>再减就是0了</li>
</ul>
<p>而按$2^n$来计算个数的话就是这样的：</p><ul>
<li>13 = 1101, 没有0，就是移1位，变成12</li>
<li>12 = 1100， 2个0， 就是移4位，变成8</li>
<li>8 = 1000， 3个0， 移8位，变成0</li>
</ul>
<p>现在来讲update，前面知道，update会级联影响到所以把该cell考虑进去的节点，因此，它需要反着往上找（极端情况当然是找到最后一个元素，通常这个元素就是整个数组的值，所以任何元素的更改，肯定都会影响到它）</p><p>前面找下一个节点用的是减法，现在就要用加法了，比如我更新了cell 9, 用以上两种任意一种方法来计算：</p><ul>
<li>$9 = 2^3 + 1 \Rightarrow 10^3 + 1 = 1001, +1 = 1010 = 10$</li>
<li>1010 + 10 = 1100 = 12</li>
<li>1100 + 100 = 10000 = 16 到顶了，</li>
</ul>
<p>所以需要把9, 10, 12, 16分别应用这个point的更新，也就是说只有这几个cell把9计算进去了。</p><figure  style="flex: 66.59505907626209" ><img width="1240" height="931" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/57cf2e654121e8c54e9f6cd1eeb60d9b.png" alt=""/></figure><p>当然，可以看一下左边的示意图，更直观</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> 
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> 
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<p>代码非常简单，就是不断通过LSB找下一个位置去更新就行了。</p><h2>Construction</h2>
<p>现在来讲构建</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">construct</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">length</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># Clone the values array since we’re # doing in place operations</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">deepCopy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
<p>几乎就一句话，就是把元素按原数据摆好（即不加别的节点）后，每次找到当前元素影响的上一级（不再向上冒泡）</p><ul>
<li>比如1，把1算进去的有2，虽然上面还有4， 8， 16，但只把1更新到2</li>
<li>到2的上一级是4 (2 + lsb(2) = 4), 把节点2的现值（已经加了节点1）加到4去</li>
<li>所以核心算法始终只有两个变量，i，j代表最近的包含关系</li>
</ul>
<p><strong>一些算法换成位运算</strong></p><ul>
<li>lsb(i): <code>i &amp; -i</code></li>
<li>i -= lsb(i) =&gt; <code>i &amp;= ~lsb(i)</code></li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/" target="_self">数据结构篇五：Hash Tables</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/" target="_self">
                <time class="text-uppercase">
                    November 15 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Hash Tables</h1>
<ul>
<li>key-value pair</li>
<li>using <code>Hashing</code> technique</li>
<li>often used tracking item frequencies</li>
</ul>
<p>what's <em>hash function</em>?</p><ul>
<li>maps a key <code>x</code> to a whole number in a fixed <code>range</code>.<ul>
<li>e.g. $H(x) = (x^2 - 6x + 9) % 10$ maps (0, 9)</li>
<li>这个方程会为不同的x产生一样的y -&gt; <code>hash collision</code></li>
</ul>
</li>
<li>can hash arbitrary objects like string, list, tuple...</li>
<li>must be <code>deterministic</code>(确定的x产生确定的y)<ul>
<li>因此key的应该是<code>immutable</code>的类型</li>
</ul>
</li>
</ul>
<p>关键词是<code>range</code>，你设计的function总要mod一下，将结果限制在一个范围内。这里你应该暂时能推测出hashtable的key可能就是数字吧？</p><p><strong>hash collision</strong></p><ul>
<li><code>separate chaining</code></li>
</ul>
<p>用一种数据结构（通常是链表）保留所有冲突的值</p><ul>
<li><code>open addressing</code></li>
</ul>
<p>为冲突的值选择一个offset（地址/值）保存 -&gt; <code>probing sequence P(x)</code></p><p>不管是怎么解决冲突，<strong>worst</strong>的情况下，hash table的操作时间也会由O(1)变成O(n)</p><p>怎么用HT来查找呢？不是把hash后的结果拼到原数据上，而是每次查询前，对key进行一次hash function，就能去查询了。</p><h2>Open Addressing</h2>
<p><strong>probing sequences</strong></p><ul>
<li>linear probing: P(x) = ax + b</li>
<li>quadratic probing: p(x) = $ax^2 + bx + c$</li>
<li>double hashing: p(k, x) = $x * H_2(k)$ 双重hash</li>
<li>pseudo random number generator: p(k, x) = x * rng(H(k), x) 用H(k)(即hash value)做种的随机数</li>
</ul>
<p>总之就是在这样一个序列里找下一个位置</p><p>假设一个table size 为N的HT，使用开放寻址的伪代码：</p><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">keyHash</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>   <span class="c1"># 直接计算出来的hash value</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">keyHash</span>  <span class="c1"># 偏移过后存在HT里的index</span>

<span class="k">while</span> <span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyHash</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">%</span> <span class="n">N</span>  <span class="c1"># 加上偏移，考虑size（N）</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 游标加1</span>

<span class="c1"># now can insert (k,v) at table[index]</span>
</pre></div>
<h3>Chaos with cycles</h3>
<p><strong>Linear Probling (LP)</strong></p><p>LP中，如果你<em>运气不好</em>，产生的序列的下一个值永远是occupied的状态（一般是值域小于size），就进入死循环了。</p><p>假设p(x) = 3x, H(k) = 4, N = 9
那么H(k)+P(x) % N 只会产生{4,7,1}，如果这三个位置被占用，那就陷入了永远寻找下一个的无限循环中。</p><p>一般是限制probing function能返回刚好N个值。</p><blockquote>
<p>当p(x)=ax的a与size的N互质，即没有公约数，<code>GCD(a, N) = 1</code>一般能产生刚好N个值。(Greatest Common Denominator)</p></blockquote>
<blockquote>
<p>注意，为了性能和效率的平衡，有<code>load factor</code>的存在，所以到了阈值，size就要加倍，N的变化，将会使得<code>GCD(a, N) = 1</code>的a的选择有变化，而且之前对N取模，现在取值也变发生变化，这时候需要重新map</p></blockquote>
<p>重新map不再按元素当初添加的顺序，而是把现有HT里的值按索引顺序重新map一遍。比如第一个是k6, 即第6个添加进来的，但是现在第一个就重新计算它的值，填到新的HT里面去。</p><p><strong>Quadratic Probing （QP）</strong></p><p>QP 同样有chaos with cycles的问题，通用解决办法，三种：</p><ol>
<li>p(x) = $x^2$, size选一个 prime number &gt; 3, and $\alpha \leq \frac{1}{2}$</li>
<li>p(x) = $(x^2 + x) / 2$, keep the size a power of 2 （不需要是素数了）</li>
<li>p(x)= $(-1^x) \times x^2$, make size prime N $\equiv 3$ mod 4 ???</li>
</ol>
<p><strong>Double Hashing</strong></p><p>Double Hashing: P(x) = $x \times H_2(k)$可见仍然类似一个一次的线性方程，$H_2(k)$就类似于ax中的a，设为$\delta$，相比固定的a, 这里只是变成了动态的，这样不同的key的待选序列就是不一样的（可以理解为系数不同了）</p><p>解决chaos:</p><ol>
<li>size N to be a prime number</li>
<li>calculate: $\delta = H_2(k)$ mod N<ul>
<li>$\delta=0$ 时offset就没了，所以需要人为改为1</li>
<li>$1 \leq \delta \lt N$ and GCD($\delta$, N) = 1</li>
</ul>
</li>
</ol>
<p>可见，虽然系数是“动态”的了，但是取值还是（1，N）中的一个而已，hash只是让其动起来的一个原因，而不是参与计算的值。</p><p>我们本来就是在求hash value，结果又要引入另一个hash function，显然这个$H_2$不能像外层这样复杂，一般是针对常见的key类型(string, int...-&gt; fundamental data type)的<code>universal hash functions</code></p><blockquote>
<p>因为N要是一个素数，所以在double size的时候，还要继续往上找直到找到一个素数为止，比如N=7, double后，N=14，那么最终，N=17</p></blockquote>
<figure  style="flex: 67.68558951965065" ><img width="1240" height="916" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/cbae1de97a3f72ae84ea59804293ec56.png" alt=""/></figure><h3>Issues with removing</h3>
<p>因为冲突的hash value需要probing，probing的依据是从序列里依次取出下一个位置，检查这个位置<strong>有没有被占用</strong>，那么问题就来了，如果一个本被占用的位置，因为元素需要删除，反而变成没有占用了，这有点类似删除树节点，不但要考虑删除，还要考虑这个位置怎么接续。</p><p><strong>lazy deletion</strong>
但HT机制比树要复杂，为了避免反复应用probing函数重新摆放后续所有节点，干脆就在删除的位置放置一个预设的标识，我们称为墓碑(<code>tombstone</code>)，而不是直接置空，然后所有的查找和添加加上这一条规则，就能快速删除又无需重新排序。</p><p>大量删除会造成空间浪费，但无需立即处理：</p><ol>
<li>添加元素允许添加到墓碑位置</li>
<li>到达阈值容量需要倍增的时候有一次重排，这个时候就可以移除所有的墓碑</li>
</ol>
<p>如果查找一个hash value，连续3个都是墓碑，第4个才是它，这是不是有点浪费时间？
确实，所以还可以优化，当你查找过一次之后，就可以把它移到第一个墓碑的位置，这样，<strong>下次</strong>查询的时候速度就会快很多了。</p><p>整个机制，叫<code>lazy deletion</code></p><figure class="vertical-figure" style="flex: 29.61816305469556" ><img width="1148" height="1938" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a935a20b4bc9641962766872aace8306.png" alt=""/></figure></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%94%EF%BC%9AHash-Tables/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/" target="_self">数据结构篇四：Binary Trees and Binary Search Trees (BST)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/" target="_self">
                <time class="text-uppercase">
                    November 14 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<p>Tree: 满足以下定义的<code>undirected graph</code>(无向图)</p><ul>
<li>An acyclic(非循环的) connected graph</li>
<li>N nodes and N-1 edges</li>
<li>有且只有一条路径连接<em>任意</em>两个顶点</li>
</ul>
<blockquote>
<p>任意一个节点都可以被理解为root</p></blockquote>
<p><strong>Binary Tree</strong>
拥有最多两个节点的Tree</p><p><strong>Binary Search Tree</strong>
服从以下特性的<code>binary tree</code></p><ul>
<li>左子树的元素小于右子树</li>
</ul>
<p>拥有重复元素是允许的，但多数情况下我们只研究不重复的元素</p><p>这是一个有效的BST吗？
<figure  style="flex: 57.83582089552239" ><img width="1240" height="1072" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d9ca27993e1a1228a3ffcadf9ed86aba.png" alt=""/></figure></p><p>是的（对于单链下来的，几乎会直接就满足右边比左边大）</p><p><strong>Usage</strong></p><ul>
<li>BSTs<ul>
<li>implementation of some map and set ADTs</li>
<li>red black trees</li>
<li>AVL trees</li>
<li>splay trees</li>
<li>...</li>
</ul>
</li>
<li>binary heaps</li>
<li>syntax trees (by compiler and calculators)</li>
<li>Treap - a probabilistic DS (uses a randomized BST)</li>
</ul>
<p><strong>Complexity</strong>
增删查平均为O(log n)，但最差情况下都为O(n)，即线性时间</p><h2>Adding elements to a BST</h2>
<ul>
<li>第一个为root</li>
<li>每一个新数，比顶点大，放右边，比顶点小，放左边，顺序下行<ul>
<li>不是从左到右摆满再做subtree</li>
<li>比如3,6,9, 会得一棵全部数字摆在右边的数，而不是顶3左6右9的三角形</li>
<li>这也是为什么极端情况下，时间复杂度是<code>O(n)</code>，因为就是一条线到底</li>
<li>这也是<code>balanced binary search trees</code>被引入的原因</li>
</ul>
</li>
</ul>
<h2>Removing elements from a BST</h2>
<ul>
<li>find<ul>
<li>从root开始，小的走左右，大的走右边</li>
</ul>
</li>
<li>replace (to maintain the BST invariant)</li>
</ul>
<p>找继任者的时候，如果删除元素没有子节点，只有左或右子节点，都很好办，但如果它有两个子节点，那么应该用哪个来接续呢？</p><p>原则仍然是要服从左边的比右边的小，所以你其实有两种选择：</p><ul>
<li>把左边最大的数选出来 或</li>
<li>把右边最小的数选出来</li>
</ul>
<p>因为它们的“来源”，肯定是能保证bst invariant的
    * 这个数是要替换这个节点的，所以要比这个节点左边的数都大，及比右边所有的数都小，显然就是左边的最大数，或右边的最小数了。
    * 只是把找到的元素复制过去后，多了的那个怎么办呢？</p><ul>
<li>递归</li>
</ul>
<p>新找到的元素当然要从原来的位置删除，这时又根据它是否叶节点，单子节点还是全节点，来反复进行前面的操作，最终总是可以退出的
<figure  style="flex: 57.83582089552239" ><img width="1240" height="1072" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/511db0d1a3889dca35b02ce18318c787.png" alt=""/></figure></p><figure  style="flex: 68.69266055045871" ><img width="1198" height="872" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/85b0081fb572f97bd8fb1a93c9ca3d90.png" alt=""/></figure><h2>Tree Traversals</h2>
<p>(Preorder, Inorder, Postorder &amp; Level order)
<figure  style="flex: 92.67563527653213" ><img width="1240" height="669" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/731be06981a3a58193e3d1ea54d7fd22.png" alt=""/></figure></p><ul>
<li>preorder，在遍历左侧元素的时候，每次已经先取到元素了（最顶层）</li>
<li>inorder里，遍历元素的时候，直到所有的left走完了，才取到第一个元素（最底层的）</li>
<li>postorder里，也是遍历到最底层，但是下一步就是取兄弟节点了</li>
</ul>
<figure  style="flex: 99.51845906902086" ><img width="1240" height="623" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/47fe26cb82c30df966d2cbb9f8bd3ee8.png" alt=""/></figure><p>inorder一个重要特征：它是从小到大排好序的！
<figure  style="flex: 97.79179810725552" ><img width="1240" height="634" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/730f8d00e817c006cb9c33171da53386.png" alt=""/></figure>
preorder 和 postorder没什么特征，举一个post的例子观察下</p><p>而levelorder则是一<code>层</code>一层地取的：</p><figure  style="flex: 91.58050221565732" ><img width="1240" height="677" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/483fae0876dbf6b3d954f86b6341ecf5.png" alt=""/></figure>
这就是广度优先了（<code>Breadth First Searth</code>)BFS<p>实现BFS</p><ol>
<li>每处理一个parent的时候，把parent加到结果数组里</li>
<li>parent的子节点加到队列里</li>
<li>每次从队列里取出一个值加到结果数组里（步骤1）</li>
<li>该值的child加到队列里（步骤2）</li>
</ol>
<p>其实就是步骤1，2的重复，比如：
<figure  style="flex: 70.7516339869281" ><img width="866" height="612" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/80ff2df354c0700753943e83fd5cd17a.png" alt=""/></figure></p>
<pre><code>[11], [6, 15] 处理第1个数11， 队列里多了两个元素6， 15
[11, 6], [15, 3, 8] 从队列里取出6， 加入结果，它的子元素(3, 8)加入队列
[11, 6, 15], [3, 8, 13, 17]
[11, 6, 15, 3], [8, 13, 17, 1, 5]
[11, 6, 15, 3, 8], [13, 17, 1, 5] 这一步，8没有子节点了，队列变短了
[11, 6, 15, 3, 8, 13], [17, 1, 5, 12, 14]
[11, 6, 15, 3, 8, 13, 17], [1, 5, 12, 14, 19] 17只有一个child
[11, 6, 15, 3, 8, 13, 17, 1, 5, 12, 14, 19] 剩下的都没child了，全部拼进去
</code></pre>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%9B%9B%EF%BC%9ABinary-Trees-and-Binary-Search-Trees-%28BST%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/" target="_self">数据结构篇三：Union Find</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/" target="_self">
                <time class="text-uppercase">
                    November 14 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Union Find</h1>
<ul>
<li>keep track of elements in different sets</li>
<li>primary operations: <code>find</code> and <code>union</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>Kruskal's <code>minimum spanning tree</code> algorithm</li>
<li>Grid percolation</li>
<li>Network connectivity</li>
<li>Least common ancestor in trees</li>
<li>Image processing</li>
</ul>
<p><strong>Complexity</strong></p><ul>
<li>construction: O(n)</li>
<li>union/join/size/check connected/: $\alpha$(n) :接近常量时间</li>
<li>count: O(1)</li>
</ul>
<p>给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树(<code>Spanning Tree</code>)。如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, <code>Minimum Spanning Tree</code>)。
-&gt; 用最少的边连接所有的顶点</p><ul>
<li>sort edges by ascending edge weight</li>
<li>walk through edges<ul>
<li>检查顶点，如果两个顶点都已经unified，就忽略<ul>
<li>其实就是这两个点分别被别的边连过了</li>
</ul>
</li>
<li>否则就添加edge，并且unify顶点</li>
</ul>
</li>
</ul>
<p>看到这里，首先想知道什么是unified，看实现，也就是在一个集合里(component)
<figure class="vertical-figure" style="flex: 42.622950819672134" ><img width="1040" height="1220" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/475d857d18dc3fe4749139b896e6f68a.png" alt=""/></figure></p><ul>
<li>观察C_J，因为C和J已经在一个组里了，这条边就不需要了</li>
<li>观察D_E，一旦连上后，紫色和绿色其实就是一个组了</li>
</ul>
<figure class="vertical-figure" style="flex: 36.810730253353206" ><img width="988" height="1342" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a3a52e1b62a1b105bc18f817ba801011.png" alt=""/></figure><ul>
<li>观察D_H，一旦连上后，紫色和红色也成为了一个组</li>
<li>连接B_C，所有顶点就全部连上了，并且只有一条紫线</li>
</ul>
<p>Find: 找元素在哪个component里，然后找到它的root
Union: 找两个元素分别在哪个component里，然后找到它们的root，如果不是同一个root，就让其中一个成为另一个的parent</p><ul>
<li>component的个数与root的个数一致</li>
<li>root的个数只减不增（因为通常只合并而不拆分）</li>
</ul>
<p>union find里</p><ul>
<li>为每个元素分配一个索引，每个元素指向自己（即初始是n个root，n个component)</li>
<li>描述两两之间的关系，以任一元素为parent （谁来描述？）</li>
<li>有一个元素已经属于别的component里的，就将它也加到那个component里去<ul>
<li>如果这个元素也是别的component里的顶点，就把整个组指向另一个组的root</li>
</ul>
</li>
</ul>
<h2>Path Compression Union Find</h2>
<figure class="vertical-figure" style="flex: 36.48111332007952" ><img width="734" height="1006" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5bac1a63885746047c532e2362b8ead9.png" alt=""/></figure><p>由一层层找到root改为所有顶点直接指向顶点（星形结构），实现路径压缩</p><p>这段代码演示的是，查找p的root节点，在查找的过程中，顺便进行了路径压缩
<figure  style="flex: 102.99003322259136" ><img width="1240" height="602" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6de31545897b5731ee7c6916033393a1.png" alt=""/></figure></p><p>合并的逻辑就是比较谁的元素多就把谁当作root，另一个component的root的parent设为元素多的组的root<br />
合并完成后组数就少了1
<figure  style="flex: 71.1825487944891" ><img width="1240" height="871" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1b52c2255e8963040253701946bae7d8.png" alt=""/></figure></p><p>看代码，这一步里面并没有路径压缩，也就是小组里面的元素并没有<strong>进一步</strong>再星状地指向新的parent，仍然指向的是老的组的root。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%89%EF%BC%9AUnion-Find/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/" target="_self">数据结构篇二：Priority Queues (PQs) with an interlude on Heaps</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/" target="_self">
                <time class="text-uppercase">
                    November 13 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><p>优先队列和堆的插曲，在优先队列里引入了heap只是个插曲而不算正式介绍，但其实讲得差不多了。</p><hr />
<h1>Priority Queues (PQs) with an interlude on heaps</h1>
<ul>
<li>A priority queue is an <code>Abstract Data Type</code> (ADT)</li>
<li>except each element has a certain priority<ul>
<li>determine the order (removed from the PQ)</li>
</ul>
</li>
<li>need <code>comparable data</code></li>
</ul>
<p>每次取出最小（或最大）的-&gt;pool，添加到PQ，如何得知极值呢？-&gt; heap</p><h2>Heap</h2>
<ul>
<li>a tree based data structure</li>
<li>statisfies the <code>heap invariant</code>(heap property):<ul>
<li>if A is a parent node of B then A is <code>ordered with respect ot B</code> for all nodes A, B in the heap</li>
<li>说人话，A是B的父节点，如果A比B大，那么比B的所有子节点都大，vice versa</li>
</ul>
</li>
</ul>
<p>Priority Queue有时候也被叫做Heap，因为它只是一个ADT，当然它也可以用别的数据结构实现。</p><p>以下四个，都是heap
<figure class="vertical-figure" style="flex: 45.29616724738676" ><img width="1040" height="1148" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ca1ec5da989f79cdabb15eaf7cc6c092.png" alt=""/></figure></p><p>这些就不是
<figure  style="flex: 141.57608695652175" ><img width="1042" height="368" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a2a4acdc3e610752ca81c063f3b7b01f.png" alt=""/></figure></p><p><strong>Usage</strong></p><ul>
<li>certain implementations of <code>Dijkstra's Shortest Path algorithm</code></li>
<li>anytime you need the <em>dynamically</em> fetch the <strong>next</strong> <code>best</code> or <code>worst</code> element</li>
<li><code>Huffman coding</code> -&gt; lossless data compression</li>
<li>BFS，PQs <code>continuously grab the next</code> most promising node</li>
<li><code>Minimum Spaning Tree</code> (MST) algorithm</li>
</ul>
<p>可见是很多算法的基础</p><p><strong>Complexity</strong></p><ul>
<li>Binary Heap construction: O(n)</li>
<li>Polling: O(log n)</li>
<li>Peeking: O(1)</li>
<li>Adding: O(log n)</li>
<li>原生删除：O(n)<ul>
<li>with hash table: O(log n)</li>
</ul>
</li>
<li>原生contains: O(n)<ul>
<li>with hash table: O(1)</li>
</ul>
</li>
</ul>
<p><strong>Turning Min PQ into Max PQ</strong></p><p>大多数编程语言标准库只提供了min PQ。</p><ol>
<li>在构建min pq的时候，把比较标准从<code>x&gt;=y</code>变成<code>x&lt;=y</code>（operator重载）</li>
<li>在构建min pq的时候，把x变成<code>-x</code>，取出的时候再取反一次</li>
</ol>
<p>原则都是取巧，而且，第二种方法，存在pq里的，并不是你要使用（和本想存储）的对象，所以取出的时候需要处理。</p><h2>Priority Queue with Binary Heap</h2>
<p>实现了<code>heap invariant</code>的binary tree.</p><p>除了Binary Heap，还有很多</p><ul>
<li>Fibonacci Heap</li>
<li>Binomial Heap</li>
<li>Paring Heap</li>
<li>...</li>
</ul>
<p>都能实现一个PQ</p><p><strong>Adding Elements to Binary Heap</strong></p><ul>
<li>从尾部(last leaf)添加</li>
<li>如果违反了heap invairant(即比parent大)，则交换</li>
<li>向上冒泡</li>
</ul>
<p><strong>Removing Elements From a  Binary Heap</strong></p><ol>
<li>Poll()</li>
</ol>
<ul>
<li>因为root总是优先级最高的元素，<code>poll</code>移掉的就是root</li>
<li>root当然不能直接移，所以先跟最后一个元素swap</li>
<li>swap后原root就没有children了，直接移除</li>
<li>最低优先级的元素到了top，所以要向下冒泡<ul>
<li>先左后右，先低再高</li>
<li>即如果两个子级优先级一样，那么直接与左边交换</li>
<li>否则哪个优先级最低就与哪个子级交换</li>
<li>子级优先级都比它低，就完成了pool()</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Remove(m) 即删除一个特定元素</li>
</ol>
<ul>
<li>linear scan，找到元素位置</li>
<li>与last node交换，然后移除</li>
<li>last node用先上向下的原则冒泡<ul>
<li>即先看能不能往上冒泡，不能的话再看往下冒泡</li>
</ul>
</li>
</ul>
<p><strong>Complexity</strong>
Pool(): O(log n)
Remove(): O(n) (最坏情况下，可能要删的元素在最后一个)</p><p>用hashtable优化remove</p><ul>
<li>hashtable为lookup和update提供constant time</li>
<li>因为为Index和value建立了映射，这样不需要通过遍历，直接通过映射就能找到元素<ul>
<li>如果两个node拥有同样的value呢？</li>
<li>直接把每个value对应的n个索引全部存起来(set)</li>
<li>但我应该remove哪一个呢？<ul>
<li>随便，只要最终satisfy the heap variant</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%BA%8C%EF%BC%9APriority-Queues-%28PQs%29-with-an-interlude-on-Heaps/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/" target="_self">数据结构篇一：Array, Linked-List, Stack, Queues</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><p>前几个比较基础,只记录了些关键字和提纲</p><h1>Static and Dynamic Arrays</h1>
<p><strong>static array</strong></p><ul>
<li>fixed length</li>
<li>indexable</li>
</ul>
<p>usage:</p><ul>
<li>sequential data</li>
<li>IO routines as buffers</li>
<li>lookup tables and inverse lookup tables</li>
<li>return multiple values</li>
</ul>
<p>operation complexity:
access: O(1)
search: <code>O(n)</code>
insert: <code>O(n)</code>
append: O(1)
delet: <code>O(n)</code>
需要遍历的操作就是O(n)</p><p>Q: How to implement a dynamic array?
A:</p><ol>
<li>static array with an initial capacity</li>
<li>add new elements, keep tracking the size</li>
<li>if exceed capacity, create a new static array with <code>twice the capacity</code><ul>
<li>and copy the original elements into it</li>
</ul>
</li>
</ol>
<h2>Singly and Doubly Linked Lists</h2>
<p>单向/双向链表</p><p>sequential list of nodes that hold data which point to other nodes also containing data.</p><ul>
<li>节点序列，</li>
<li>节点拥有指向别的节点的数据（指针）</li>
<li>别的节点也拥有这种指针</li>
</ul>
<p>usage:</p><ul>
<li>many <code>List, Queue &amp; Stack</code> implementations</li>
<li>circular lists</li>
<li>model real world objects such as <code>trains</code></li>
<li>implementation of adjancy list for graphs</li>
<li>separate chaining -&gt; ?<ul>
<li>deal with hashing collisions -&gt; ?</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述两上问号后续在<code>Hash Table</code>一节里自然就解惑了</p></blockquote>
<p><strong>Terminology</strong>
Head / Tail / Pointer / Node</p><p>Singly vs Doubly</p><ul>
<li>Doubly holds a <code>next</code> and <code>prev</code> reference, which Singly has no <code>prev</code><ul>
<li>插入删除的时候需要更新所有引用</li>
</ul>
</li>
<li>both maintain a reference of <code>head</code> and <code>tail</code> for quick additions / removals</li>
</ul>
<p><strong>insertion</strong></p><ul>
<li>create a traverser and move by sepcific steps</li>
<li>create new node</li>
<li>singly:<ul>
<li>原node的next指向新node</li>
<li>新node的next指向原next的node</li>
</ul>
</li>
<li>doubly:<ul>
<li>新node的next和prev分别指向原node和下一个node</li>
<li>两个node分别用next和prev指向新node</li>
</ul>
</li>
</ul>
<p><strong>removal</strong></p><p>singly需要两个游标:</p><ul>
<li>pt1指向head, pt2指向head-&gt;next</li>
<li>pt1, pt2一起移动，直到pt2找到目标</li>
<li>pt2再向前移动一步</li>
<li>pt1位置的node用next指向pt2位置</li>
<li>now can sefely remoing the element between pt1 and pt2</li>
</ul>
<p>doubly却只需要一个：</p><ul>
<li>pointer找到目标元素</li>
<li>用prev和next找到上一个和下一个</li>
<li>下一个和下一个node分别互相指向</li>
</ul>
<p><strong>Complexity</strong>
searth: <code>O(n)</code>
insert at head/tail: O(1)
remove at head: O(1)
remove at tail: <code>O(n)</code> (singly) / O(1) (doubly)
因为即使我们知道tail在哪，在单向链表中，我们也找不到它的前一个去设置为新的tail
remove in middle: <code>O(n)</code></p><h1>Stack</h1>
<ul>
<li>one-ended linear data structure (LIFO)</li>
<li>two operation: <code>push</code> and <code>pop</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>undo mechanisms</li>
<li>compiler syntax checking for matching brackets and braces<ul>
<li>开括号压入栈内，每碰到一个闭括号，与栈顶的比较，匹配就出栈，不匹配就报错</li>
</ul>
</li>
<li>model a pile of books or plates<ul>
<li>汉诺塔(tower of hanoi)</li>
</ul>
</li>
<li>tracking previous function calls</li>
<li>DFS on a graph</li>
</ul>
<p><strong>Complexity</strong>
push/pop/peek/size: O(1)
search: <code>O(n)</code></p><p>双向链表实现一个Stack，基本上就是操作tail</p><h1>Queues</h1>
<ul>
<li>a linear data structure, model real world queues (FIFO)</li>
<li>two primary operations: <code>enqueue</code>, <code>dequeue</code></li>
</ul>
<p><strong>Usage</strong></p><ul>
<li>any waiting line models a queue</li>
<li>keep track of the x most recently added elements -&gt; ?</li>
<li>web server request management where you want first come first serve</li>
<li>BFS graph traversal</li>
</ul>
<p><strong>Complexity</strong></p><p>只有<code>contains, revomval</code>需要遍历，其它操作（出入列等）都是O(1)</p><p>实现一个BFS：</p><p>基本就是动态往 queue 里添加子节点,当前级别元素访问完后, 再 dequeue 出来的就是所有的下一级子节点
<figure  style="flex: 92.55319148936171" ><img width="1044" height="564" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/910285ef71036aa37402e819d06f56fc.png" alt=""/></figure></p><p>双向列表实现Queue，入列用tail，出列用head，即添加的总在尾巴，永远从头部取出。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%80%EF%BC%9AArray-Linked-List-Stack-Queues/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" target="_self">全排列，递归与分治</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" target="_self">
                <time class="text-uppercase">
                    November 04 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>能够用递归和分治解决的，特征都是下一级做的事跟上一级一样（抽象），最后一层做真正的业务。比如n个数字的全排列，抽象出来就是每n-1个数字的全排列</p><p>它的难点就在于抽象，因为等于什么都没描述（我要5个数字的全排列，你就说，那好，你告诉我这4个数字的全排列，我就能告诉你5个数字的全排列）。</p><p>也就是说，尝试用n和n-1的思维（有点像归纳法，动态规划）去描述问题，而不去看能不能解决。</p><p>具体到这里，以ABCD为例，我们的请求过程应该是这样的</p><ul>
<li>A打头的话，BCD的全排列 swap(0, 0)</li>
<li>B打头的话，ACD的全排列 swap(0, 1)</li>
<li>...swap(0,2)</li>
<li>...swap(0,3)</li>
</ul>
<p>自己是可以数出来的：</p><div class="highlight"><pre><span></span>A固定，BCD的所有排列 swap<span class="o">(</span><span class="m">0</span>,0<span class="o">)</span>
  B固定，CD的所有排列 swap<span class="o">(</span><span class="m">1</span>,1<span class="o">)</span>
      C固定，D的所有排列 swap<span class="o">(</span><span class="m">1</span>,2<span class="o">)</span>（1）
      D固定，C的所有排列 swap<span class="o">(</span><span class="m">1</span>,3<span class="o">)</span>（1）
  C固定，同B（2）
  D固定，同B（2）
  计6种
B固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,1<span class="o">)</span>
C固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,2<span class="o">)</span>
D固定，同A，<span class="o">(</span><span class="m">6</span><span class="o">)</span> swap<span class="o">(</span><span class="m">0</span>,3<span class="o">)</span>
结果应该是24
</pre></div>
<p>所有缩进部分都是递归，所以真正的业务代码就是一句话，交换每次比较的数组的第一个和剩下的几个的位置，然后递归下去</p><div class="highlight"><pre><span></span><span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">ctr</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="c1"># 思路是，我每次只动一个数字，然后固定住这个数字，看剩下的数字有多少种排列</span>
            <span class="c1"># 代码里每次把固定的数字挪到开头</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">perm</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ctr</span><span class="p">)</span>
</pre></div>
<p>output: 24</p><p>可能是我理解能力的问题，所有人都没有解释为什么有swap，可能是太直观吧，毕竟swap才是真正在”排列“的业务代码。我还是自己写一遍才想明白，记录一下吧。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/" target="_self">cs193p_2021_笔记_[完结]_pdf下载</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>所有笔记已导出成一篇pdf文档，已上传百度：
链接: <a href="https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g">https://pan.baidu.com/s/1hgnzfxbE9l4zlcYBDsa-1g</a> 提取码: 7w1f</p><hr />
<p>本文内容：与UIKit的集成，以及学习过程中的一些tips，skills，与章节无章的notes</p><hr />
<h1>MVVM</h1>
<figure  style="flex: 89.08045977011494" ><img width="1240" height="696" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/da570de12fc64177b4e88c6429ae285b.png" alt=""/></figure><ul>
<li>viewmodel要起到gete keeper的作用，它就要把model给private起来<ul>
<li>或者private (set), 这样保护了写，但是能读</li>
<li>或者用一个计算属性把需要的model 暴露出去</li>
</ul>
</li>
<li>一个viewmodel通常要conform <code>ObservableObject</code><ul>
<li>就隐含了一个<code>var objectWillChange: ObservableObjectPublisher</code></li>
<li>model要改动前：<code>objectWillChange.send()</code></li>
<li>或者，把model改为<code>@Publisher var model</code>，会自动广播</li>
</ul>
</li>
<li>订阅者（通常就是View）就要把这个viewmodel打个可订阅的标识：<ul>
<li><code>@ObservedObject var viewModel: MyViewModel</code></li>
<li>只能是<code>var</code>，因为很明显是会变的</li>
<li>View监听到是会自动invalicate view的，就会重绘</li>
</ul>
</li>
</ul>
<h1>UIKit Integration</h1>
<p>UIKit并不是纯View的世界，大多数时候是跟ViewController一起出现的，还严重依赖<code>Delegate</code>这种机制进行跨View的事件传递（回调）。</p><h2>Representbles</h2>
<p><code>UIViewRepresentable</code>，<code>UIViewContorllerRepresentable</code>都是SwiftUI的View了，包含几个组件：</p><ol>
<li><code>makeUIView{Controller}(context: Context) -&gt; view/controller</code></li>
<li><code>updateUIView{Controller}(view/controller, context: Context) -&gt;</code></li>
<li><code>makeCoordiinator() -&gt; Coordinator</code> // handle delegate<ul>
<li>调用该方法后, <code>context.coordinator</code>就有值了</li>
</ul>
</li>
<li>a <code>Context</code> containn the coordinator, swiftui's env, animation transaction</li>
<li><code>dismantleUIView{Controller}(view/controller, coordinator: Coordinator)</code> // clean up when disappears</li>
</ol>
<h1>Tips &amp; Skills</h1>
<p>学习过程随笔记下来的一些技巧和知识点:</p><h2>basic</h2>
<ul>
<li>[0...6]是0到6，[0..&lt;6]是0到5</li>
<li>var s = struct_a; s[&quot;a&quot;] = 3, 不会改变struct_a, 因为struct永远是复制</li>
<li><code>arr.firstIndex(where: { item in item.id == myID})</code>，因为where需要的函数传递的是本身（类似map, filter)，所以可以简化为：<ul>
<li><code>arr.firstIndex(where: { $0.id == myID})</code></li>
</ul>
</li>
<li><code>typealias Card = MemoryGame&lt;String&gt;.Card</code> 别名</li>
<li><code>var a_int_array = [Int]()</code> 一种初始化方式</li>
<li>extension中的属性可以直接用，（当然也可以用<code>self.</code>）</li>
<li><code>arr.filter { isGood($0)}</code> 因为参数就是自己，还可以继续简化： `arr.filter(isGood)``<ul>
<li>同理：<code>[1...100].reduce(0, +)</code>，因为默认参数是两个，所以会自动填到+号两边，展开就是<code>{ $0 + $1 }</code></li>
</ul>
</li>
<li><code>Collection</code> protocol is for <em>immutable</em> collections<ul>
<li>mutalbe Collection protocol is <code>RangeReplaceableCollection</code></li>
<li>所以要写一个扩展，在改变集合的元素，先选对正确的protocol</li>
</ul>
</li>
<li>用<code>try</code>还是<code>try?</code>调用一个声明了<code>throw</code>的函数，取决于你是要忽略它还是处理它<ul>
<li><code>try</code>就是不处理，结果就是包含了这段代码的函数也要标上<code>throw</code></li>
<li><code>try?</code>就是忽略掉，承认<code>nil</code></li>
</ul>
</li>
<li><code>String(describing: obj)</code>: 对象的字符串表示，或字符串描述</li>
<li><code>#function</code> 程序名</li>
<li><code>@ScaleMetric var fontSize: CGFloat = 40.0</code> 固定大小的字体，用<code>@ScaleMetric</code>也能按比例缩放</li>
<li>剪贴板：<code>UIPasteboard.general.image?.jpegData(...)</code></li>
<li>safe area: <code>UIAplication.shared.windows.first?.safeAreaInsets</code></li>
<li><code>views.map{ UIHostingController(rootView: $0)}</code> 把一组View转为ViewController</li>
<li><code>timer = Timer.publish(erery: 3, on: .current, in: .common).autoconnect()</code><ul>
<li>view<code>.onReceive(timer, perform: {})</code></li>
</ul>
</li>
<li><code>Texxt(Image(systemName: &quot;video.circle&quot;)) + Text(&quot;视频&quot;)</code>: 两个知识点<ul>
<li>Text view重载了<code>+</code>操作符，省去了用<code>HStack</code></li>
<li>Image也可以作为Text的内容</li>
</ul>
</li>
<li><code>Circle + trim + stroke + rotation</code> 可以组合出一段任意角度的弧形</li>
<li>一个<code>PreferenceKey</code>用来广播属性变化的例子：</li>
</ul>
<figure class="vertical-figure" style="flex: 38.9937106918239" ><img width="1240" height="1590" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e660e659aadcd624c62b1b9102d015d5.png" alt=""/></figure>
<pre><code>* see more [https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/](https://swiftwithmajid.com/2020/01/15/the-magic-of-view-preferences-in-swiftui/)
</code></pre>
<p>看一个简化的实例：
<figure class="vertical-figure" style="flex: 43.13868613138686" ><img width="1182" height="1370" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/01b4f14b413613c6bd36ad5b2288df9d.png" alt=""/></figure>
可以看到，其实化简化可读性更强，用for循环，再在里面做逻辑，会把直白的初衷绕进去：</p><ul>
<li><p>返回唯一一个面朝上的卡片</p></li>
<li><p>设置选定索引的卡片面朝上</p></li>
<li><p>同样， <code>Button</code>的声明是：<code>(_ title: StringProtocol, action: () -&gt; Void)</code>,</p><ul>
<li>简化后也更加直观了：<code>Button(&quot;text&quot;){ actions }</code></li>
</ul>
</li>
<li><p>给class/struct添加和使用默认的<code>description</code>有点绕，等于原生并不支持，还理解成了<code>String</code>的方法</p></li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">abc</span><span class="p">:</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">a</span><span class="p">:</span><span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">b</span><span class="p">:</span><span class="nb">Int</span>
    <span class="kd">func</span> <span class="nf">de</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span><span class="p">{</span>
        <span class="c1">// #function, file, filePaht, fileID, line, column</span>
        <span class="s">&quot;</span><span class="si">\(</span><span class="nb">String</span><span class="si">(</span><span class="n">describing</span><span class="p">:</span> <span class="kc">self</span><span class="si">))</span><span class="se">\n</span><span class="si">\(</span><span class="kc">#function</span><span class="si">)</span><span class="se">\n</span><span class="si">\(</span><span class="p">#</span><span class="n">filePath</span><span class="si">)</span><span class="s">&quot;</span>

        <span class="c1">// String(describing: obj)</span>
        <span class="c1">// 理解为用obj对象的description属性来构造字符串</span>
        <span class="c1">// 而一般人的设计思路会是：给obj对象增加一个description属性，这个属性是个string</span>
        <span class="c1">// 并且这个对象要服务 CustomStringConvertible 协议</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">:</span><span class="si">\(</span><span class="n">a</span><span class="si">)</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">b</span><span class="se">\&quot;</span><span class="s">:</span><span class="si">\(</span><span class="n">b</span><span class="si">)</span><span class="s">}&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">abc</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">88</span><span class="p">).</span><span class="n">de</span><span class="p">()</span> <span class="c1">// 输出： {&quot;a&quot;: 77, &quot;b&quot;: 88} \n de() \n myfile_path</span>
</pre></div>
<h2>view</h2>
<ul>
<li><code>var body : some View {...}</code> 意思是你自己不需要实现View，但你要返回some实现了View的（别的）对象<ul>
<li>它是一个computed var，所以跟的{}就是一个function</li>
<li>所以{}里隐含了一个return</li>
</ul>
</li>
<li><code>Text(&quot;hello&quot;).padding()</code>返回的不再是Text</li>
<li><code>ZStack(alignment: .center, content: {...})</code><ul>
<li>简化为：<code>ZStack(alignment: .center) {...}</code>，提取了方法体</li>
<li>如果<code>alignment</code>为空： <code>ZStack {...}</code></li>
<li>所以它里面也可以有局部变量</li>
</ul>
</li>
<li>多个函数参数也可以简化：<ul>
<li><code>Button(action: {...}, label: {...})</code></li>
<li><code>Button {...} label: {...}</code>省掉了第一个参数名，省掉了逗号</li>
</ul>
</li>
<li><code>Button.contextMenu{ some View}</code> 上下文菜单，内容就是some View</li>
<li><code>Menu{ some View} label: { Label }</code> 呈现为一个button，点击后会自动呈现some View组成的菜单<ul>
<li>也就是说它自己帮你封装了UI和行为（点击弹出菜单），不需要写什么<code>onTap</code>事件</li>
</ul>
</li>
<li><code>myView.sheet(isPresented: $flag) { some View}</code> 通过<code>$flag</code>就能根据<code>myView</code>的位置在合适的位置打开sheet，内容由@viewBuilder的closure提供</li>
<li><code>popover</code>也同理，还有一种popover时把对象传进去的用法：<ul>
<li><code>popover</code>与<code>sheet</code>的区别是<code>popover</code>在计算自身大小的时候是“尽可能小”，所以在包的对象里对好自己size一下</li>
</ul>
</li>
<li>alert有点不同：<code>.alert(item: $flag) { alertToShow in return Alert}</code>， 就是要返回一个<code>Alert</code>对象</li>
<li><code>myView.popover(item: $obj) {obj in ...}</code> 这一类传item做flag的用法也有广泛的使用场景</li>
<li>弹出的页面查看自己的状态，用<code>presentationMode</code>环境变量<ul>
<li><code>presentationMode.wrappedValue.isPresented</code></li>
</ul>
</li>
<li><code>NavigationView</code>里的<code>NavigationLink</code>也是一样封装了UI和行为（点击跳转）</li>
<li>toolbaritem的placement除了leading, trailing等直观表示，还有一些语义对应的(类似alert中有红色的销毁按钮），如<code>destructiveAction, cancellationAction, confirmationAction</code>等，甚至<code>automaic</code></li>
<li>工具条放到底部：ToolbarItemGroup(placement: .bottmbar){}`</li>
<li><code>.StackNavigationViewStyle</code>, 让大屏幕iPhone横屏时不去尝试左右分屏，直接铺满</li>
<li><code>UIDevice.current.userInterfaceIdiom == .pad</code></li>
<li>环境变量：<code>horizontalSizeClass</code>, <code>verticalSizeClass</code>等，根据是否compact来判断布局，而不是写死的大小，以实现跨机型适配</li>
</ul>
<h2>layout</h2>
<ul>
<li><code>lazyVGrid(columns: [GridItem(.fixed(200)), GridItem(.flexable()), GridItem())])</code><ul>
<li>其实就是一个flex的排版</li>
<li>横向利用所有空间，竖向尽可能小</li>
<li>竖排，没定义，看效果是top</li>
<li>横排，由每一个GridItem来定义</li>
<li><code>Lazy</code>的意思是只有出现在屏幕上时，才会渲染<code>body</code></li>
<li>如果横向元素也自由排列呢？比如横屏15个，竖屏6个<ul>
<li><code>lazyVGrid(columns: GridItem(.adaptive(minimum: 80)))</code> 只要一个item, 然后指定一个最小宽度即可</li>
</ul>
</li>
<li>同理应该有lazyHGrid</li>
</ul>
</li>
</ul>
<h2>static</h2>
<ul>
<li>.largeTitle, .white, 其实就是静态变量: <code>Font.largeTitle</code>, <code>Color.white</code>，所以不要觉得代码里用<code>static let xxx = xxx</code>很low<ul>
<li>静态方法同理，只要不需要是实例变量的，都可以staic起来，跳出初始化流程</li>
</ul>
</li>
</ul>
<h2>XCode</h2>
<ul>
<li>设置 &gt; Behaviors &gt; Generates output 可以设置模拟器有output时的行为，比如拉出控制台看输出</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// 设置预览的设备</span>
    <span class="p">.</span><span class="n">previewDevice</span><span class="p">(</span><span class="n">PreviewDevice</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="s">&quot;iPhone 12&quot;</span><span class="p">))</span>
    <span class="p">.</span><span class="n">previewDisplayName</span><span class="p">(</span><span class="s">&quot;iPhone 12&quot;</span><span class="p">)</span>
</pre></div>
<ul>
<li>preview里面你做两个<code>.preferredColorScheme(.dark/.light)</code>就可以同时预览两种颜色模式下的效果了</li>
<li>其实以上在右侧面板设置会更简单，一样会在Preview里生成相应（跟手写一模一样）的代码</li>
</ul>
<p>...</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0_%5B%E5%AE%8C%E7%BB%93%5D_pdf%E4%B8%8B%E8%BD%BD/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/" target="_self">cs193p_2021笔记[7]_Document-Architecture</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Document Architecture</h1>
<p>所谓的Dopcument Architecture，其实就是支持把用app产生的作品保存起来，比如你创作的一幅图片，可以保存为<code>.jpg</code>，你用photoshop做的文件是<code>.psd</code>，下次用自己的app加载这个文件，能认出所有组件和模型，比如我们想为document取个名字叫<code>.emojiart</code>。</p><h2>App Architecture</h2>
<h3>App protocol</h3>
<ul>
<li>一个app里只能有一个struct服从<code>App Protocol</code></li>
<li>mark it with <code>@main</code></li>
<li>it's <code>var body</code> is <code>some Scene</code></li>
</ul>
<h3>Scene protocol</h3>
<ul>
<li>A <code>Scene</code> is a container fo a <code>top-lever</code> View that you want to show in your UI</li>
<li><code>@Environment(\.scenePhase)</code></li>
<li>three main types of Scenes:</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">WindowGroup</span> <span class="p">{</span><span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>
<span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:)</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span> <span class="p">...</span> <span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>
<span class="n">DocumentGroup</span><span class="p">(</span><span class="n">viewing</span><span class="p">:</span> <span class="n">viewer</span><span class="p">:)</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span> <span class="p">...</span> <span class="k">return</span> <span class="n">aTopLevelView</span><span class="p">}</span>  <span class="c1">// 只读</span>
</pre></div>
<ul>
<li>后两个类似view里面的<code>ForEach</code>但不完全相同：<ul>
<li>而是：&quot;<strong>new window</strong>&quot; on Mac, &quot;<strong>splitting the screen</strong>&quot; on iPad -&gt; for create new Scene</li>
</ul>
</li>
<li><code>content</code>参数是一个返回some View的方法<ul>
<li>返回的是top-level view</li>
<li>每当新建一个窗口或窗口被分割时都会被调用</li>
</ul>
</li>
</ul>
<p>当你在iPad上分屏，且两个打开同一应用，就是<code>WindowGroup</code>在管理，为每一个windows生成一个Scene(share the same parameter e.g. view model, 因为代码是同一份，除非额外为每个scene设置自己的viewmodel之类的).</p><p><code>config</code>里保存了document(即viewModel)，也保存了文件位置。</p><h3>SceneStorage</h3>
<ul>
<li>能持久化数据</li>
<li>以窗口/分屏为单位 -&gt; per-Scene basis</li>
<li>也会invalidate view</li>
<li>数据类型有严格限制，最通用的是<code>RawRepresentable</code></li>
</ul>
<p>[图片上传失败...(image-66d359-1636448439942)]</p><p>一个View里的<code>@State</code>改为<code>@SceneStorage(uniq_id)</code>后，app退出或crash了，仍然能找回原来的值。</p><p>这个时候每个Scene里的值就已经不一样了。</p><h3>AppStorage</h3>
<ul>
<li>application-wide basis</li>
<li>存在UserDefaults里</li>
<li>服从<code>@SceneStorage</code>的数据才能被存储</li>
<li>invalidate view</li>
</ul>
<h2>DocumentGroup</h2>
<p><code>DocumentGroup</code> is the document-oriented Scene-building Scene.</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">main</span>
<span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">StateObject</span> <span class="kd">var</span> <span class="nv">paletteStore</span> <span class="p">=</span> <span class="n">PaletteStore</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&quot;Default&quot;</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">WindowGroup</span> <span class="p">{</span>
            <span class="n">MyDemoView</span><span class="p">()</span>
            <span class="p">.</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">paletteStore</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V.S.</span>

<span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span><span class="n">myDocument</span><span class="p">()})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
            <span class="n">MyDemoView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="n">document</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>不再用<code>@StateObject</code>传递ViewModel，每新建一个Document都会有一个独立的ViewModel<ul>
<li>必须要服从<code>ReferenceFileDocument</code>(这样能存到文件系统以及从文件系统读取了)</li>
<li><code>config</code>参数包含了这个ViewModel（就是document)，以及document的url</li>
<li>很好理解，每一个document肯定有自己的数据（想象一个“最近打开”的功能，每一个文档都是独立的）</li>
</ul>
</li>
<li><code>newDocument</code>里自行提供一个新建document的方法</li>
<li>封装了关联的（选择document的）UI和行为</li>
<li>you <strong>MUST</strong> implement <code>Undo</code> in your application</li>
</ul>
<p>如果不去实现<code>Undo</code>，也可以直接把model存到document文件里：</p><ol>
<li>你的ViewModel要能init itself from a <code>Binding&lt;Type&gt;</code><ul>
<li>如<code>config.$document</code></li>
</ul>
</li>
<li>ViewModel由一个<code>ObservedObject</code>变成一个<code>StateObject</code><ul>
<li>这次必须服从<code>FileDocument</code></li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">MyDemoApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
        <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span><span class="n">myDocument</span><span class="p">()})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
            <span class="c1">// MyDemoView(document: config.document) // 之前的</span>
            <span class="n">MyDemoView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="err">$</span><span class="n">document</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>把<code>newDocument: {myDocument()}</code>改为<code>viewer: myDocument.self</code>，就成了一个只读的model，（你甚至不需要传入实例），如果你要开发的是一个查看别人文档的应用，这个特性就比较有用了。</p><h3>FileDocument protocol</h3>
<p>This protocol gets/puts the contents of a document from/to a file. 即提供你的document读到文件系统的能力。</p><div class="highlight"><pre><span></span><span class="c1">// create from a file</span>
<span class="kd">init</span><span class="p">(</span><span class="n">configuration</span><span class="p">:</span> <span class="n">ReadConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">configuration</span><span class="p">.</span><span class="n">file</span><span class="p">.</span><span class="n">regularFileContents</span> <span class="p">{</span>
        <span class="c1">// init yourself from data</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">CocoaError</span><span class="p">(.</span><span class="n">fileReadCorruptFile</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// write</span>
<span class="kd">func</span> <span class="nf">fileWrapper</span><span class="p">(</span><span class="n">configuration</span><span class="p">:</span> <span class="n">WriteConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">FileWrapper</span> <span class="p">{</span>
    <span class="n">FileWrapper</span><span class="p">(</span><span class="n">regularFileWithContents</span><span class="p">:</span> <span class="cm">/*my data*/</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3>ReferenceFileDocument</h3>
<ul>
<li>几乎和<code>FileDocument</code>一致</li>
<li>继承自<code>ObservableObject</code> -&gt; ViewModel only</li>
<li>唯一的区别是通过后台线程的一个<code>snapshot</code>来写入</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// 先snapshot</span>
<span class="kd">func</span> <span class="nf">snapshot</span><span class="p">(</span><span class="n">contentType</span><span class="p">:</span> <span class="bp">UTType</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Snapshot</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// my data or something</span>
<span class="p">}</span>
<span class="c1">// then write</span>
<span class="kd">func</span> <span class="nf">fileWrapper</span><span class="p">(</span><span class="n">snapshot</span><span class="p">:</span> <span class="n">Snapshot</span><span class="p">,</span> <span class="n">configuration</span><span class="p">:</span> <span class="n">WriteConfiguration</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">FileWrapper</span> <span class="p">{</span>
    <span class="n">FileWrapper</span><span class="p">(</span><span class="n">regularFileWithContents</span><span class="p">:</span> <span class="cm">/* snapshpt converted to a Data */</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>流程大概是，你的model有变化之后，会先找<code>snapshot</code>方法创建一份镜像，然后再要求你给出一个<code>fileWrapper</code>来写文件。</p><h3>自定义文件类型</h3>
<p>声明能打开什么类型的文件，通过：UTType(<code>Uniform Type Identifier</code>)</p><p>可以理解为怎么定义并注册（关联）自己的扩展名，就像photoshop关联.psd一样。</p><ol>
<li>声明(Info tab)，设置<code>Exported/Imported Type Identifier</code>，所以表面上的扩展名，内里还对应了一个唯一的标识符，一般用反域名的格式</li>
</ol>
<figure  style="flex: 322.98850574712645" ><img width="1124" height="174" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6b64ff3f0d28f9e054f79ae65e4eada0.png" alt=""/></figure><ol start="2">
<li>声明拥有权，用的就是上一步标识符，而不是扩展名</li>
</ol>
<figure  style="flex: 400.0" ><img width="1136" height="142" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/86264dc076782270e53b2ea22b2eb60f.png" alt=""/></figure><ol start="3">
<li>告知系统能在<code>Files</code> app里打开这种文档<ul>
<li>info.plist &gt; Supports Document Browser &gt; YES</li>
</ul>
</li>
<li>代码里添加枚举：</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="bp">UTType</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">emojiart</span> <span class="p">=</span> <span class="bp">UTType</span><span class="p">(</span><span class="n">exportedAs</span><span class="p">:</span> <span class="s">&quot;edu.bla.bla.emojimart&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">static</span> <span class="kd">let</span> <span class="nv">readableContentTypes</span> <span class="p">=</span> <span class="p">[</span><span class="bp">UTType</span><span class="p">.</span><span class="n">emojiart</span><span class="p">]</span>
</pre></div>
<h2>Undo</h2>
<ul>
<li>use <code>ReferenceFileDocument</code> must implement Undo</li>
<li>这也是SwiftUI能自动保存的时间节点</li>
<li>by <code>UndoManager</code> -&gt; <code>@Environment(\.undoManager) var undoManager</code></li>
<li>and by register an <code>Undo</code> for it: <code>func registerUndo(withTarget: self, howToUndo: (target) -&gt; Void)</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">undoablePerform</span><span class="p">(</span><span class="n">operation</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">with</span> <span class="n">undoManager</span><span class="p">:</span> <span class="n">UndoManager</span><span class="p">?,</span> <span class="n">doit</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nv">oldModel</span> <span class="p">=</span> <span class="n">model</span>
    <span class="n">doit</span><span class="p">()</span>
    <span class="n">undoManager</span><span class="p">?.</span><span class="n">registerUndo</span><span class="p">(</span><span class="n">withTarget</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">myself</span> <span class="k">in</span>
        <span class="n">myself</span><span class="p">.</span><span class="n">model</span> <span class="p">=</span> <span class="n">model</span>
    <span class="p">}</span>
    <span class="n">undoManager</span><span class="p">?.</span><span class="n">setActionName</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span> <span class="c1">// 给操作一个名字，如&quot;undo paste&quot;， 非必需</span>
<span class="p">}</span>
</pre></div>
<p>用`undoablyPerform(with:){} 包住的任何改变model的操作就都支持了undo</p><h2>Review</h2>
<p>回顾一下，我们把应用改造为<code>Document Architechture</code>的步骤：</p><ol>
<li>应用入口，将<code>WindowGroup</code>改为了<code>DocumentGroup</code>，并修改了相应的传递document的方式</li>
<li>实现document(即view model) comform to <code>ReferenceFileDocument</code><ul>
<li>实现snapshot, write to file (<code>FileWrapper</code>), and read from file</li>
</ul>
</li>
<li>自定义一个文件类别（扩展名，标识符，声明拥有者等）</li>
<li>此时启动应用，入口UI已经是文档选择界面了，所以我说它封装了UI和行为<ul>
<li>但此时不具备保存的功能，需要进一步实现<code>Undo</code>'</li>
</ul>
</li>
<li>通过<code>undoManager</code>把改动model的行为都包进去实现undo/redo<ul>
<li>此时document已能自动保存</li>
</ul>
</li>
<li>增加toolbar, 实现手动undo/redo</li>
<li>顺便注册文档类型，以便在Files应用内能用本app打开<ul>
<li><code>Info.plist</code> &gt; <code>Supports Document Browser</code> &gt; YES</li>
</ul>
</li>
</ol>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B7%5D_Document-Architecture/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/3/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 AlanDecode</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>