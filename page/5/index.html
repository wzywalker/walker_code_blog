<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/628197911571ef8eb878ea16c97a021b.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="AlanDecode" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/5/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/iOS-App-%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86/" target="_self">iOS-App-签名的原理</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/iOS-App-%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86/" target="_self">
                <time class="text-uppercase">
                    November 23 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>原文转载: <a href="https://wereadteam.github.io/2017/03/13/Signature/"><a href="https://wereadteam.github.io/2017/03/13/Signature/">https://wereadteam.github.io/2017/03/13/Signature/</a></a></p><p>iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E7%9B%AE%E7%9A%84">https://wereadteam.github.io/2017/03/13/Signature/#%E7%9B%AE%E7%9A%84</a>目的
先来看看苹果的签名机制是为了做什么。在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">https://wereadteam.github.io/2017/03/13/Signature/#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86</a>非对称加密
通常我们说的签名就是数字签名，它是基于非对称加密算法实现的。对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。
简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的：
选两个质数 p
 和 q
，相乘得出一个大整数n
，例如 p=61，q=53，n=pq=3233
选 1-n 间的随便一个质数 e
，例如 e = 17
经过一系列数学公式，算出一个数字 d
，满足：a. 通过 n
 和 e
 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。b. 如果只知道 n
 和 e
，要推导出 d
，需要知道 p
 和 q
，也就是要需要把 n 因数分解。</p><p>上述的 (n,e)
 这两个数据在一起就是公钥，(n,d)
 这两个数据就是私钥，满足用公钥加密，私钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥（只知道 n
 和 e）的情况下，要推导出私钥 (n,d)
，需要把大整数 n
 因数分解。目前因数分解只能靠暴力穷举，而n数字越大，越难以用穷举计算出因数 p
 和 q
，也就越安全，当 n
 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。
若对数字 d
 是怎样计算出来的感兴趣，可以详读这两篇文章：RSA 算法原理<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">（一）</a><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">（二）</a>
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">https://wereadteam.github.io/2017/03/13/Signature/#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D</a>数字签名
现在知道了有非对称加密这东西，那数字签名是怎么回事呢？
数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。
有了上述非对称加密算法，就可以实现这个需求：
<a href="https://wereadteam.github.io/img/sign0.png"><figure  style="flex: 64.47963800904978" ><img width="855" height="663" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/234925bff10aed3dd8bbfcc719a6ed52.png" alt=""/></figure></a>
首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。
生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。
对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。
用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。</p><p>之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位/ 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。
好了，有了非对称加密的基础，知道了数字签名是什么，怎样可以保证一份数据是经过某个地方认证的，来看看怎样通过数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果认证允许的。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%BE%E5%90%8D">https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%BE%E5%90%8D</a>最简单的签名
要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。
<a href="https://wereadteam.github.io/img/sign1.png"><figure  style="flex: 98.60406091370558" ><img width="777" height="394" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/b8742d54a8daf092eae0fd59ae4b8b9f.png" alt=""/></figure></a>
如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。
但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：
开发 App 时可以直接把开发中的应用安装进手机进行调试。
In-House 企业内部分发，可以直接安装企业证书签名后的 APP。
AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。</p><p>苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%96%B0%E7%9A%84%E9%9C%80%E6%B1%82">https://wereadteam.github.io/2017/03/13/Signature/#%E6%96%B0%E7%9A%84%E9%9C%80%E6%B1%82</a>新的需求
我们先来看第一个，开发时安装APP，它有两个个需求：
安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。
苹果必须对这里的安装有控制权，包括a.经过苹果允许才可以这样安装。b.不能被滥用导致非开发app也能被安装。</p><p>为了实现这些需求，iOS 签名的复杂度也就开始增加了。
苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：
<a href="https://wereadteam.github.io/img/sign2.png"><figure  style="flex: 100.48622366288492" ><img width="1240" height="617" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/55b89ed1e2050a5894ae5c7f1fb704bd.png" alt=""/></figure></a>
在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local
苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple
把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。
在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。
在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。
验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）</p><p><a href="https://wereadteam.github.io/2017/03/13/Signature/#%E5%8A%A0%E7%82%B9%E4%B8%9C%E8%A5%BF">https://wereadteam.github.io/2017/03/13/Signature/#%E5%8A%A0%E7%82%B9%E4%B8%9C%E8%A5%BF</a>加点东西
上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。
怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。
<a href="https://wereadteam.github.io/img/sign3.png"><figure  style="flex: 88.69814020028612" ><img width="1240" height="699" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/244a2c4cc4ff1bf3d4193b222dfe4648.png" alt=""/></figure></a>
可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%80%E7%BB%88%E6%B5%81%E7%A8%8B">https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%80%E7%BB%88%E6%B5%81%E7%A8%8B</a>最终流程
到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。
实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。
所以整个流程稍微变一下，就变成这样了：
<a href="https://wereadteam.github.io/img/sign4.png"><figure  style="flex: 74.25149700598803" ><img width="1240" height="835" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/09c33bcd536897bd2ae93cef8900d748.png" alt=""/></figure></a>
因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：
在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local
苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple
把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。
在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。
在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision
，把 APP 安装到手机上。
在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision
 的数字签名是否正确，里面的证书签名也会再验一遍。
确保了 embedded.mobileprovision
 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。</p><p>开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C">https://wereadteam.github.io/2017/03/13/Signature/#%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C</a>概念和操作
上面的步骤对应到我们平常具体的操作和概念是这样的：
第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 CertificateSigningRequest
 就是公钥，私钥保存在本地电脑里。
第 2 步苹果处理，不用管。
第 3 步对应把 CertificateSigningRequest
 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12
 文件，其他 Mac 打开后就导入了这个私钥。
第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。
第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision
 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature
 目录下。</p><p>第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。
这里再总结一下这些概念：
<strong>证书</strong>：内容是公钥或私钥，由其他机构对其签名组成的数据包。
<strong>Entitlements</strong>：包含了 App 权限开关列表。
<strong>CertificateSigningRequest</strong>：本地公钥。
<strong>p12</strong>：本地私钥，可以导入到其他电脑。
<strong>Provisioning Profile</strong>：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</p><p><a href="https://wereadteam.github.io/2017/03/13/Signature/#%E5%85%B6%E4%BB%96%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F">https://wereadteam.github.io/2017/03/13/Signature/#%E5%85%B6%E4%BB%96%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F</a>其他发布方式
前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。
而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision
 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。
据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision
 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。
那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。
所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。
到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#P-S-%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE">https://wereadteam.github.io/2017/03/13/Signature/#P-S-%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE</a>P.S.一些疑问
最后这里再提一下我关于签名流程的一些的疑问。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E4%BC%81%E4%B8%9A%E8%AF%81%E4%B9%A6">https://wereadteam.github.io/2017/03/13/Signature/#%E4%BC%81%E4%B8%9A%E8%AF%81%E4%B9%A6</a>企业证书
企业证书签名因为限制少，在国内被广泛用于测试和盗版，fir.im / 蒲公英等测试平台都是通过企业证书分发，国内一些市场像 PP 助手，爱思助手，一部分安装手段也是通过企业证书重签名。通过企业证书签名安装的 App，启动时都会验证证书的有效期，并且不定期请求苹果服务器看证书是否被吊销，若已过期或被吊销，就会无法启动 App。对于这种助手的盗版安装手段，苹果想打击只能一个个吊销企业证书，并没有太好的办法。
这里我的疑问是，苹果做了那么多签名和验证机制去限制在 iOS 安装 App，为什么又要出这样一个限制很少的方式让盗版钻空子呢？若真的是企业用途不适合上 AppStore，也完全可以在 AppStore 开辟一个小的私密版块，还是通过 AppStore 去安装，就不会有这个问题了。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#AppStore-%E5%8A%A0%E5%AF%86">https://wereadteam.github.io/2017/03/13/Signature/#AppStore-%E5%8A%A0%E5%AF%86</a>AppStore 加密
另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。
<a href="https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%AC%E5%9C%B0%E7%A7%81%E9%92%A5">https://wereadteam.github.io/2017/03/13/Signature/#%E6%9C%AC%E5%9C%B0%E7%A7%81%E9%92%A5</a>本地私钥
我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest
 和 p12
 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？
能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/iOS-App-%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/shell%E5%91%BD%E4%BB%A4%E7%94%A8%E6%AD%A3%E5%88%99%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/" target="_self">shell命令用正则批量重命名文件</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/shell%E5%91%BD%E4%BB%A4%E7%94%A8%E6%AD%A3%E5%88%99%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/" target="_self">
                <time class="text-uppercase">
                    November 14 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>又是用shell来操作文件的问题.</p><p>我下了老友记的全集, 结果在NAS里死活匹配不出3季以后的剧集信息, 因为打包来源相同, 一直没深究, 只当是刮削工具做得不好, 今天才发现从第4季开始, 所有的文件名格式都错了, 如:</p><div class="highlight"><pre><span></span><span class="n">Friends</span><span class="p">.</span><span class="n">s10</span><span class="p">.</span><span class="mf">06.2003</span><span class="p">.</span><span class="n">BDRip</span><span class="p">.</span><span class="mi">1080</span><span class="n">p</span><span class="p">.</span><span class="n">Ukr</span><span class="p">.</span><span class="n">Eng</span><span class="p">.</span><span class="n">AC3</span><span class="p">.</span><span class="n">Hurtom</span><span class="p">.</span><span class="n">TNU</span><span class="p">.</span><span class="n">Tenax555</span><span class="p">.</span><span class="n">mkv</span>
</pre></div>
<p>中的<code>s10.06</code>应为<code>s10.e06</code>, 那么改对不就是了么. 又是批量任务啊, 这次的需求从上次的批量移动文件变成了批量修改文件名.</p><p>事实上<code>mv</code>其实也是重命名工具, 奈何这次的规则稍微复杂, 我还是想要用正则来匹配, 一番搜索, 找到了<code>rename</code>这个工具. 网上的相关文章似乎有点旧, 跟今天我Homebrew下来的的文档有出入, 因此也就没看网上的文档了, 建议自己看一下官方文档, 还自带了<code>tutorial</code>和<code>cookbook</code>, 很良心啊, 看完基本自己就会了.</p><p>新版的<code>rename</code>工具把选项分为了<code>switch</code>和<code>transforms</code>, 自然文档也就成了:</p>
<pre><code>rename [switches|transforms] [files]
</code></pre>
<p>既然都推荐你们看文档了, 我了不一一介绍了, 挑几个需要注意的讲, 最后再揭晓我是如何完成这次批量重命名的.</p><p>##debug
<code>-n</code>这个<code>switch</code>可以显示本次命令将被如何执行, 而不真正执行, 这非常像上一篇文章里介绍<code>xargs</code>时的<code>-p</code>, 在<code>rename</code>的语境里, 它叫<code>dry-run</code>. 总之我就是通过这个学习的, 非常有用.</p><p>##替换
新版<code>rename</code>加了很多像去头啊, 去尾啊, 加前缀啊, 加尾缀啊, 去空白啊, 变大小写啊等等的选项, 这个去读文档, 执行一些简单且明确的任务用这些<code>switch</code>和<code>transforms</code>比自己去构建正则要来的简单, 这也是作者把这些小功能全提取出来的目的吧. 由于我的目标是正则, 着重关注<code>-s</code>这个<code>transform</code>.</p><p>假设有文件<code>abc123.mp3</code>和<code>abc456.mp3</code>, 以下命令均加了<code>-n</code>, 以便直接看输出</p><div class="highlight"><pre><span></span><span class="c1">#替换</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span><span class="n">s</span> <span class="n">abc</span> <span class="n">mmm</span> <span class="o">*</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="s1">&#39;s/abc/mmm/&#39;</span> <span class="o">*</span>
<span class="c1">#以上两句只是展示两种写法/格式</span>
<span class="c1">#输出:</span>
<span class="s1">&#39;abc123.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;mmm123.mp3&#39;</span>
<span class="s1">&#39;abc456.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;mmm456.mp3&#39;</span>

<span class="c1">#加前缀</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="s1">&#39;s/^/album_/&#39;</span> <span class="o">*.</span><span class="n">mp3</span>
<span class="c1">#输出:</span>
<span class="s1">&#39;abc123.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;album_abc123.mp3&#39;</span>
<span class="s1">&#39;abc456.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;album_abc456.mp3&#39;</span>

<span class="c1">#演示一次错误的加前缀方式</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="s1">&#39;s/^/album_^/&#39;</span> <span class="o">*.</span><span class="n">mp3</span>
<span class="c1">#输出:</span>
<span class="s1">&#39;abc123.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;album_^abc123.mp3&#39;</span>
<span class="s1">&#39;abc456.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;album_^abc456.mp3&#39;</span>
<span class="c1">#看到了吧? 直接把^给替换了, 而不是插入</span>

<span class="c1">#去后缀</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="s1">&#39;s/\.mp3//&#39;</span> <span class="o">*.</span><span class="n">mp3</span>
<span class="c1">#输出:</span>
<span class="s1">&#39;abc123.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;abc123&#39;</span>
<span class="s1">&#39;abc456.mp3&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;abc456&#39;</span>

<span class="c1">#分组</span>
<span class="err">$</span><span class="n">touch</span> <span class="n">AA</span><span class="o">.</span><span class="n">S01</span><span class="mf">.12</span><span class="o">.</span><span class="n">mkv</span> <span class="n">AA</span><span class="o">.</span><span class="n">S01</span><span class="mf">.13</span><span class="o">.</span><span class="n">mkv</span> <span class="n">AA</span><span class="o">.</span><span class="n">S01</span><span class="mf">.14</span><span class="o">.</span><span class="n">mkv</span>
<span class="c1">#这次把文件搞复杂点, 假定有如上三个文件, 我们要把12改为E12, 以此类推</span>
<span class="err">$</span><span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="s1">&#39;s/\.(\d</span><span class="si">{2}</span><span class="s1">)\./\.E$1\./&#39;</span> <span class="o">*.</span><span class="n">mkv</span>
<span class="c1">#输出:</span>
<span class="s1">&#39;AA.S01.12.mkv&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;AA.S01.E12.mkv&#39;</span>
<span class="s1">&#39;AA.S01.13.mkv&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;AA.S01.E13.mkv&#39;</span>
<span class="s1">&#39;AA.S01.14.mkv&#39;</span> <span class="n">would</span> <span class="n">be</span> <span class="n">renamed</span> <span class="n">to</span> <span class="s1">&#39;AA.S01.E14.mkv&#39;</span>
</pre></div>
<p>看到最后一个例子是不是发现我的目标已经达到了? 我没有深入研究, 只是简单的根据实际情况把前后带点符号, 中间夹了两位数字的提取了出来, 加了字母<code>E</code>, 可能还有更简便的办法, 但我看到输出, 就急急测试去了, 果然等待数秒后, 文件全部重命名成功.</p><p>##递归
当然没那么简单, 因为4-10季的内容在各自的文件夹里, 如何递归呢? 看过我<a href="https://www.jianshu.com/p/6fab4aedc07e">上一篇文章</a>的人可能会想到我又去借管道和<code>xargs</code>了吧? 这次得益于我提前读了文档, 里面也有介绍, 它还能直接应用<code>find</code>过来的结果, 还不需要像<code>xargs</code>一样给个占位, 应该是作者直接做的支持, 所以我的最终命令是这样的:</p><div class="highlight"><pre><span></span><span class="err">$</span><span class="bp">find</span> <span class="p">.</span> <span class="o">-</span><span class="n">name</span> <span class="s">&quot;*.mkv&quot;</span> <span class="o">-</span><span class="n">print0</span> <span class="o">|</span> <span class="n">rename</span> <span class="o">-</span><span class="n">n</span> <span class="err">&#39;</span><span class="n">s</span><span class="o">/</span><span class="err">\</span><span class="p">.(</span><span class="err">\</span><span class="n">d</span><span class="p">{</span><span class="mi">2</span><span class="p">})</span><span class="err">\</span><span class="p">.</span><span class="o">/</span><span class="err">\</span><span class="p">.</span><span class="n">e</span><span class="nv">$1</span><span class="err">\</span><span class="p">.</span><span class="o">/</span><span class="err">&#39;</span>
</pre></div>
<blockquote>
<p>是的, 肯定要先<code>-n</code>看看有没有操作失误, 文件出问题就麻烦了(建议先复制一份).</p></blockquote>
<p>此外, 因为用的是管道, 所以最后的<code>[files]</code>参数就不需要了, 我之前就是疏忽了, 复制过来时留着前面做测试的<code>*.mkv</code>尾巴, 看到出错提示才意识到.</p><blockquote>
<p>2021/4/22
我又来批量重命名的时候，发现<code>-print0</code>加上反而不行了，也就是说把带了换行符的<code>find</code>输出直接送到<code>rename</code> 里面，反而能成功，拼成一行送进去的不行，不知道上次是怎么成功的。</p></blockquote>
<p>so far so good.</p><p>##吐槽
简书的代码块, 预览里很好看, 发布出去千奇百怪, 是什么鬼, 为了给代码着色, 我不得不在代码语言标识上乱写一通(反正写bash是不着色的)</p><hr />
<h2>Bonus</h2>
<p>不小心看到关于<code>mv</code>的<a href="%5Bhttps://news.ycombinator.com/item?id=22860140">这个技巧</a>, 如果改动的只是文件名的一小部分, 比如在<code>10</code>前面加个<code>e</code>变成<code>e10</code>, 这么做就可以了</p><div class="highlight"><pre><span></span><span class="n">mv</span> <span class="n">Friends</span><span class="p">.</span><span class="n">s06</span><span class="p">.{,</span><span class="n">e</span><span class="p">}</span><span class="mf">10.1080</span><span class="n">p</span><span class="p">.</span><span class="n">x265</span><span class="p">.</span><span class="n">mkv</span>
</pre></div>
<p>而不需要</p><div class="highlight"><pre><span></span><span class="n">mv</span> <span class="n">Friends</span><span class="p">.</span><span class="n">s06</span><span class="p">.</span><span class="mf">10.1080</span><span class="n">p</span><span class="p">.</span><span class="n">x265</span><span class="p">.</span><span class="n">mkv</span> <span class="n">Friends</span><span class="p">.</span><span class="n">s06</span><span class="p">.</span><span class="n">e10</span><span class="p">.</span><span class="mi">1080</span><span class="n">p</span><span class="p">.</span><span class="n">x265</span><span class="p">.</span><span class="n">mkv</span>
</pre></div>
<p>原文里面有两个例子, 一目了然</p><div class="highlight"><pre><span></span><span class="nt">mv</span><span class="w"> </span><span class="nt">foo-bar-</span><span class="p">{</span><span class="err">baz,quux</span><span class="p">}.</span><span class="nc">txt</span><span class="w"></span>
<span class="nt">mv</span><span class="w"> </span><span class="nt">foo-bar</span><span class="p">{</span><span class="err">,-baz</span><span class="p">}.</span><span class="nc">txt</span><span class="w"></span>
</pre></div>
<p>以上显示的是更改和添加, 显然,你也可以猜到删除的用法, 看起来跟rename用法类似</p><div class="highlight"><pre><span></span><span class="nt">mv</span><span class="w"> </span><span class="nt">foo-bar</span><span class="p">{</span><span class="err">-baz,</span><span class="p">}.</span><span class="nc">txt</span><span class="w"></span>
</pre></div>
<p>当然这个贴子有很大的争论, 感兴趣可以看看.</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/shell%E5%91%BD%E4%BB%A4%E7%94%A8%E6%AD%A3%E5%88%99%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/ES6%E4%B8%ADgenerator%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/" target="_self">ES6中generator传参与返回值</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/ES6%E4%B8%ADgenerator%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/" target="_self">
                <time class="text-uppercase">
                    November 13 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>先看两个例子,</p><p>1,</p>
<pre><code>function* f() {
  for(var i=0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

document.write(g.next().value) // { value: 0, done: false }
document.write(g.next().value) // { value: 1, done: false }
document.write(g.next(true).value) // { value: 0, done: false }
</code></pre>
<p>2,</p>
<pre><code>function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){ 
    document.write(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（'出错了'）;
</code></pre>
<p>有什么区别?
第一个里传入了一个<code>true</code>参数, 第二个里传入了一个<code>1</code>参数, 目的都是期望传递给generator.
但例一演示的参数, 传过去是传给了<code>yield</code>语句本身的返回值, 即<code>reset</code>, 也就是说, 如果你没有传参, 每一次<code>next</code>方法, <code>reset</code>获取的结果都是<code>undefined</code>
例二中, 方法本身就有入参, 所以千万不要搞错了, 这种入参等于是一个<code>种子</code>, 所以只需要在实例化这个生成器的时候才需要传.</p><p>区别就在是在生成器里传, 还是在生成器的next方法里传. 前者是给生成器赋种子值, 后者是给每个yield赋返回值</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/ES6%E4%B8%ADgenerator%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/SwiftUI%E7%9A%84ViewModifier%E5%92%8CAnimation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_self">SwiftUI的ViewModifier和Animation学习笔记</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/SwiftUI%E7%9A%84ViewModifier%E5%92%8CAnimation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_self">
                <time class="text-uppercase">
                    October 17 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>我们通过这篇文章练习如下几个知识点，借用的是斯坦福CS193p的课程里的demo，但是代码是我写的，也就是对着最终的效果写出我的实现的意思</p><h2>ViewModifier</h2>
<figure class="vertical-figure" style="flex: 33.333333333333336" ><img width="212" height="318" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d841a907770d839bdbd57e0119a8651e.png" alt=""/></figure><p>首先，我们的卡片分为正面和背面，背面是纯色很简单，正面有一个圆环，和一张图片（实际是<code>emoji</code>，也就是<code>String</code>)，我们用<code>ZStack</code>布局好后即可：</p><div class="highlight"><pre><span></span><span class="n">ZStack</span> <span class="p">{</span>
            <span class="n">Group</span> <span class="p">{</span>
                <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">).</span><span class="n">fill</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">)</span>
                <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">).</span><span class="n">stroke</span><span class="p">(</span><span class="n">lineWidth</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
    				<span class="n">CountDownCircle</span><span class="p">()</span>  <span class="c1">// 卡片内容1</span>
    				<span class="n">Text</span><span class="p">(</span><span class="n">card</span><span class="p">.</span><span class="n">content</span><span class="p">)</span> <span class="c1">// 卡片内容2</span>
            <span class="p">}.</span><span class="n">opacity</span><span class="p">(</span><span class="n">isFaceUp</span> <span class="p">?</span> <span class="mf">1.0</span> <span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">opacity</span><span class="p">(</span><span class="n">isFaceUp</span> <span class="p">?</span> <span class="mf">0.0</span> <span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="p">}</span>
</pre></div>
<p>所以其实卡片内容就是emoji和圆环，因此我们就想，可不可以在我绘制好这两个内容后，调用一个通用方法就能把它变成一张卡片呢？</p><p><code>ViewModifier</code>就是干这个的，使用语法如同：<code>myView.modifier(Cardify(isFaceUp:))</code>
提取出来的<code>modifier</code>如下：</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Cardify</span><span class="p">:</span> <span class="n">ViewModifier</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span>

    <span class="kd">func</span> <span class="nf">body</span><span class="p">(</span><span class="n">content</span><span class="p">:</span> <span class="n">Content</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="n">ZStack</span> <span class="p">{</span>
            <span class="n">Group</span> <span class="p">{</span>
                <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">).</span><span class="n">fill</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">white</span><span class="p">)</span>
                <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">).</span><span class="n">stroke</span><span class="p">(</span><span class="n">lineWidth</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
                <span class="n">content</span>  <span class="c1">// 正面卡片内容</span>
            <span class="p">}.</span><span class="n">opacity</span><span class="p">(</span><span class="n">isFaceUp</span> <span class="p">?</span> <span class="mf">1.0</span> <span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">)</span>
            <span class="p">.</span><span class="n">opacity</span><span class="p">(</span><span class="n">isFaceUp</span> <span class="p">?</span> <span class="mf">0.0</span> <span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span> <span class="c1">// 反面卡片内容</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>Extension</h2>
<p>更进一步，SwiftUI不是有很多<code>View.font(..).opacity(...)</code>的用法么，其中的<code>font</code>，<code>opacity</code>就是这些modifier，然后扩展（<code>extension</code>）给<code>View</code>的，我们也可以：</p><div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">modifier</span><span class="p">(</span><span class="n">Cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="n">isFaceUp</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>很简单的语法，这样最终<code>myView.cardify(isFaceUp:)</code>就能把当前内容给“<strong>卡片化</strong>”了</p><h2>Animation</h2>
<p>想点击卡片翻面的时候有一个翻页效果，有一个原生的<code>rotation3DEffect</code>方法：</p><div class="highlight"><pre><span></span><span class="n">myView</span><span class="p">.</span><span class="n">rotation3DEffect</span><span class="p">(</span>
            <span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">animatableData</span><span class="p">),</span>
            <span class="n">axis</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="c1">// 沿Y轴翻转，即水平翻转</span>
            <span class="p">)</span>
</pre></div>
<p>实际效果如下：
<figure class="vertical-figure" style="flex: 35.714285714285715" ><img width="220" height="308" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/72b4116eb1e49a3b1eaa9097a2890b60.jpg" alt=""/></figure></p><p>动画加长了，我们能看清卡片虽然有了翻面的动面，但是在开始动画的一瞬间，卡片的正面就显示出来了，我们来解决这个问题，所以我这里并不是系统讲解动画，而是在对解决问题的思路做个笔记。</p><blockquote>
<p>题外话，我觉得<code>SwiftUI</code>和<code>Flutter</code>诞生时代相同，很多理念也驱同，在动画方面，也是放弃了以前要么从头画起，要么用封装得很好的有限几个动画的思路，基本上让你能用自绘+插值的方式来自己控制动画（有点类似关键帧，但关键帧的帧与帧之间也是自动的），而现在你可以完全对一个过程进行Linear interpolation，来控制动画过程（Flutter中的<code>lerp</code>函数就是干这个的，本节也有SwiftUI的类似实现）。</p></blockquote>
<p>比如这个翻转，<code>Objective-C</code>里直接就给你实现好了，在SwiftUI里，给的是一个最基本的几何变换，至于这上面的效果，就要你自己实现了。我认为这是对的。</p><p>按课程里的思路，卡片要么正面，要么反面，是由<code>isFaceUp</code>决定的，加入动画后，那需要这个属性在进行了50%（也就是90˚）的时候才改值</p><p>而这个属性是卡片的属性，与动画无关，所以<strong>第一个决策</strong>，就是把动画函数写到<code>ViewModifier</code>里面去，传进去的是卡片的属性，但是在<code>modifier</code>里，我们把它适当转化成应该转的角度（0˚或90˚）,这样在<code>modifier</code>里面不管做什么变化，都不影响外部调用者自己的语义了（方法和参数都没变）：</p><div class="highlight"><pre><span></span><span class="kd">init</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// step1 这里接的是布尔值，但是我们需要把它转成对应的翻转角度</span>
        <span class="n">animatableData</span> <span class="p">=</span> <span class="n">isFaceUp</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">180</span>
    <span class="p">}</span>

    <span class="c1">// 重新定义了isFaceUp，改由翻转角度的大小决定</span>
    <span class="c1">// 从而解决isFaceUp在第一时间就改变的问题</span>
    <span class="kd">var</span> <span class="nv">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="c1">// step3</span>
        <span class="n">animatableData</span> <span class="o">&lt;</span> <span class="mi">90</span>
    <span class="p">}</span>
</pre></div>
<p>剩下的就是语法了，我们要实现一个<code>Animatable</code>的协议，与<code>ViewModifier</code>协议合并成<code>AnimatableModifier</code>，它只有一个属性，用我的话来说，就是前面提到的“动画插值”，我一直用这一个概念来理解这些新库里的动画原理，你也可以有你的理解。</p><p>总之，它需要你指定一个提供插值的来源，在这个例子中，这个来源就是<code>rotation3DEffect</code>函数，因为它会自动执行动画，显然里面的“<strong>角度</strong>”参数是会自己变的，我们要的就是捕捉这个“<strong>角度</strong>”，组合起来，看代码：</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Cardify</span><span class="p">:</span> <span class="n">AnimatableModifier</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// step1 把参数转化成动画插值的（最终）值</span>
        <span class="n">animatableData</span> <span class="p">=</span> <span class="n">isFaceUp</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">180</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nv">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="c1">// step3 通过插值来反推正反面</span>
        <span class="n">animatableData</span> <span class="o">&lt;</span> <span class="mi">90</span>
    <span class="p">}</span>

    <span class="c1">// step0</span>
    <span class="c1">// 把写死的角度变成插值</span>
    <span class="kd">var</span> <span class="nv">animatableData</span><span class="p">:</span> <span class="nb">Double</span> <span class="c1">// 这个类型是自定义的， 我们要用它来旋转角度，所以是double</span>

    <span class="kd">func</span> <span class="nf">body</span><span class="p">(</span><span class="n">content</span><span class="p">:</span> <span class="n">Content</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="n">ZStack</span> <span class="p">{</span>
            <span class="n">Group</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">isFaceUp</span> <span class="p">{</span>
    					<span class="c1">// 卡片正面代码                </span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                	   <span class="c1">// 卡片反面代码</span>
                <span class="p">}</span>
        <span class="c1">// step2</span>
        <span class="c1">// 课程里是有额外的角度参数，并且与animatableData进行了绑定</span>
        <span class="c1">// 其实为了演示插值的作用，不包装更直观</span>
        <span class="p">.</span><span class="n">rotation3DEffect</span><span class="p">(</span>
            <span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">animatableData</span><span class="p">),</span>
            <span class="n">axis</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>效果如下，其实就是解决了如何捕捉动画进度的问题，也就是<code>animatableData</code>
<figure class="vertical-figure" style="flex: 35.714285714285715" ><img width="220" height="308" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/72b4116eb1e49a3b1eaa9097a2890b60.jpg" alt=""/></figure></p><h2>Animation2</h2>
<p>多一个例子，课程里每张卡片翻开就会倒计时，原本是一个大饼，我根据我的喜好改成了圆环（其实是我学教程的习惯，尽可能不去做跟教程一样的事，避免思维惰性）</p><p>那么怎么让进度条动起来呢？终于讲到了怎么手动计算<strong>插值</strong>，并把这组值推给动画库让它动起来的过程了。</p><p>有了上一个例子，我查看了一个<code>Shape</code>的定义，原生就conform to protocol <code>Animatable</code>的，所以我们直接添加一个<code>AnimatedData</code>试试。</p><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">animatableData</span><span class="p">:</span> <span class="nb">Double</span>   <span class="c1">// degrees</span>
</pre></div>
<blockquote>
<p>这里跟上例有一点区别，上一例动画是系统库做好的，我们只是<code>capture value</code>，所以几乎只要把那个变量摆在那，别处需要的时候直接使用就可以了，而现在我们是要主动更改这个data，从而实现绘图的不断更新，所以稍微复杂了些。</p></blockquote>
<p>课程里把起点和终点都做成了动画参数，可能是为了演示<code>AnimatablePair</code>，而本例中起点其实是不变的，所以我实事求是，把它用最简单的方法来实现，同时，放弃对象化思维，使用动画插值的思维，不去考虑插值与原来的类的属性有什么关系，直接把插值用在需要变化的位置，这是做教学的话最直观的方案了，按我的做法，代码几乎没有变化，就多了一行和改了一行：</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">CountDownCircle</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span>

<span class="cm">/* </span>
<span class="cm">以下注释掉的是教程的用法，保留了data与angle的关系</span>
<span class="cm">    var endAngle: Angle  //</span>
<span class="cm">    var animatableData: Double {</span>
<span class="cm">        get {</span>
<span class="cm">            endAngle.degrees</span>
<span class="cm">        }</span>
<span class="cm">        set {</span>
<span class="cm">            print(&quot;set: \(newValue)&quot;)</span>
<span class="cm">            endAngle = Angle.degrees(newValue)</span>
<span class="cm">        }</span>
<span class="cm">*/</span>    
    <span class="c1">// 我直观展示这个插值的用法</span>
    <span class="kd">var</span> <span class="nv">animatableData</span><span class="p">:</span> <span class="nb">Double</span>   <span class="c1">// degrees</span>

    <span class="kd">func</span> <span class="nf">path</span><span class="p">(</span><span class="k">in</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Path</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">Path</span><span class="p">()</span>
        <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">rect</span><span class="p">.</span><span class="n">midX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">rect</span><span class="p">.</span><span class="n">midY</span><span class="p">)</span>
        <span class="n">p</span><span class="p">.</span><span class="n">addArc</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                 <span class="n">radius</span><span class="p">:</span> <span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="mf">10.0</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>
                 <span class="n">startAngle</span><span class="p">:</span> <span class="n">Angle</span><span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">90</span><span class="p">),</span>
                 <span class="n">endAngle</span><span class="p">:</span> <span class="n">Angle</span><span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">animatableData</span><span class="p">),</span> <span class="c1">//endAngle（教程用endAngle）,</span>
                 <span class="n">clockwise</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>改造很简单，就是把告诉动画库“<strong>结束角度</strong>”是一个需要变动的值就好了，我们调用的时候把一个<strong>能自己变化的值</strong>送到这个参数里就能动起来。对调用者进行一点准备：</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">animatedData</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">0.0</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">startRemainingCountdown</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">animatedData</span> <span class="p">=</span> <span class="err">剩余进度</span>
        <span class="n">withAnimation</span><span class="p">(.</span><span class="n">linear</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="err">剩余时间</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">animatedData</span> <span class="p">=</span> <span class="mf">0.0</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<p>这里做了两件事：</p><ol>
<li><code>@State</code>的用法，<code>View</code>是无状态的，现在我们要做动画，需要保持一些状态，这里我们保持一个“进度”的值</li>
<li>添加了一个触发动画的函数，就是设置动画初值，设置终止值，然后通过<code>withAnimation</code>函数让它自动生成插值序列，这就是我前面提过的类似的<code>Flutter</code>的<code>lerp</code>方法，SwiftUI中没找到，但是变相提供了用系统动画来提供插值的做法。</li>
</ol>
<p>使用就很简单了，把“<strong>进度</strong>”填到相应的参数位，然后选择一个时机触发，我们这里选择的是<code>onAppear</code></p><div class="highlight"><pre><span></span><span class="n">CountDownCircle</span><span class="p">(</span><span class="n">animatableData</span><span class="p">:</span> <span class="o">-</span><span class="n">animatedData</span><span class="o">*</span><span class="mi">360</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="p">.</span><span class="n">stroke</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="n">strokeStyle</span><span class="p">).</span><span class="n">opacity</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="p">.</span><span class="n">onAppear</span> <span class="p">{</span>
            <span class="n">startRemainingCountdown</span><span class="p">()</span>
        <span class="p">}</span>
</pre></div>
<blockquote>
<p>需要注意的是<code>withAnimation</code>过程中对值的更改我们并不能显式捕捉，至少我试图把它显示在UI上观察它的变化是失败的，直接显示了最终值，而在接这个变化的插值的底层函数里，我能在<code>animatableData</code>的<code>set</code>方法里看到确实设置了无数的插值，暂时没有理解<code>withAnimation</code>真的有有没有直接对两个数字直接生成一系列中间值</p></blockquote>
<p>效果如下：
<figure class="vertical-figure" style="flex: 35.714285714285715" ><img width="220" height="308" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/72b4116eb1e49a3b1eaa9097a2890b60.jpg" alt=""/></figure></p><h2>后记</h2>
<p>动画我之前写过一篇：<a href="https://www.jianshu.com/p/0e4c8f0e1c23">用CALayer绘图,添加动画和渐变</a>，很明显可以看到，以前的写法仍然是黑匣子，即告诉动画库，请给我动画，动画的要求是blablabla，而现在都走了插值的路线，即把一系列值告诉你，你按照每个值直接绘图就是了，绘成啥样我自己负责。这就是我这篇文章反复强调的思路的变化，我喜欢这种思路。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/SwiftUI%E7%9A%84ViewModifier%E5%92%8CAnimation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E4%BB%8E%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8%E7%9A%84shell%E5%91%BD%E4%BB%A4%E8%AF%B4%E5%BC%80%E5%8E%BB/" target="_self">从查找文件并移动的shell命令说开去</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E4%BB%8E%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8%E7%9A%84shell%E5%91%BD%E4%BB%A4%E8%AF%B4%E5%BC%80%E5%8E%BB/" target="_self">
                <time class="text-uppercase">
                    October 13 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>一个不能更常见的需求: 从一大堆下载目录(或别的目录)里, 查找指定的文件, 并移动/复制到指定的文件夹, 如果用鼠标点开一个个的文件夹, 还有文件夹里的文件夹, 估计要累死, 当然, 即使自己不会, 也很容易查到两个shell命令:</p>
<pre><code>find path_A -name &quot;*AAA*&quot; -print0 | xargs -0 -I {} mv {} path_B
find path_A -maxdepth 1 -name &quot;*AAA*&quot; -exec mv {} path_B \; 
</code></pre>
<p>都能达到目的, 第二条命令容易懂很多(<code>-maxdepth</code>去掉就是recrusive search), 去<code>exec</code>一个<code>mv</code>命令, 记得加上表示语句结束的分号就好了, 我的关注点在第一条, 趁机学学<code>xargs</code>吧.</p><p>查到<a href="https://www.cnblogs.com/wangqiguo/p/6464234.html">这篇文章</a>说的不错, 先摘几个要点:</p>
<pre><code>echo 'main' | cat test.cpp
</code></pre>
<p>这条命令并不会把<code>main</code>输出, 因为管道确实将其作为标准输入给了<code>cat</code>命令作为标准输入, 但因为有了<code>test.cpp</code>这个命令行参数, <code>cat</code>命令就没有去读标准输入的参数了.<br />
其实基本上linux的命令中很多的命令的设计是先从命令行参数中获取参数，然后从标准输入中读取，反映在程序上，命令行参数是通过main函数<code>int main(int argc,char*argv[])</code>的函数参数获得的，而标准输入则是通过标准输入函数例如C语言中的scanf读取到的。他们获取的地方是不一样的。例如：</p>
<pre><code>echo 'main' | cat
</code></pre>
<p>这条命令中cat会从其标准输入中读取内容并处理，也就是会输出 'main' 字符串。echo命令将其标准输出的内容 'main' 通过管道定向到 cat 的标准输入中。</p>
<pre><code>cat
</code></pre>
<p>如果仅仅输入cat并回车，则该程序会等待输入，我们需要从键盘输入要处理的内容给cat，此时cat也是从标准输入中得到要处理的内容的，因为我们的cat命令行中也没有指定要处理的文件名。大多数命令有一个参数<code>-</code>如果直接在命令的最后指定 <code>-</code>则表示从标准输入中读取，例如：</p>
<pre><code>echo 'main' | cat -
</code></pre>
<p>这样也是可行的，会显示 'main' 字符串，同样输入	<code>cat -</code>直接回车与输入 <code>cat</code>直接回车的效果也一样，但是如果这样呢：</p>
<pre><code>echo 'main' | cat test.cpp -
</code></pre>
<p>同时指定test.cpp 和 - 参数，此时cat程序会先输出test.cpp的内容，然后输出标准输入'main'字符串，如果换一下顺序变成这样：</p>
<pre><code>echo 'main' | cat - test.cpp
</code></pre>
<p>则会先输出标准输入'main'字符串，然后输出test.cpp文件的内容。如果去掉这里的<code>-</code>参数，则cat只会输出test.cpp文件的内容。另外如果同时传递标准输入和文件名，grep也会同时处理这两个输入，例如：</p>
<pre><code>echo 'main' | grep 'main' test.cpp -
</code></pre>
<p>此处同上, 如果不加<code>-</code>, 则只会在test.cpp中搜索&quot;main&quot;, 加了<code>-</code>, 则会在文件和标准输出中都检查关键字.</p><p>另外很多程序是不处理标准输入的，例如<code>kill</code>,<code>rm</code>这些程序如果命令行参数中没有指定要处理的内容则不会默认从标准输入中读取。所以：</p>
<pre><code>echo '516' | kill
</code></pre>
<p>这种命里是不能执行的。</p>
<pre><code>echo 'test' | rm -f
</code></pre>
<p>这种也是没有效果的。</p><p>有时候我们的脚本却需要<code>echo '516' | kill</code>这样的效果，例如<code>ps -ef | grep 'ddd' | kill</code>这样的效果，筛选出符合某条件的进程pid然后结束。这种需求对于我们来说是理所当然而且是很常见的，那么应该怎样达到这样的效果呢。有几个解决办法：</p>
<pre><code>kill `ps -ef | grep 'ddd'`    
</code></pre>
<p>这个时候实际上等同于拼接字符串得到的命令，其效果类似于<code>kill $pid</code></p>
<pre><code>for procid in $(ps -aux | grep &quot;some search&quot; | awk '{print $2}'); do kill -9 $procid; done   
</code></pre>
<p>其实与第一种原理一样，只不过需要多次kill的时候是循环处理的，每次处理一个</p>
<pre><code>ps -ef | grep 'ddd' | xargs kill  
</code></pre>
<p>OK，使用了<code>xargs</code>命令，铺垫了这么久终于铺到了主题上。<code>xargs</code>命令可以通过管道接受字符串，并将接收到的字符串<strong>通过空格分割成许多参数</strong>(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数</p><p>###xargs与管道的区别</p>
<pre><code>echo '--help' | cat
echo '--help' | xargs cat
```	
第一句输出`--help`, 第二句相当于执行了`cat --help`, 所以管道是把前面的输出当成后面的输入, 而`xargs`则是把前面的输出当成了后面的命令行参数.

`xargs`的命令参数可以查我给的引用原文, 说得详细且有实例, 或者看下面的简单介绍:

</code></pre>
<p>-0，--null：以\0作为分隔符，接受到的特殊字符将当作文本符号处理；<br />
-d：指定分段的分隔符，默认分隔字符为空白字符；
-a，--arg-file=file：指定命令标准输入的来源文件；
-e'FLAG' 或者-E 'FLAG'：指定一个终止符号，当xargs命令匹配到第一个FLAG后，停止传递，并退出命令；
-p：每当xargs执行一个分段时，询问一次用户是否执行；
-t：表示先打印执行的命令再输出；
-n NUM：表示一个分段包含的参数个数，参数之间以分隔符隔开，默认是将所有的参数当作一个分段输出；
-i：用于将分段分批传递给其后的{}进行输出，分段会替换{}所在的位置进行输出；
-I &quot;FLAG&quot;：可指定分段的替换符号，分段会分批替换到符号所在的位置进行输出执行；
-L：指定每次执行的最大的非空行的行数；</p>
<pre><code>我们来说回&quot;查找并移动&quot;这个原始需求.

首先, 前面铺垫的那么多`-`与标准输入的内容其实与`find`命令并无多大关系. 我们看这里面用到的三个参数

### -print0
用过`find`都知道它的结果是以换行符分隔的, 而加上`-print0`选项则可以把它换成`\0`(其实就是`NUL`)来分隔. 嗯, 不是空格, 但是至少变成了一行, 有点命令行参数的意思了吧?

### -0
就是`--null`, 以`null`为分隔符, 因为我们在前面设置`find`的输出为`null`, 这里当然要设置相应的分隔符. 如果仔细读了前面的参数表, 会发现其实它就是`-d '\0'`的简化版.

### -I
这个命令的英文说明看得我云里雾里, 一贯的不说人话风格, 我还是用一个实例来说明它的用法吧

我在一个目录里建了几个文件, 用`find`把它找出来并用`xargs`把它`echo`出来:

</code></pre>
<p>$find . -name &quot;*.txt&quot; -print0 | xargs -p -0 echo
echo ./c.txt ./b.txt ./a.txt?...y
./c.txt ./b.txt ./a.txt</p>
<pre><code>    
注意, 我加了一个`-p`参数, 这是为了在执行命令前先把命令打印出来, 这样一来你有机会检查生成的命令最终是不是你想要的, 另一方面也能检查你的命令是否执行了多次.

根据上面的演示, 我们发现一个问题, 就是如果是执行`mv file path/`这样的命令, 也就是说我们需要在命令**中间**插入管道过来的参数, 是不行的, 似乎应该用占位符.

反向学习, 我们既然已经知道了`-I replstr`是正确答案, 那就尝试一下吧:

</code></pre>
<p>$find . -name &quot;*.txt&quot; -print0 | xargs -p -0 -I {} echo {} &quot;HELLO&quot;
echo ./c.txt HELLO?...y
./c.txt HELLO
echo ./b.txt HELLO?...y
./b.txt HELLO
echo ./a.txt HELLO?...y
./a.txt HELLO</p>
<pre><code>
首先, 我们发现, 我们成功地在`echo`和`HELLO`间插入了管道过来的参数, 其次, 它还把参数用分隔符自行拆开了一次执行一个(又有点类似于添加了`-n 1`的选项的意思).

现在我们明白了, 网上查到的那条命令最终就是执行了N次`mv FILE /path`, 这就是`-I {}`.

Furthermore, 我们把标准答案里那高大上的`{}`换一下如何?

</code></pre>
<p>$ find . -name &quot;*.txt&quot; -print0 | xargs -p -0 -I 'M' echo 'M' &quot;HELLO&quot;
echo ./c.txt HELLO?...y
./c.txt HELLO
echo ./b.txt HELLO?...y
./b.txt HELLO
echo ./a.txt HELLO?...y
./a.txt HELLO</p><p>$ find . -name &quot;*.txt&quot; -print0 | xargs -p -0 -I M echo M &quot;HELLO&quot;
echo ./c.txt HELLO?...y
./c.txt HELLO
echo ./b.txt HELLO?...y
./b.txt HELLO
echo ./a.txt HELLO?...y
./a.txt HELLO</p>
<pre><code>
这里我分别用了`'M'`和`M`, 都不影响其作为占位符的作用, 不要被那故弄玄虚的`{}`给迷惑了. 之所以用`{}`应该还是它更好被辨识和表义, 并不是大括号本身是什么语法.
</code></pre>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E4%BB%8E%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8%E7%9A%84shell%E5%91%BD%E4%BB%A4%E8%AF%B4%E5%BC%80%E5%8E%BB/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/error--IB-Designables--Failed-to-update-auto-layout-status/" target="_self">error--IB-Designables--Failed-to-update-auto-layout-status</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/error--IB-Designables--Failed-to-update-auto-layout-status/" target="_self">
                <time class="text-uppercase">
                    August 21 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>首先, 了解一下 <a href="http://nshipster.com/ibinspectable-ibdesignable/">IBInspectable / IBDesignable</a>
这是让 Xcode能在设计时就体现你代码对 UI 进行的修改, 以及在设计器里能动态增加你对视图添加的属性的控件的特性(是的, 只是 xcode 的特性, 并不是语言特征)</p><p>然后, 用这个的人多半碰到了这类问题:
<figure  style="flex: 200.0" ><img width="360" height="90" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8dd76778db9d224fac448fc48d7671eb.png" alt=""/></figure></p><blockquote>
<p>error: IB Designables: Failed to update auto layout status: Interface Builder Cocoa Touch Tool raised a &quot;NSInternalInconsistencyException&quot; exception: Could not load NIB in bundle: 'NSBundle</p></blockquote>
<p>网上可能有一大堆讨论相关问题的贴子, 解决方法不尽其数, 可能都不适用你, 所以我的这篇也可能不适用你, 最好还是善用搜索, 我谨提供一种思路.</p><p>网上有让你修改工程配置的, 寻找崩溃日志的, 解决我这个问题的, 是在Storyboard 界面里选中出问题的 View(你一定要至少知道是给哪个 view 添加上 <code>IB_DESIGNABLE</code>才导致的问题, 可以通过逐个移除这个声明以测试), 再在菜单里选择: <code>Editor - Debug Selected Views</code>
这个时候就会模拟<code>IB_DESIGNABLE</code>进行 debug, 再加上全局异常断点, 代码就会在崩溃处命中了.</p><p>我的问题是我用了两个属性, 然后在 view 的 <code>drawWithRect:</code>方法中, 这两个属性都为空, 而我的属性是在<code>initWithCoder:</code>中初始化的. 所以我再添加<code>initWithFrame:</code>, 在其中解决, 顺利解决.</p><p>这说明三个问题:</p><ol>
<li><code>IB_DESIGNABLE</code>目前的实现还有 bug, 真实启动是跑<code>initWithCoder:</code>的, 它在设计器里绘图的时候却走了<code>initWithFrame:</code>, 你可能不得不为了对付这个 bug 而添加一次同样的代码</li>
<li><code>initWithFrame:</code>的时候 frame 是{0, 0, 0, 0}可别忘了, 有时候这个也是崩溃原因</li>
<li>如果我把<code>drawWithRect:</code>中要用到的属性提前初始化一样可以避免这样的问题, 怎样做? 配合<code>IBInspectable</code>, 然后在设计器中给属性设初始值</li>
</ol>
<figure  style="flex: 145.88235294117646" ><img width="1240" height="425" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/9224752a673054143b82aadd16747841.png" alt=""/></figure></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/error--IB-Designables--Failed-to-update-auto-layout-status/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/El-Captain%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" target="_self">El-Captain设置环境变量</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/El-Captain%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" target="_self">
                <time class="text-uppercase">
                    August 19 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这里说的不是设置变量给bash/shell来用, 而是给程序使用, 比如, chromium自36版以后, 就不再内置google api keys, <a href="http://www.chromium.org/developers/how-tos/api-keys">官方文档</a>说明你打包的时候没有添加key的话, 可以在runtime添加, 比如在系统的环境变量里添加进去.</p><blockquote>
<p>Providing Keys at Runtime</p></blockquote>
<p>If you prefer, you can build a Chromium binary (or use a pre-built Chromium binary) without API keys baked in, and instead provide them at runtime. To do so, set the environment variables GOOGLE_API_KEY, GOOGLE_DEFAULT_CLIENT_ID and GOOGLE_DEFAULT_CLIENT_SECRET to your &quot;API key&quot;, &quot;Client ID&quot; and &quot;Client secret&quot; values respectively.</p><p>至于key哪来的请自行google, 我们不去申请key的话, 还是拿来主义:</p><blockquote>
<p>export GOOGLE_API_KEY=&quot;AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k&quot;</p></blockquote>
<p>export GOOGLE_DEFAULT_CLIENT_ID=&quot;811574891467.apps.googleusercontent.com&quot;
export GOOGLE_DEFAULT_CLIENT_SECRET=&quot;kdloedMFGdGla2P1zacGjAQh&quot;</p><p>关于如何在mac上设置环境变量, 有这么<a href="http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-mac-os-x-terminal-only/">一篇雄文</a>, 我一般是直接编辑<code>~/.bash_profile</code>文件, 这次不生效了, 改来改去都没用, 于是换关键词: <code>yosemite/el captain下如何设置环境变量</code>, 立刻就有<a href="http://stackoverflow.com/questions/25385934/setting-environment-variables-via-launchd-conf-no-longer-works-in-os-x-yosemite">答案</a>了</p><p>头两个答案都可以, 第一个是使用了<code>setenv VARIABLENAME=VALUE</code>这种语法, 第二个是直接在一个文件里编辑, 然后使之生效, 我直接用了第二种, 因为文本随时可编辑, 可查看</p><p>1, Create an environment.plist file in <code>~/Library/LaunchAgents/</code> with this content:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
  &lt;key&gt;Label&lt;/key&gt;
  &lt;string&gt;my.startup&lt;/string&gt;
  &lt;key&gt;ProgramArguments&lt;/key&gt;
  &lt;array&gt;
    &lt;string&gt;sh&lt;/string&gt;
    &lt;string&gt;-c&lt;/string&gt;
    &lt;string&gt;
        launchctl setenv GOOGLE_API_KEY AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k
        launchctl setenv GOOGLE_DEFAULT_CLIENT_ID 811574891467.apps.googleusercontent.com
        launchctl setenv GOOGLE_DEFAULT_CLIENT_SECRET kdloedMFGdGla2P1zacGjAQh
    &lt;/string&gt;
  &lt;/array&gt;
  &lt;key&gt;RunAtLoad&lt;/key&gt;
  &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>2, You can add many launchctl commands inside the <code>&lt;string&gt;&lt;/string&gt;</code> block.可见, 我们只需要在<code>string</code>标签里写需要的内容就行了, 本例是一系列google api keys.</p><p>3, The plist will activate after system reboot. You can also use <code>launchctl load ~/Library/LaunchAgents/environment.plist</code> to launch it immediately.</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/El-Captain%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/-bin-bash%E5%92%8C-bin-sh%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_self">-bin-bash和-bin-sh的区别</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/-bin-bash%E5%92%8C-bin-sh%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_self">
                <time class="text-uppercase">
                    July 02 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p><a href="https://wangdoc.com/bash/intro.html">教程地址</a></p><h2>快捷键:</h2>

<pre><code>ctrl+L: 清除屏幕并移到顶部
ctrl+U: 删到行首(剪) ctrl+A: 移到行首
ctrl+K: 删到行尾(剪) ctrl+E: 移到行尾
ctrl+b, f, (左移, 右移)
alt+b,f (前, 后移一个单词)
ctrl+1 等同于clear
ctrl+d delete, ctrl+w 删到单词首
alt+t 词换位, ctrl+t 字符换位 (与前一个)
alt+d, alt+backspace 剪切至词首, 词尾
ctrl+y 粘贴
</code></pre>

<pre><code>$ ’Something wrong happend’ &gt;&amp;2
</code></pre>
<p>解释:</p><blockquote>
<p><code>&gt;</code>代表重定向输出</p></blockquote>
<p><code>&amp;</code>表示接下来的是一个文件描述符数字(<em>file descriptor number</em>)
<code>2</code>表示<code>stderr</code>
所以就是把上述字符串输出到stderr里去的意思,
如果是<code>$ ”str” &lt;2</code> (没有&amp;), 则会输出到一个叫2的文件里去</p><h2>echo</h2>
<p><code>-n</code>: 可以取消结尾的换行 
<code>-e</code>: 解释字符串里的转义符</p><h2>扩展(通配符)</h2>

<pre><code>$ ~/walker # 表示用户目录下的walker目录
$ ~walker # 表示名为walker的目录
$ ~+ # 扩展为当前目录, 等同于 pwd
$ echo d{a, e, I, o, u}g 输出: dag, deg, dig, dog, dug # 大括号内不要有空格(否则会当成参数)
$ echo {j{p,pe}g, png} —&gt; 嵌套
</code></pre>
<p>波浪线, 方括号的括号都是基于”<strong>路径</strong>”的, 如果当前路径没有匹配到对应的文件名, 则会<strong>变成字符串</strong>原样输出, 而大括号则不然, 是基于”<strong>逻辑</strong>”的, 只管扩展, 不会去探测扩展后对应的路径存不存在, 因此可能报错文件不存在. 
如<code>echo [a,b].txt</code>, 如果不存在a.txt, b.txt, 则会变成<code>”[a,b].txt”</code>这样一个输出, 而<code>{a,b}.txt</code>则<strong>一定</strong>会扩展成a.txt, b.txt
<strong>例外</strong>: 
在用<code>..</code>来扩展时, 如果系统无法理解, 则不会扩展, 如<code>{1..5}</code>会扩展成1,2,3,4,5, 但<code>{ab..123}</code>, 则会变成字符串
但是前导0不参与路径匹配: <code>{01…5}</code> # 01,02,03,04,05 (几个零都可以)
步长:{0..8..2}  (<code>未测试成功</code>) # 要打开哪个shopt开关?
活用:</p>
<pre><code>$ echo .{mp{3..4},m4{a,b,p,v}} # 匹配了: .mp3 .mp4 .m4a .m4b .m4p .m4v
$ mkdir {2007..2009}-{01..12}  # 建了2007-2009每年12个目录
for I in {1..4}
</code></pre>
<p>注意惊叹号的使用(类似正则里的<code>^</code>)</p>
<pre><code>$ echo ${!S*} # 返回所有以S开头的”变量名”, 如SHELL, SSH..等
</code></pre>
<p>另两种转义(<code>string interpolation</code>):</p>
<pre><code>$ echo date is $(date) # 即包在$(…)中
$ echo date is `date` # 包在反引号中
</code></pre>
<p>但是要计算2+2, 只有<code>echo $((2+2))</code> 这种形式, 反引号就不行了</p><p>[[:alnum:]], [[:digit:]]等<strong>预置</strong>的字符类扩展见: <a href="https://wangdoc.com/bash/expansion.html"><a href="https://wangdoc.com/bash/expansion.html">https://wangdoc.com/bash/expansion.html</a></a> 很丰富, 建议详读.</p><p><code>(?, \*, +, @, !)</code>则为匹配的个数, 分别是(0或1, 0或多, 一或多, 一个, 非一个), 如<code>song@(.)mp3</code>等同于song.mp3,
是的, 不同于正则, 它是先规定<strong>个数</strong>, 再设定匹配字串</p><blockquote>
<p>注: 需要打开<code>shopt -s extglob</code></p></blockquote>
<p>双引号碰到$, 反引号和反斜杠都会自动扩展, 所以<code>echo “$SHELL”</code> 等同于<code>echo echo \$SHELL</code>
双引号能保留”输出”的格式, 比如 echo `cal`, 格式就没了, 自己试试看? 而<code>echo “$(cal)”</code>则可以保留格式:</p>
<pre><code>$ echo &quot;$(cal)&quot;
      六月 2020
日 一 二 三 四 五 六
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30
</code></pre>
<p>大段文字输入可以用</p>
<pre><code>$command &lt;&lt; token
your long inputs
token
</code></pre>
<p>等同于: <code>echo &quot;your long inputs&quot; | command</code> 即把echo的输出作为command的输入, 这个一般用于多行文本</p><blockquote>
<p>texts里面可以进行使用变量, 但是如果把token用双引号包起来就不能解释变量了.</p></blockquote>
<p>如果只是简单字符串, 用下面更明确:
<code>$ command &lt;&lt;&lt; ‘text’</code> 
如: <code>$ cat &lt;&lt;&lt; “hello world”</code>, 一样等同于 <code>$ echo “hello world” | cat</code>
<code>&lt;&lt;&lt;</code> 还有一个作用就是把变量值用这种方式能变成<strong>标准输入</strong>, 这样被”<strong>计算</strong>”出来的值也能用于只接受标准输入的命令了, 比如<code>read</code></p><h2>变量</h2>
<p><code>printenv PATH</code> 与 <code>echo $PATH</code>等同
解释变量中的变量, 比如<code>$PATH</code>, 不是想象中的$嵌套: <code>${${myvar}}</code>, 应该这么用</p>
<pre><code>$ myvar=PATH
$ echo ${!myvar}, # 即多加一个惊叹号
</code></pre>
<p><code>$?</code>: 上一个命令的退出码(0成功, 1失败) 
<code>$$</code>: 当前Shell进程的ID
<code>$_</code>: 上一个命令的最后一个参数
<code>$!</code>: 最后一个后台执行的异步命令的进程ID
<code>$0</code>: 当前Shell的名称
<code>$-</code>: 当前shell的启动参数, <code>$@</code>, <code>$#</code> 表示脚本的参数数量</p><blockquote>
<p><code>$?</code>命令除了取出上一个命令的返回值, 也可以取出上一个函数的返回值</p></blockquote>
<p><code>${varname-:value}</code> 取值, 如果不存在则返value, 但<strong>不赋值</strong>
<code>${varname=:value}</code> 取值, 如果不存在则返value, 顺便<strong>赋值</strong>
<code>${varname+:value}</code> 如果有值则返value(而<strong>不是值本身</strong>), 没有值则为空, 所以这个时候的value一般用一个标识符号就好了
<code>${varname?:value}</code> 取值, 如果不存在就<strong>报错</strong>并把value作为错误错误打印出来
比如 <code>$ filename=${$1:?”filename missing”}</code> 从脚本中取第一个参数作为文件名, 发现没有文件名就报错退出</p><p>变量都是字符串, 可以用<code>declare</code>来进行一些限定</p>
<pre><code>$ declare -I v1=13 v2=14 v3=v1+v2 # 声明为integer
$ echo $v3
# 这样更快: 
$ let v=13+14  # 如果习惯了=两边加空格, 则包到引号里: $ let “v = 13 + 14”
</code></pre>
<h2>字符串</h2>
<p><code>${#”string”}</code> 长度
<code>${varname:offset:length}</code> 切片(变量名_不需要_美元符号)
删除: (# 和 ## 的区别就是贪婪与否的区别)</p>
<pre><code>$ phone=&quot;555-456-1414&quot;
$ echo ${phone#*-}
&gt; 456-1414
$ echo ${phone##*-}
&gt; 1414
</code></pre>
<p>替换: <code>${variable/#pattern/string}</code> 注意, <code>#</code> 左边多了一个 <code>/</code> , 右边多了替换字串
以上, 都是从头匹配, 从<strong>尾部</strong>匹配把 <code>#</code> 换成 <code>%</code> 
<strong>任意位置</strong>匹配则换成/, 所以就成了你们最熟悉的语法:<code>varname/search/replace</code></p><blockquote>
<p>这个时候再回头看<code>/#</code> , <code>/%</code>, 不过是<code>/</code>语法的修饰符罢了(限定起始方向)</p></blockquote>
<p><code>${varname^^}</code>, <code>${varname,,}</code> # 转大写, 转小写</p><h2>数值运算</h2>
<p>逗号是求值, 如
<code>$ echo $((foo = 1+2, 3*4))</code> 输出为12, 但foo的值是3, 依次计算, 输出是逗号后面的</p><blockquote>
<p><code>expr</code>命令等同于双括号: <code>expr 3+5</code> 与<code>$((3+5))</code>同义</p></blockquote>
<h2>行操作</h2>
<p>Bash内置Readline库, 默认采用Emacs快捷键, 切换:</p>
<pre><code>$ set -o vi 或 $ set -o emacs
</code></pre>
<h2>切换目录/堆栈</h2>
<p>不管你cd到哪个了哪个目录, 想回到cd前的目录, 用<code>cd -</code>就行了
<code>pushd</code> , <code>popd</code>则可以把目录推到堆栈里, 演示:</p>
<pre><code>$ pushd 2
/test/1/2 /test/1
$ pushd 3
/test/1/2/3 /test/1/2 /test/1
$ pushd 4
/test/1/2/3/4 /test/1/2/3 /test/1/2 /test/1
$ dirs  # 其实每一次pushd都会把当前堆栈dirs出来
/test/1/2/3/4 /test/1/2/3 /test/1/2 /test/1
$ cd /tmp
$ dirs # 观察, cd其实只是把顶层给改了, 不会增减层级
/tmp /test/1/2/3 /test/1/2 /test/1
$ cd /usr
$ dirs  # 验算
/usr /test/1/2/3 /test/1/2 /test/1
</code></pre>
<p>现在你知道 了, cd永远只是更改顶栈, 大多数情况下, 你可以用<code>pushd</code>来替换<code>cd</code>, 这样你就有了<em>后退权</em>了
此时你再<code>popd</code>, 目录会顺利切到<code>/test/1/2/3</code>, 不管你进行过多少次<code>cd</code>, 第二层都不会变并且能直接<code>pop</code>出来
$小练习$
如果你查看堆栈, 要从第4个开始后退(0为起始), 那么可以把从3开始(不是4)的记录提到顶层来(然后再<code>popd</code>):
<code>$ pushd +3</code> (加号不可省)</p><blockquote>
<p>注意, 此时0, 1, 2都还在, 只是挪到了尾巴</p></blockquote>
<p>而<code>popd +3</code>则不是”<strong>移动</strong>”, 而是<strong>删除</strong>了, 意思是正向删除<strong>第</strong>3个, 如果不带<code>+</code>, 则理解为删除3<strong>以后</strong>的所有堆栈(即从4开始)</p><blockquote>
<p>注意: 为什么要从第4个开始退要把从3开始的移到顶层呢?</p></blockquote>
<p>因为如下<code>dirs: /1, /2, /3</code> , 你做<code>popd</code>, 是会回到/2的
可见顶栈永远表示的是&quot;当前&quot;目录. 所以你自然无法<strong>跳到</strong>当前目录.
而<code>pushd</code>, <code>popd</code>+<code>数字</code>改动的只是堆栈表, 不是目录, 即虽然你的目录没变, 但是系统<strong>认为</strong>你在第三层, 这个时候再后退(<code>popd</code>)自然到了目录表里的下一层<code>/4</code>.</p><h2>脚本</h2>
<p>shebang行<code>#!/usr/bin/env bash</code> 的写法是为了避免<code>#!/bin/bash</code> 这种写法时bash不在bin目录
<code>source</code>命令可以 用一个点来表示: <code>. ~/.bash_profile</code>
读用户的输入:</p>
<pre><code>$ read firstname lastname
$ “you input: $firstname, $lastname” # 如果read后没有给变量名, 则由默认的$REPLY来取出
</code></pre>
<p>读文件:</p>
<pre><code>while read myline  # 每次读一行
do
  echo &quot;$myline&quot;
done &lt; $filename  # 注意这里特殊的传参方式, 同时, 如果不传入文件路径, 就是一个无限循环了(read)
</code></pre>
<p>存数组:</p>
<pre><code>$ read -a varname. #  -a 参数把用户的多个输入全存到`varname`这个数组里了
</code></pre>
<p>其它有用的:</p>
<pre><code># -e 参数使得用户在输入的时候能用tab补全(包含所有readline库快捷键),
# 如果没有这个参数输入文本的时候是不能使用快捷键的
$ read -e -p “please input the path to the file” 
# -s 可以隐藏用户的输入, 通常用于密码
$ read -s  -p “input password”
# -p 显然就是能直接显示输入前的提示了
</code></pre>
<h2>条件判断</h2>
<p><code>if</code>里面的<code>test</code>命令
<code>test expression</code>, <code>[ expression]</code>, <code>[[ expression ]]</code> 是等价的(<em>第三种</em>支持正则)  <strong>空格不能省</strong>
<code>[ -? file ]</code> 查看文件状态有非常多的表达式(参数), 具体参阅<a href="https://wangdoc.com/bash/condition.html">https://wangdoc.com/bash/condition.html</a> 推荐阅读
for循环
<code>for [ test ] in list; do … done</code> 其中的<code>in list</code>如果省略, 则代表所有脚本参数<code>”$@“</code>:</p>
<pre><code>$ for filename; do echo “$filename”; done
# 等同于
$ for filename in “$@“; do echo “$filename”; done
</code></pre>
<p>同理, 如果是用在<strong>函数中</strong>, 则等于所有函数参数.
用双括号, 变量也无需加<code>$</code>了
<code>for (( i=0; i&lt;5; i+=1 )); do echo $i; done</code>
<code>case in</code>, 如果希望一个匹配后继续做下一个匹配(<code>passthrough</code>), 每一个case 的结尾用<code>;;&amp;</code>而不是<code>;;</code> (多了一个&amp;)</p><h2>select</h2>
<p>select生成的菜单, 选择并执行命令后, 要自行在<code>do-done</code>体内用<code>break</code>退出, 否则会一直要你选择</p><h2>数组</h2>
<p>以下方式声明数组</p>
<pre><code>$ names=(hatter [5]=duchess Alice), 指定了0, 5, 6, 其它为空字符串
$ mp3s=( *.mp3 )
$ declare -a ARRAYNAME
$ read -a ARRAYNAME
</code></pre>
<p>读取的时候: <code>$ echo ${array[1]}</code> 大括号不可省
<code>@</code>仍然是返回所有元素: <code>$ echo ${array[@]}</code> 但是在<code>for…in</code>中, 要把整个表达式放双引号中:</p>
<pre><code>$ activities=( swimming &quot;water skiing&quot; canoeing &quot;white-water rafting&quot; surfing )
$ for act in “${activities[@]}”; do….; done
</code></pre>
<p>不然其中有”water”, “skiing”,”white-water&quot;, rafting”等都会被拆开(<em>bug吧? 字符串也拆</em>)
把<code>@</code>换成<code>*</code>, 加上双引号, 则会一个个字符返回
拷贝数组最方便的方法:</p>
<pre><code>$ hobbies=( “${activities[@]}” diving ) # 顺便演示了为数组添加成员
</code></pre>
<p>直接赋值给一个数组(即没有指定索引), 则是赋给<strong>第0个组员</strong>, 同理, <strong>使用</strong>数组名也是使用的0号组员</p>
<pre><code># 以下@可以换成*
$ echo ${#array[@]} # #仍然用以计数, 但是如果传的是具体索引, 则返回的是对应项的字符串长度
$ echo ${!array[@]} 用以返回有值的索引 (为空的不返回) # 活用的话遍历数组更高效
$ echo ${array[@]:2:3} # 切片
$ arr+=(3 4 5) # 追加
$ unset arr[2] # 删除 , 或: 
$ arr[2]= # 或
$ arr[2]=‘’
# 以上三者等效, 
</code></pre>
<p>根据上面知识<code>$ arr=</code> 表示删除第一个成员, 但是<code>unset arr</code> 则是清空整个数组了
也可以用<strong>字符串</strong>做索引, 就成了字典了:</p>
<pre><code>$ declare -A colors  # 变成大写即可
$ colors[“red”]=“#ff0000”
</code></pre>
<h2>set命令</h2>
<p>单独一个set会显示所有环境变量和Shell函数
以下都可以以<code>set -xxx</code> 的方式写在<strong>脚本头</strong>或<strong>任何位置</strong>, 就当一个即时开关使用吧
也可以在调用bash脚本前传入比如: <code>bash -eux script.sh</code>
<code>-u</code>: 遇到不存在的变量就报错, 而不是忽略 与 <code>-o nounset</code> 等价
<code>-x</code>: 每一个命令执行前会先打印出来 等同于 <code>-o xtrace</code>, 关闭用<code>set +x</code> (组合起来用就是一个小环境)
<code>-e</code>: 有错误就中止 等同于 <code>-o errexit</code>
<code>-o pipefail</code>: 即使在管道中, 有错也中止(-e 在管道中会失效)
<code>-n</code>: <code>-o noexec</code> 不执行命令只检查语法
<code>-f</code>: <code>-o noglob</code> 不对通配符进行文件名(路径)扩展  可用+f 关闭
<code>-v</code>: <code>-o verbose</code> 打印shell接收到的每一行输入     可用+v 关闭
$ set -euxo pipefail 一般这么四个连用</p><h2>shopt</h2>
<p>即: shell option
同set, 直接shopt也可以列出所有参数, <code>-s</code>, <code>-u</code>分别是是打开, 关闭某个参数
<code>shopt 参数名</code>, 可直接查询该参数是否打开关闭, 但是如果是用于编程, 因为返回是字符串不好判断, 所以提供了<code>-q</code>参数(返回0/1, 分别表示打开/关闭)</p>
<pre><code>$ if shopt -q globstar; then …; fi
</code></pre>
<h2>除错</h2>

<pre><code># 先看目录存不存在, 然后再进入, 然后再打印出来将要删除的文件, 
# 这是最安全的删除方法
# 否则一旦目录不存在, 不同的写法会有不同的问题
[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; echo rm *  
</code></pre>
<p>如果在执行bash脚本前加入<code>-x</code>参数, 则每一条命令<strong>执行前</strong>都会打印出来 # 等同于<code>set -x</code></p><blockquote>
<p>或者写在脚本的shebang行里也行</p></blockquote>
<p>每一条命令会同上一个<strong>标识符</strong>作前缀, 默认是<code>+</code>, 可以用<code>export PS4=‘$LINENO +’</code>这种方式自定义(比如现在就加上了行号)
$几个环境变量$
<code>$LINENO</code>: 这个变量在哪, 打印的就是这一行的行号
<code>$FUNCNAME</code>: 返回一个数组, 函数调用的名称堆栈, 最里层(即本函数)的是0
<code>$BASH_SOURCE</code>: 返回一个数组, 函数调用的脚本堆栈, 即每层调用的脚本是哪一个, 最里层(即本文件)的是0
<code>$BASH_LINENO</code>: 返回一个数组, 函数每一次被调用时在该脚本的行号, 同样也是从最里层开始
例:</p>
<pre><code>${BASH_SOURCE[1] = main.sh  # [0] 是文件本身, 所以要[1]
${BASH_LINENO[0] = 17  # 调用来源的行号  —&gt; 所以调用来源的行号的索引永远比调用来源(文件)的索引要小1
${FUNCNAME[0]} = hello  # 本方法(或者说”被调用的方法”)
</code></pre>
<p>上例代表在 main.sh的17行调用了hello()方法 
$小练习$</p>
<pre><code>#!/bin/bash
source lv2.sh   # 引入外部脚本
function lv1method()
{
    echo ---------lv1------------
    i=0
    for v in &quot;${BASH_LINENO[@]}&quot;; do
        echo &quot;bash_line_no[$((i++))]: $v&quot;
    done
    i=0
    for v in &quot;${FUNCNAME[@]}&quot;; do
        echo &quot;func_name[$((i++))]: $v&quot;
    done
    i=0
    for v in &quot;${BASH_SOURCE[@]}&quot;; do
        echo &quot;bash_source[$((i++))]: $v&quot;
    done
    lv2method # 调用外部脚本的方法
}
</code></pre>
<p>以上脚本, 多做几次嵌套,  打印出来看看索引之间的关系
输出:</p>
<pre><code>---------lv1------------
bash_line_no[0]: 5
bash_line_no[1]: 0
func_name[0]: lv1method
func_name[1]: main
bash_source[0]: lv1.sh
bash_source[1]: entry.sh
---------lv2------------
bash_line_no[0]: 21
bash_line_no[1]: 5
bash_line_no[2]: 0
func_name[0]: lv2method
func_name[1]: lv1method
func_name[2]: main
bash_source[0]: lv2.sh
bash_source[1]: lv1.sh
bash_source[2]: entry.sh
---------lv3------------
bash_line_no[0]: 19
bash_line_no[1]: 21
bash_line_no[2]: 5
bash_line_no[3]: 0
func_name[0]: lv3method
func_name[1]: lv2method
func_name[2]: lv1method
func_name[3]: main
bash_source[0]: lv3.sh
bash_source[1]: lv2.sh
bash_source[2]: lv1.sh
bash_source[3]: entry.sh
</code></pre>
<h2>临时文件</h2>
<p>安全的用法:</p>
<pre><code>trap 'rm -f &quot;$TMPFILE&quot;’ EXIT  # 退出时删除临时文件)
TMPFILE=$(mktemp) || exit 1  # 用mktemp命令建立临时文件可以只有本人能读, 如果失败就退出
echo &quot;Our temp file is $TMPFILE”
</code></pre>
<p>参数: 
<code>-d</code>: 创建的是目录
<code>-p</code>: 指定目录
<code>-t</code>: 指定模板
如 <code>mktemp -t aaa.XXXXXXX</code> 能生成<code>/tmp/aaa.yZ1HgZV</code>(与X个数相同)
<code>trap</code>是用来响应系统信号的, 如<code>ctrl+c</code>产生中断信号<code>SIGINT</code>
<code>$ trap -l</code> 列出所有信号(自己打印出来看看)
<code>trap</code>的格式: <code>$ trap [动作] [信号1] [信号2] ...</code>
<code>trap</code> 命令接的信号有如下</p><ul>
<li>HUP：编号1，脚本与所在的终端脱离联系。</li>
<li>INT：编号2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL：编号9，该信号用于杀死进程。</li>
<li>TERM：编号15，这是kill命令发出的默认信号。</li>
<li>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
<p>如果trap要执行多条命令, 可以封装到函数里, 命令的位置写函数:<code>$ trap func_name EXIT</code></p><h2>启动环境</h2>
<p>登录session依次启动如下脚本:</p><ul>
<li>/etc/profile</li>
<li>/etc/profile.d # 目录下的所有.sh文件</li>
<li>~/.bash_profile # 如果有, 则中止</li>
<li>~/.bash_login # 如果有, 则中止  此为C shell 初始化脚本</li>
<li>~/.profile # Bourne shell 和 Korn shell 初始化脚本</li>
</ul>
<p>通过<code>$ bash - -login</code> 参数, 可以强制执行以上脚本
非登录session</p><ul>
<li>/etc/bash.bashrc # 所有用户都执行</li>
<li>~/.bashrc # 当前用户的</li>
</ul>
<p>启动参数:
<code>-n</code>: 不执行脚本, 只检查语法
<code>-v</code>: 执行语句前先输出
<code>-x</code>: 执行语句后输出该语句</p><p><code>~/.bash_logout</code> 退出时要执行的命令
<code>$ include /etc/inputrc</code> 在<code>~/.inputrc</code>里加这一行, 可以在里面自定义快捷键</p><h2>命令提示符</h2>
<p>上面提到过<code>$PS4</code>能修改<code>set -x</code>时打印的每句语句前面的<code>+</code>号
命令提示符默认的<code>$</code>符号(<strong>根用户</strong>是<code>#</code>号)则可以用<code>$PS1</code>来修改, 怎么改参考<a href="https://wangdoc.com/bash/prompt.html"><a href="https://wangdoc.com/bash/prompt.html">https://wangdoc.com/bash/prompt.html</a></a>
<code>$PS2</code>表示的是输入时折行的提示符, 默认为<code>&gt;</code>
<code>$PS3</code>表示使用select命令时系统输入菜单的提示符</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/-bin-bash%E5%92%8C-bin-sh%E7%9A%84%E5%8C%BA%E5%88%AB/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/iOS%E5%B1%8F%E5%B9%95%E6%BB%9A%E5%8A%A8%E6%97%B6Timer%E4%BF%9D%E6%8C%81%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" target="_self">iOS屏幕滚动时Timer保持工作的几种方式</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/iOS%E5%B1%8F%E5%B9%95%E6%BB%9A%E5%8A%A8%E6%97%B6Timer%E4%BF%9D%E6%8C%81%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" target="_self">
                <time class="text-uppercase">
                    March 22 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>iOS当前线程的RunLoop在TableView等scrollView滑动时将DefaultMode切换到了<code>TrackingRunLoopMode</code>。因为Timer默认是添加在RunLoop上的<code>DefaultMode</code>上的，当Mode切换后Timer就停止了运行。
如这样:</p><div class="highlight"><pre><span></span><span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">withTimeInterval</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">repeats</span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">timer</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">dateFormatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DateFormatter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">dateFormatter</span><span class="p">.</span><span class="n">dateFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;HH:mm:ss&quot;</span><span class="w"></span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">timeLabel</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;\(dateFormatter.string(from: Date()))&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>本文记录如下四种方式:</p><ul>
<li>将NSTimer添加到当前线程所对应的RunLoop中的<code>commonModes</code>中。</li>
<li>通过Dispatch中的<code>TimerSource</code>来实现定时器。</li>
<li>是开启一个新的子线程，将NSTimer添加到这个子线程中的RunLoop中，并使用<code>DefaultRunLoopModes</code>来执行。</li>
<li>使用<code>CADisplayLink</code>来实现。</li>
</ul>
<h2>CommonModes</h2>
<div class="highlight"><pre><span></span><span class="n">override</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">super</span><span class="p">.</span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">withTimeInterval</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">repeats</span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">timer</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"></span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">dateFormatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DateFormatter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">dateFormatter</span><span class="p">.</span><span class="n">dateFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;HH:mm:ss&quot;</span><span class="w"></span>
<span class="w">        </span><span class="nb">self</span><span class="p">.</span><span class="n">timeLabel</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;\(dateFormatter.string(from: Date()))&quot;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">RunLoop</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">forMode</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="n">commonModes</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>子线程/异步 + DefaultMode</h2>
<div class="highlight"><pre><span></span><span class="n">override</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">super</span><span class="p">.</span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">().</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">withTimeInterval</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">repeats</span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">timer</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"></span>
<span class="w">            </span><span class="n">let</span><span class="w"> </span><span class="n">dateFormatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DateFormatter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="n">dateFormatter</span><span class="p">.</span><span class="n">dateFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;HH:mm:ss&quot;</span><span class="w"></span>
<span class="w">            </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="nb">self</span><span class="p">.</span><span class="n">timeLabel</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;\(dateFormatter.string(from: Date()))&quot;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">RunLoop</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span><span class="w"> </span><span class="n">forMode</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="n">defaultRunLoopMode</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RunLoop</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">run</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>DispatchTimerSource</h2>
<p>GCD的知识点</p><div class="highlight"><pre><span></span><span class="n">override</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">queue</span><span class="o">:</span><span class="w"> </span><span class="n">DispatchQueue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">()</span><span class="w">   </span><span class="c1">//也可以用mainQueue来实现</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DispatchSource</span><span class="p">.</span><span class="n">makeTimerSource</span><span class="p">(</span><span class="n">flags</span><span class="o">:</span><span class="w"> </span><span class="n">DispatchSource</span><span class="p">.</span><span class="n">TimerFlags</span><span class="p">(</span><span class="n">rawValue</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">queue</span><span class="o">:</span><span class="w"> </span><span class="n">queue</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UInt64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NSEC_PER_SEC</span><span class="w"></span>

<span class="w">    </span><span class="n">source</span><span class="p">.</span><span class="n">scheduleRepeating</span><span class="p">(</span><span class="n">deadline</span><span class="o">:</span><span class="w"> </span><span class="n">DispatchTime</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">uptimeNanoseconds</span><span class="o">:</span><span class="w"> </span><span class="n">UInt64</span><span class="p">(</span><span class="n">timer</span><span class="p">)),</span><span class="w"> </span><span class="n">interval</span><span class="o">:</span><span class="w"> </span><span class="n">DispatchTimeInterval</span><span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span><span class="w"> </span><span class="n">leeway</span><span class="o">:</span><span class="w"> </span><span class="n">DispatchTimeInterval</span><span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">dateFormatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DateFormatter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">dateFormatter</span><span class="p">.</span><span class="n">dateFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;HH:mm:ss&quot;</span><span class="w"></span>
<span class="w">    </span><span class="n">source</span><span class="p">.</span><span class="n">setEventHandler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">timeout</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">source</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">self</span><span class="p">.</span><span class="n">timeLabel</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;\(dateFormatter.string(from: Date()))&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">source</span><span class="p">.</span><span class="n">resume</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>CADisplayLink</h2>
<p>CADisplayLink可以添加到RunLoop中，RunLoop的每一次循环都会触发CADisplayLink所关联的方法。在屏幕不卡顿的情况下，每次循环的时间时1/60秒。</p><div class="highlight"><pre><span></span><span class="n">override</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">super</span><span class="p">.</span><span class="n">awakeFromNib</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">().</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">displayLink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CADisplayLink</span><span class="p">(</span><span class="n">target</span><span class="o">:</span><span class="w"> </span><span class="nb">self</span><span class="p">,</span><span class="w"> </span><span class="n">selector</span><span class="o">:</span><span class="w"> </span><span class="err">#</span><span class="n">selector</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">update</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">displayLink</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">RunLoop</span><span class="p">.</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">forMode</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="n">defaultRunLoopMode</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RunLoop</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">run</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">func</span><span class="w"> </span><span class="n">update</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">dateFormatter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DateFormatter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">dateFormatter</span><span class="p">.</span><span class="n">dateFormat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;HH:mm:ss&quot;</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;\(dateFormatter.string(from: Date()))&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">currentTime</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="w"></span>
<span class="w">        </span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">self</span><span class="p">.</span><span class="n">timeLabel</span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">currentTime</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>详细内容请<a href="https://mp.weixin.qq.com/s/amgKKHhOCJ10Mr-OBEQyjw">阅读原文</a></p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/iOS%E5%B1%8F%E5%B9%95%E6%BB%9A%E5%8A%A8%E6%97%B6Timer%E4%BF%9D%E6%8C%81%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/MacOS%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" target="_self">MacOS添加自启动脚本</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/MacOS%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" target="_self">
                <time class="text-uppercase">
                    March 21 2020
                </time>
            </a>
        </div>
        <div class="prism-content"><p>MacOS下添加自启动脚本有很多方法, 在一篇<a href="https://www.zhihu.com/question/22794908/answer/89421030">知乎文章</a>中了解到Launchd替代了过去的init, rc, init.d, rc.d, SystemStarter, inted/xinetd, watchdogd等, 建议用Launchd.
当然还有别的Automator, Apple Script等方式(底层未研究), 感兴趣的自己搜索, 我选择了直接Launchd, 结合so上的<a href="https://stackoverflow.com/a/13372744/1051235">这篇文章</a>:</p><ol>
<li>编写自己的脚本, 添加可执行权限<code>chmod a+x myscript.sh</code></li>
<li>编写Launchd配置文件(<code>.plist</code>文件)</li>
<li>结合上述两篇文章, 确定在系统启动还是用户启动时运行脚本, 我选择的是用户目录(<code>~/Library/LaunchAgents/</code>)</li>
<li>load这个配置: <code>launchctl load -w ~/Library/LaunchAgents/com.service.name.plist</code></li>
<li>登入登出测试, 或: <code>launchctl start com.service.name</code></li>
</ol>
<p>注:</p><ol>
<li>可执行脚本里的路径有空格需要转义</li>
<li>但plist文件里<code>&lt;string&gt;</code>标签里的目录如果有空格, 不需要转义</li>
<li><code>load</code>带<code>-w</code>参数参见<a href="https://apple.stackexchange.com/a/308421">这篇文章</a></li>
<li>如果出错, 运行<code>Console</code>应用查看日志, 或参考<a href="https://stackoverflow.com/a/48017581">这篇文章</a>, 定向日志输出文件</li>
</ol>
<p>即在<code>.plist</code>文件里添加:</p><div class="highlight"><pre><span></span><span class="nt">&lt;key&gt;</span>StandardOutPath<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;string&gt;</span>/var/log/mylog.log<span class="nt">&lt;/string&gt;</span>
</pre></div>
<p>附: <code>.plist</code>文件示例</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
    &lt;dict&gt;
    	&lt;key&gt;Label&lt;/key&gt;
    	&lt;string&gt;com.service.name&lt;/string&gt;
    	&lt;key&gt;ProgramArguments&lt;/key&gt;
    	&lt;array&gt;
    		&lt;string&gt;/path/to/my/script.sh&lt;/string&gt;
    	&lt;/array&gt;
    	&lt;key&gt;RunAtLoad&lt;/key&gt;
    	&lt;true/&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>如果执行的脚本就一句话, 你可能希望直接在<code>.plist</code>文件里运行, 而不是额外再多生成一个脚本吧? (<a href="https://superuser.com/a/285273">source</a>)</p>
<pre><code>&lt;key&gt;ProgramArguments&lt;/key&gt;
&lt;array&gt;
        &lt;string&gt;/bin/bash&lt;/string&gt;
        &lt;string&gt;-c&lt;/string&gt;
        &lt;string&gt;ls -1 | grep *.txt | echo &amp;gt; allTextFiles&lt;/string&gt;
&lt;/array&gt;
</code></pre>
<p>继续, 如果还想<a href="https://superuser.com/questions/36087/how-do-i-run-a-launchd-command-as-root">以root来执行脚本</a>, 综合起来, 我的实现如下:</p><div class="highlight"><pre><span></span>cp com.run.udp2raw.plist /Library/LaunchDaemons
<span class="nb">cd</span> /Library/LaunchDaemons
sudo launchctl load -w com.run.udp2raw.plist
sudo launchctl start com.run.udp2raw
</pre></div>
<p>其中<code>udp2raw</code>对应的命令是需要<code>root</code>权限的, 实测通过. 我选择的是<code>/Library/LaunchDaemons/</code></p><blockquote>
<p>注: 唯一要注意的地方, 就是最后两行, <code>load</code>和<code>start</code>命令都需要加<code>sudo</code>. 没有加的时候没有报错, 但是没有运行成功.</p></blockquote>
<p>附: folders and usage</p>
<pre><code>|------------------|-----------------------------------|---------------------------------------------------|
| User Agents      | ~/Library/LaunchAgents            | Currently logged in user
|------------------|-----------------------------------|---------------------------------------------------|
| Global Agents    | /Library/LaunchAgents             | Currently logged in user
|------------------|-----------------------------------|---------------------------------------------------|
| Global Daemons   | /Library/LaunchDaemons            | root or the user specified with the key UserName
|------------------|-----------------------------------|---------------------------------------------------|
| System Agents    | /System/Library/LaunchAgents      | Currently logged in user
|------------------|-----------------------------------|---------------------------------------------------|
| System Daemons   | /System/Library/LaunchDaemons     | root or the user specified with the key UserName
|------------------|-----------------------------------|---------------------------------------------------|
</code></pre>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/MacOS%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/page/4/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/6/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 AlanDecode</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>