<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "/b098f530e4b4a4a690a595806babc6a7.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="walker" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase link-active" href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/collectionview_diffable_datasource/" target="_self">Collection View With Diffable Datasource</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/collectionview_diffable_datasource/" target="_self">
                <time class="text-uppercase">
                    September 09 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这篇文章有</p><ul>
<li>collection view自定义布局的一些心得体会和查阅文档时的一些笔记</li>
<li>Compositional layout笔记 （少量）</li>
<li>diffable datasource笔记</li>
</ul>
<h1>Compositional Layout</h1>
<ul>
<li>Group 宽高给够（或estimate），Item固定大小，就成了一个FlowLayout</li>
<li>设定section垂直方向行为为滚动(分页，靠边等），则不会折行<ul>
<li><code>.continuousGroupLeadingBoundary</code> 的意思是如果一行摆不下，正常情况下会折行，这一行后面就会剩下空白，当你做成continous后，下一个元素也会排在空白后，而不是直接就接在后面了</li>
<li><code>.paging</code>和<code>.groupPageing</code>的区别则是一次滚动一页还是一个group</li>
</ul>
</li>
</ul>
<h1>Diffable Data Sources</h1>
<ul>
<li>A <em>diffable data source</em> stores a list of section and item <em>identifiers</em><ul>
<li>In contrast, a custom data source that conforms to <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasource"><code>UICollectionViewDataSource</code></a> uses <em>indices</em> and <em>index paths</em>, which aren’t stable.<ul>
<li>They represent the <strong>location</strong> of sections and items, which can change as the data source adds, removes, and rearranges the contents of a collection view.</li>
<li>相反Diffable Data Source却能根据identifier追溯到其location</li>
</ul>
</li>
</ul>
</li>
<li>To use a value as an identifier, its data type must conform to the <a href="https://developer.apple.com/documentation/swift/hashable"><code>Hashable</code></a> protocol.<ul>
<li>Hashing能让集合成为“键”，提供快速lookup能力<ul>
<li>比如set, dictionary, snapshot</li>
</ul>
</li>
<li>can determine the differences between its <strong>current</strong> snapshot and <strong>another</strong> snapshot.</li>
</ul>
</li>
</ul>
<h3>Define the Diffable Data Source</h3>
<div class="highlight"><pre><span></span><span class="p">@</span><span class="n">preconcurrency</span> <span class="p">@</span><span class="n">MainActor</span> <span class="kd">class</span> <span class="bp">UICollectionViewDiffableDataSource</span><span class="p">&lt;</span><span class="n">SectionIdentifierType</span><span class="p">,</span> <span class="n">ItemIdentifierType</span><span class="p">&gt;</span> <span class="p">:</span> <span class="bp">NSObject</span> <span class="k">where</span> <span class="n">SectionIdentifierType</span> <span class="p">:</span> <span class="nb">Hashable</span><span class="p">,</span> <span class="n">SectionIdentifierType</span> <span class="p">:</span> <span class="n">Sendable</span><span class="p">,</span> <span class="n">ItemIdentifierType</span> <span class="p">:</span> <span class="nb">Hashable</span><span class="p">,</span> <span class="n">ItemIdentifierType</span> <span class="p">:</span> <span class="n">Sendable</span>

<span class="c1">// 声明示例</span>
<span class="kd">private</span> <span class="kd">var</span> <span class="nv">recipeListDataSource</span><span class="p">:</span> <span class="bp">UICollectionViewDiffableDataSource</span><span class="p">&lt;</span><span class="n">RecipeListSection</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">.</span><span class="n">ID</span><span class="p">&gt;</span><span class="o">!</span>

<span class="kd">private</span> <span class="kd">enum</span> <span class="nc">RecipeListSection</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">main</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Recipe</span><span class="p">:</span> <span class="n">Identifiable</span><span class="p">,</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">title</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">prepTime</span><span class="p">:</span> <span class="nb">Int</span>   <span class="c1">// In seconds.</span>
    <span class="kd">var</span> <span class="nv">cookTime</span><span class="p">:</span> <span class="nb">Int</span>   <span class="c1">// In seconds.</span>
    <span class="kd">var</span> <span class="nv">servings</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">ingredients</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">directions</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">isFavorite</span><span class="p">:</span> <span class="nb">Bool</span>
    <span class="kd">var</span> <span class="nv">collections</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span>
    <span class="n">fileprivate</span> <span class="kd">var</span> <span class="nv">addedOn</span><span class="p">:</span> <span class="n">Date</span><span class="p">?</span> <span class="p">=</span> <span class="n">Date</span><span class="p">()</span>
    <span class="n">fileprivate</span> <span class="kd">var</span> <span class="nv">imageNames</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>section是枚举，枚举就是正整数</li>
<li>Recipe conforming to <code>Identifiable</code>，automatically exposes the associated type <a href="https://developer.apple.com/documentation/swift/identifiable/id-swift.associatedtype"><code>ID</code></a></li>
<li>整个<code>Recipe</code>结构体不必是<code>Hashable</code>的，因为存在Datasource和Snapshot里的仅仅只是<code>identifiers</code><ol>
<li>Using the <code>Recipe.ID</code> as the item identifier type for the <code>recipeListDataSource</code> means that the <strong>data source</strong>, and any <strong>snapshots</strong> applied to it, <strong>contains only</strong> <code>Recipe.ID</code> values and not the complete recipe data.</li>
</ol>
</li>
</ol>
<h3>Configure the Diffable Data Source</h3>
<div class="highlight"><pre><span></span><span class="c1">// Create a cell registration that the diffable data source will use.</span>
<span class="kd">let</span> <span class="nv">recipeCellRegistration</span> <span class="p">=</span> <span class="bp">UICollectionView</span><span class="p">.</span><span class="n">CellRegistration</span><span class="p">&lt;</span><span class="bp">UICollectionViewListCell</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">cell</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">recipe</span> <span class="k">in</span>
    <span class="c1">// 会带着cell对象，位置和应的数据源数据来请求配置当前cell </span>
    <span class="c1">// 这里进行了两种配置，</span>
    <span class="c1">// 1. 一种是对contentConfiguration进行配置（应该就是包了一层，没对cell暴露出来的subview直接进行设置）</span>
    <span class="kd">var</span> <span class="nv">contentConfiguration</span> <span class="p">=</span> <span class="bp">UIListContentConfiguration</span><span class="p">.</span><span class="n">subtitleCell</span><span class="p">()</span>
    <span class="n">contentConfiguration</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">recipe</span><span class="p">.</span><span class="n">title</span>
    <span class="n">contentConfiguration</span><span class="p">.</span><span class="n">secondaryText</span> <span class="p">=</span> <span class="n">recipe</span><span class="p">.</span><span class="n">subtitle</span>
    <span class="n">contentConfiguration</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="n">recipe</span><span class="p">.</span><span class="n">smallImage</span>
    <span class="n">contentConfiguration</span><span class="p">.</span><span class="n">imageProperties</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="n">contentConfiguration</span><span class="p">.</span><span class="n">imageProperties</span><span class="p">.</span><span class="n">maximumSize</span> <span class="p">=</span> <span class="n">CGSize</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">cell</span><span class="p">.</span><span class="n">contentConfiguration</span> <span class="p">=</span> <span class="n">contentConfiguration</span>

    <span class="c1">// 2. 这里就是直接对cell的subview来进行设置了，所以理论上上一节的内容应该也可以直接对cell来配置</span>
    <span class="k">if</span> <span class="n">recipe</span><span class="p">.</span><span class="n">isFavorite</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">image</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">systemName</span><span class="p">:</span> <span class="s">&quot;heart.fill&quot;</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">accessoryConfiguration</span> <span class="p">=</span> <span class="bp">UICellAccessory</span><span class="p">.</span><span class="n">CustomViewConfiguration</span><span class="p">(</span><span class="n">customView</span><span class="p">:</span> <span class="bp">UIImageView</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">image</span><span class="p">),</span> <span class="n">placement</span><span class="p">:</span> <span class="p">.</span><span class="n">trailing</span><span class="p">(</span><span class="n">displayed</span><span class="p">:</span> <span class="p">.</span><span class="n">always</span><span class="p">),</span> <span class="n">cell</span><span class="p">.</span><span class="n">accessories</span> <span class="p">=</span> <span class="p">[.</span><span class="n">customView</span><span class="p">(</span><span class="n">configuration</span><span class="p">:</span> <span class="n">accessoryConfiguration</span><span class="p">)]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cell</span><span class="p">.</span><span class="n">accessories</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Create the diffable data source and its cell provider.</span>
<span class="n">recipeListDataSource</span> <span class="p">=</span> <span class="bp">UICollectionViewDiffableDataSource</span><span class="p">(</span><span class="n">collectionView</span><span class="p">:</span> <span class="n">collectionView</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">collectionView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">identifier</span> <span class="p">-&gt;</span> <span class="bp">UICollectionViewCell</span> <span class="k">in</span>
    <span class="c1">// `identifier` is an instance of `Recipe.ID`. Use it to</span>
    <span class="c1">// retrieve the recipe from the backing data store.</span>
    <span class="kd">let</span> <span class="nv">recipe</span> <span class="p">=</span> <span class="n">dataStore</span><span class="p">.</span><span class="n">recipe</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">identifier</span><span class="p">)</span><span class="o">!</span>
    <span class="c1">// 这里既是传入注册cell的方法的地方，也是那个方法的handler里三个参数的来源</span>
    <span class="k">return</span> <span class="n">collectionView</span><span class="p">.</span><span class="n">dequeueConfiguredReusableCell</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="n">recipeCellRegistration</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">recipe</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>The <code>configureDataSource()</code> method creates a cell <strong>registration</strong> and provides a handler closure that <strong>configures each cell</strong> with data from a recipe.</li>
</ul>
<h3>Load the Diffable Data Source with Identifiers</h3>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">func</span> <span class="nf">loadRecipeData</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Retrieve the list of recipe identifiers determined based on a</span>
    <span class="c1">// selected sidebar item such as All Recipes or Favorites.</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">recipeIds</span> <span class="p">=</span> <span class="n">recipeSplitViewController</span><span class="p">.</span><span class="n">selectedRecipes</span><span class="p">?.</span><span class="n">recipeIds</span><span class="p">()</span>
    <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="c1">// Update the collection view by adding the recipe identifiers to</span>
    <span class="c1">// a new snapshot, and apply the snapshot to the diffable data source.</span>
    <span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="bp">NSDiffableDataSourceSnapshot</span><span class="p">&lt;</span><span class="n">RecipeListSection</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">.</span><span class="n">ID</span><span class="p">&gt;()</span>
    <span class="n">snapshot</span><span class="p">.</span><span class="n">appendSections</span><span class="p">([.</span><span class="n">main</span><span class="p">])</span>
    <span class="n">snapshot</span><span class="p">.</span><span class="n">appendItems</span><span class="p">(</span><span class="n">recipeIds</span><span class="p">,</span> <span class="n">toSection</span><span class="p">:</span> <span class="p">.</span><span class="n">main</span><span class="p">)</span>
    <span class="n">recipeListDataSource</span><span class="p">.</span><span class="n">applySnapshotUsingReloadData</span><span class="p">(</span><span class="n">snapshot</span><span class="p">)</span> <span class="c1">// 初始化用这个，reload代表完全重设</span>
    <span class="c1">// 更新的话用 apply(_:animatingDifferences:) 这样有动画</span>
<span class="p">}</span>
</pre></div>
<h3>Insert, Delete, and Move Items</h3>
<ul>
<li>To <strong>handle changes</strong> to a data collection, the app <strong>creates a new snapshot</strong> that represents the current state of the data collection and <strong>applies</strong> it to the diffable data source.</li>
<li>The data source <strong>compares</strong> its current snapshot with the new snapshot to <strong>determine the changes</strong>.</li>
<li>Then it performs the necessary inserts, deletes, and moves into the collection view based on those changes.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="bp">NSDiffableDataSourceSnapshot</span><span class="p">&lt;</span><span class="n">RecipeListSection</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">.</span><span class="n">ID</span><span class="p">&gt;()</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendSections</span><span class="p">([.</span><span class="n">main</span><span class="p">])</span> <span class="c1">// section是直接重建的，而不是从哪去retrieve一个, 因为它代表的是ID，只要值一致就行</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendItems</span><span class="p">(</span><span class="n">selectedRecipeIds</span><span class="p">,</span> <span class="n">toSection</span><span class="p">:</span> <span class="p">.</span><span class="n">main</span><span class="p">)</span> <span class="c1">// 这里是.main的全量数据，即增删后的结果集</span>
<span class="n">recipeListDataSource</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">animatingDifferences</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
</pre></div>
<ul>
<li>增删其实就是新建一个snapshot，datasource会根据identifiers来比较哪些多了哪些少了。<ul>
<li>因为只比较“数量“，所以只要用这些id去新建snapshot就可以了，不存在把旧的<strong>retrieve</strong>出来</li>
</ul>
</li>
</ul>
<h3>Update Existing Items</h3>
<ul>
<li>To handle changes to the properties of an <strong>EXISTING</strong> item, an app retrieves the <strong>current snapshot</strong> from the diffable data source and calls either <a href="https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot/3804468-reconfigureitems"><code>reconfigureItems(_:)</code></a> or <a href="https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot/3375783-reloaditems"><code>reloadItems(_:)</code></a> on the snapshot.  -&gt; then <code>Apply</code> to snapshot</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="n">recipeListDataSource</span><span class="p">.</span><span class="n">snapshot</span><span class="p">()</span>  <span class="c1">// 这次是retrieve了</span>
<span class="c1">// Update the recipe&#39;s data displayed in the collection view.</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">reconfigureItems</span><span class="p">([</span><span class="n">recipeId</span><span class="p">])</span> <span class="c1">// 传入identifier</span>
<span class="n">recipeListDataSource</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">animatingDifferences</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
</pre></div>
<ul>
<li>the data source invokes its cell provider closure,</li>
</ul>
<h3>Populate Snapshots with Lightweight Data Structures</h3>
<ul>
<li>对整个item对象做Hash，适用于快速建模，或数据源不会变更的场景（比如菜单）。<ul>
<li>因为item对象的任何属性变化都会被认为有过改动导致重绘，也会产生一些副作用，比如重绘之前的状态都会被清掉（如selected）</li>
</ul>
</li>
<li>实践中，不会对设置datasource的时候专门给个identifier集合，而数据源用别的集合，每次都是用identifier从集合里找item这种方式，而是重写item的hash方法和equal方法，让其只观察id字段</li>
</ul>
<h3>NSDiffableDataSourceSnapshot</h3>
<ul>
<li>A representation of <strong>the state of the data</strong> in a <code>view</code> at a <strong>specific point in time</strong>.</li>
<li>Diffable data sources use <em>snapshots</em> to provide data for collection views and table views.</li>
<li>You use a snapshot to set up the <strong>initial state</strong> of the data that a view displays, and you use snapshots to reflect <strong>changes to the data</strong> that the view displays.</li>
<li>The data in a snapshot is made up of the <strong>sections</strong> and <strong>items</strong><ul>
<li>Each of your sections and items must have unique identifiers that conform to the <a href="https://developer.apple.com/documentation/swift/hashable"><code>Hashable</code></a> protocol.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// Create a snapshot.</span>
<span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="bp">NSDiffableDataSourceSnapshot</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="n">UUID</span><span class="p">&gt;()</span>        

<span class="c1">// Populate the snapshot.</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendSections</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendItems</span><span class="p">([</span><span class="n">UUID</span><span class="p">(),</span> <span class="n">UUID</span><span class="p">(),</span> <span class="n">UUID</span><span class="p">()])</span>

<span class="c1">// Apply the snapshot.</span>
<span class="n">dataSource</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">animatingDifferences</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
</pre></div>
<h2>NSDiffableDataSourceSectionSnapshot</h2>
<ul>
<li><p>A representation of <strong>the state of the data</strong> in a <code>layout section</code> at a specific point in time.</p><ul>
<li>注意与<code>dataSourceSnapshot</code>定义的区别</li>
</ul>
</li>
<li><p>A section snapshot represents the data for a single section in a collection view or table view.</p></li>
<li><p>Through a section snapshot, you set up the <strong>initial state</strong> of the data that displays in an individual section of your view, and later <strong>update that data</strong>.</p></li>
<li><p>You can use section snapshots <strong>with</strong> or <strong>instead</strong> of an <a href="https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot"><code>NSDiffableDataSourceSnapshot</code></a></p></li>
<li><p>Use a section snapshot when you need precise management of the data in a section of your layout</p><ul>
<li>such as when the sections of your layout acquire their data from <strong>different sources</strong>.</li>
<li>不同的section来自不同的数据源的话，倾向于用sectionSnapshot</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">section</span> <span class="k">in</span> <span class="n">Section</span><span class="p">.</span><span class="n">allCases</span> <span class="p">{</span>
    <span class="c1">// Create a section snapshot</span>
    <span class="kd">var</span> <span class="nv">sectionSnapshot</span> <span class="p">=</span> <span class="bp">NSDiffableDataSourceSectionSnapshot</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;()</span>

    <span class="c1">// Populate the section snapshot</span>
    <span class="n">sectionSnapshot</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="s">&quot;Food&quot;</span><span class="p">,</span> <span class="s">&quot;Drinks&quot;</span><span class="p">])</span>
    <span class="n">sectionSnapshot</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="s">&quot;🍏&quot;</span><span class="p">,</span> <span class="s">&quot;🍓&quot;</span><span class="p">,</span> <span class="s">&quot;🥐&quot;</span><span class="p">],</span> <span class="n">to</span><span class="p">:</span> <span class="s">&quot;Food&quot;</span><span class="p">)</span>

    <span class="c1">// Apply the section snapshot</span>
    <span class="n">dataSource</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">sectionSnapshot</span><span class="p">,</span>
                     <span class="n">to</span><span class="p">:</span> <span class="n">section</span><span class="p">,</span>
                     <span class="n">animatingDifferences</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h1>苹果CollectionView教程文档</h1>
<p><strong>The Layout Object Controls the Visual Presentation</strong></p><ul>
<li>The layout object is solely responsible for determining the <strong>placement and visual styling</strong> of items within the collection view</li>
<li>do not confuse what a layout object does with the <code>layoutSubviews</code> method used to reposition child views inside a parent view.<ul>
<li>A layout object <strong>never</strong> touches the views it manages directly because it <strong>does not actually own</strong> any of those views.</li>
<li>it generates attributes that describe the location, size, and visual appearance of the cells, supplementary views, and decoration views in the collection view.</li>
<li>It is then the job of the collection view to apply those attributes to the actual view objects.</li>
<li>这就是需要提供两个代理方法的原因，一个提供view，一个提供布局配置</li>
</ul>
</li>
</ul>
<p><strong>Transitioning Between Layouts</strong></p><ul>
<li>The easiest way to transition between layouts is by using the <code>setCollectionViewLayout:animated:</code> method.</li>
<li>However, if you require control of the transition or want it to be interactive, use a <code>UICollectionViewTransitionLayout</code> object.</li>
<li>The <code>UICollectionViewTransitionLayout</code> class is a special type of layout that gets installed as the collection view’s layout object when transitioning to a new layout.<ul>
<li>With a transition layout object, you can have objects follow a <strong>non linear</strong> path, use a different <strong>timing algorithm</strong>, or move according to incoming touch events.</li>
</ul>
</li>
<li>The <code>UICollectionViewLayout</code> class provides <strong>several methods</strong> for <strong>tracking</strong> the transition between layouts.</li>
<li><code>UICollectionViewTransitionLayout</code> objects track the completion of a transition through the <code>transitionProgress</code> property.</li>
<li>As the transition occurs, your code updates this property <strong>periodically</strong> to indicate the completion percentage of the transition.</li>
</ul>
<p>通用流程：</p><ol>
<li>Create an instance of the standard class or your own custom class using the <code>initWithCurrentLayout:nextLayout:</code> method.</li>
<li>Communicate the progress of the transition by periodically modifying the <code>transitionProgress</code> property. Do not forget to invalidate the layout using the collection view’s <code>invalidateLayout</code> method after changing the transition’s progress.</li>
<li>Implement the <code>collectionView:transitionLayoutForOldLayout:newLayout:</code> method in your collection view’s delegate and return your transition layout object.</li>
<li>Optionally modify values for your layout using the <code>updateValue:forAnimatedKey:</code> method to indicate changed values relevant to your layout object. The stable value in this case is 0.</li>
</ol>
<p><strong>Customizing the Flow Layout Attributes</strong></p><ul>
<li>Flowlayout在一条线上排列元素，到达了边界就换行，新起一条线</li>
<li>元素大小可以通过<code>itemSize</code> 属性设置，如果大小不同，则通过<code>[collectionView:layout:sizeForItemAtIndexPath:](https://developer.apple.com/documentation/uikit/uicollectionviewdelegateflowlayout/1617708-collectionview)</code>代理方法设置</li>
<li>但是，同一行上不同的高度的cell会垂直居中排列，这点要注意</li>
<li><code>minimum spacing</code>设置的只是同一行元素的“最小间距”，如果布局的时候一行下一个元素放不下了，但是剩余的空间很多，这个一行的元素间距会拉大<ul>
<li>行间距同理，根据上一条描述，元素是垂直居中排列的，所以最小行间距设置的是上下两行间最高的元素的距离</li>
</ul>
</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/collectionview_diffable_datasource/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/calayer_mask/" target="_self">CALayer应用mask实现为文字部分涂抹</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/calayer_mask/" target="_self">
                <time class="text-uppercase">
                    July 14 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>先看效果，白底黑字，随着拖动，逐渐变成黑底白字（注：因为项目关系，效果是带着底色拖动，所以以这种效果来讲解，如果只是改文字颜色，就是只涂抹文字，会稍微简单一些，请触类旁通）</p><figure  style="flex: 106.89655172413794" ><img width="1116" height="522" src="/archives/assets/ffbec7d6d811b8fd6cca175ce25a294e.gif" alt="20220714161447"/></figure><p>思路：底层（白底黑字），表层（黑底白字），对表层应用蒙板，蒙板的frame由手势控制</p><figure class="vertical-figure" style="flex: 49.69230769230769" ><img width="646" height="650" src="/archives/assets/6f6838054b30d06ed348b1f6a24d1abf.png" alt="image-20220714193234444"/></figure><p>本质上是CALayer的mask，但我们先用两个UIView来实现一下，因为它直观且简单：</p><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="nb">super</span><span class="w"> </span><span class="n">viewDidLoad</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="c1">// create wrapper view 省略</span>

<span class="w">    </span><span class="c1">// 底层白底黑字</span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">whiteColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="bp">UILabel</span><span class="w"> </span><span class="o">*</span><span class="n">lbl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createLabel</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">lbl</span><span class="p">.</span><span class="n">textColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blackColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="w"> </span><span class="n">addSubview</span><span class="o">:</span><span class="n">lbl</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 表层黑底</span>
<span class="w">    </span><span class="bp">UIView</span><span class="w"> </span><span class="o">*</span><span class="n">cover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIView</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">cover</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blackColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cover</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="w"> </span><span class="n">addSubview</span><span class="o">:</span><span class="n">cover</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 白字</span>
<span class="w">    </span><span class="bp">UILabel</span><span class="w"> </span><span class="o">*</span><span class="n">lbl2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createLabel</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">lbl2</span><span class="p">.</span><span class="n">textColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">whiteColor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">cover</span><span class="w"> </span><span class="n">addSubview</span><span class="o">:</span><span class="n">lbl2</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// mask的width从0到100%</span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIView</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">blackColor</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">cover</span><span class="p">.</span><span class="n">maskView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">-</span> <span class="p">(</span><span class="bp">UILabel</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">createLabel</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">slidechanged:</span><span class="p">(</span><span class="bp">UISlider</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">sender</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sender</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>UIView当然本质上用的都是CALayer，那么我用CALayer改写会怎样呢？</p><p>结构：UIView黑底+CATextLayer Mask &gt; CAShapeLayer黑底 &gt; CATextLayer白字， 对<code>shapeLayer</code>应用mask</p><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nb">super</span><span class="w"> </span><span class="n">viewDidLoad</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create wrapper 省略</span>

<span class="w">  </span><span class="c1">// 底部文字，黑底+文字mask</span>
<span class="w">  </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">blackColor</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="n">bottom</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createTextLayer</span><span class="o">:</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bottom</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 顶部背景layer+顶部文字layer</span>
<span class="w">  </span><span class="bp">CAShapeLayer</span><span class="w"> </span><span class="o">*</span><span class="n">top</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CAShapeLayer</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">top</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="w">  </span><span class="c1">// 原本是黑底白字，后面解释为什么改成了红底</span>
<span class="w">  </span><span class="n">top</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="n">toptext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createTextLayer</span><span class="o">:</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">toptext</span><span class="p">.</span><span class="n">foregroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">top</span><span class="w"> </span><span class="n">addSublayer</span><span class="o">:</span><span class="n">toptext</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">layer</span><span class="w"> </span><span class="n">addSublayer</span><span class="o">:</span><span class="n">top</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CAShapeLayer</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">top</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">-</span> <span class="p">(</span><span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">createTextLayer:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="n">layer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CATextLayer</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">layer</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">layer</span><span class="p">.</span><span class="n">font</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">__bridge</span><span class="w"> </span><span class="n">CFTypeRef</span><span class="p">)[</span><span class="bp">UIFont</span><span class="w"> </span><span class="n">systemFontOfSize</span><span class="o">:</span><span class="mf">12.0f</span><span class="w"> </span><span class="n">weight</span><span class="o">:</span><span class="n">UIFontWeightHeavy</span><span class="p">];</span><span class="w">  </span><span class="c1">// 这里字号是无效的</span>
<span class="w">    </span><span class="n">layer</span><span class="p">.</span><span class="n">fontSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">73.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// 在这里设置字号</span>
<span class="w">    </span><span class="n">layer</span><span class="p">.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">@&quot;Hello WestWorld&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">layer</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>结果却得到这个：</p><figure  style="flex: 189.3491124260355" ><img width="1280" height="338" src="/archives/assets/41856510dfd32672a9312a09ce95245d.gif" alt="20220714180940"/></figure><p>黑底只剩下了黑边，观察到三个现象：</p><ol>
<li>对根layer进行mask，其sublayer都是被mask的</li>
<li>用文字对文字做mask，是会描边的（这一点做了额外几个测试证明了）</li>
<li>动画没有那么跟手（人在前面跑，魂在后面追），都有动量的感觉了，对比UIView的方案看看</li>
</ol>
<p>先来拣第二个软柿子捏，猜测用<code>CAShapeLayer</code>来做cover应该不会有描边，也就是说注释掉以下几行</p><div class="highlight"><pre><span></span><span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="n">toptext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createTextLayer</span><span class="o">:</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">frame</span><span class="p">];</span><span class="w"></span>
<span class="n">toptext</span><span class="p">.</span><span class="n">foregroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="n">top</span><span class="w"> </span><span class="n">addSublayer</span><span class="o">:</span><span class="n">toptext</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>效果如期望的那样，（这次没有描边了，所以就换了个颜色，不然白底白字就看不见了）</p><figure  style="flex: 200.32051282051282" ><img width="1250" height="312" src="/archives/assets/2594836c148deacd8a75f4b8fbd2ee29.gif" alt="20220714184942"/></figure><p>这次我们不用根layer做mask，添加一个层：</p><div class="highlight"><pre><span></span><span class="c1">// 底部文字，黑底+文字mask</span>
<span class="bp">CATextLayer</span><span class="w"> </span><span class="o">*</span><span class="n">bottom</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="w"> </span><span class="n">createTextLayer</span><span class="o">:</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span><span class="w"></span>
<span class="c1">// self.wrapper.backgroundColor = [UIColor blackColor];</span>
<span class="c1">// self.wrapper.layer.mask = bottom; </span>
<span class="c1">// 对根layer进行mask，会把sublayer全部mask了</span>
<span class="c1">// 所以添加一个layer</span>
<span class="bp">CAShapeLayer</span><span class="w"> </span><span class="o">*</span><span class="n">bottomShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CAShapeLayer</span><span class="w"> </span><span class="n">new</span><span class="p">];</span><span class="w"></span>
<span class="n">bottomShape</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span><span class="w"></span>
<span class="n">bottomShape</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">UIColor</span><span class="w"> </span><span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span><span class="w"></span>
<span class="n">bottomShape</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bottom</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">wrapper</span><span class="p">.</span><span class="n">layer</span><span class="w"> </span><span class="n">addSublayer</span><span class="o">:</span><span class="n">bottomShape</span><span class="p">];</span><span class="w"></span>
</pre></div>
<figure  style="flex: 181.14285714285714" ><img width="1268" height="350" src="/archives/assets/03ebfa11434ae205e656839d6c410f6b.gif" alt="20220714191352"/></figure><p>现在如愿以偿，整个结构也只有一个UIView了，相比UView的方案，显然在查看视图结构的时候要简化得多，（动画效果仍然是魂在后面追...），但是，这次仍然是文字对文字做mask，这次却没有描边了：</p><figure  style="flex: 268.01801801801804" ><img width="1190" height="222" src="/archives/assets/661881063d03936442e6722d2ad82063.png" alt="image-20220714191856600"/></figure><p>难道只有根layer上才会描？不继续探索了。</p><p>最后，解释一下对直接操作CALayer为什么反应还慢半拍呢？因为CALayer的大部分属性的改变是自带了动画的，在这个例子里得到了充分的证明。</p><p>补充一下全部用<code>CALayer</code>的结构
<figure  style="flex: 67.69662921348315" ><img width="964" height="712" src="/archives/assets/98c14a7ed3a8bfe08ed578b50521d239.png" alt=""/></figure></p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/calayer_mask/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/advanced-graphics-with-core-animation/" target="_self">Advanced Graphics With Core Animation 笔记</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/advanced-graphics-with-core-animation/" target="_self">
                <time class="text-uppercase">
                    June 25 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Core Animation</h1>
<p><a href="https://academy.realm.io/posts/tryswift-tim-oliver-advanced-graphics-with-core-animation/">Source</a></p><p><strong>Core Graphics</strong></p><ul>
<li>Core Animation is supposed to be the graphics system of the framework, but there is also Core Graphics.</li>
<li>Core Graphics is entirely done on the CPU, and cannot be performed on the GPU.<ul>
<li>Because it is an entirely CPU-bound operation</li>
</ul>
</li>
<li>you can <strong>combine</strong> it with Core Animation.<ul>
<li>You can use <code>Core Graphics</code> to create the actual bitmaps, and use <code>Core Animation</code> to display them to create some cool effects.</li>
</ul>
</li>
</ul>
<p><strong>Core Animation</strong></p><ul>
<li>It is comprised of a series of <strong>layout objects</strong>. &gt;&gt;&gt; typically <code>CALayer</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">import</span> <span class="nc">QuartzCore</span>

<span class="kd">let</span> <span class="nv">newLayer</span> <span class="p">=</span> <span class="bp">CALayer</span><span class="p">()</span>
<span class="n">newLayer</span><span class="p">.</span><span class="n">frame</span> <span class="p">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">newLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">().</span><span class="n">CGColor</span>
<span class="n">newLayer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="p">=</span> <span class="mi">10</span>
</pre></div>
<p><strong>UIKit</strong></p><ul>
<li>Everything you see when you look at a <code>UIView</code> is <strong>not</strong> being done on the <code>UIView</code> level, but by a <strong>backing layer</strong> attached to that view.</li>
<li>The layer is providing the <strong>visual content</strong>,</li>
<li><code>UIView</code> is providing <strong>other</strong> things:<ul>
<li>order layout functionality, touch recognition, guest recognizers.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="bp">UIView</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">var</span> <span class="nv">layer</span><span class="p">:</span> <span class="bp">CALayer</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><strong>为什么不让UIView直接继承CALayer</strong></p><ul>
<li>CALayer确实有自己的子类</li>
<li>它们可以插入UIView的subLayer中，并指定其为暴露的那个layer，这种设计决定了它需要有一个“容器&quot;</li>
<li>比如用一个渐变的layer子类来替换原来的layer:</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyGradientClass</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">class</span> <span class="nc">func</span> <span class="n">layerClass</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">AnyClass</span> <span class="p">{</span>
       <span class="k">return</span> <span class="bp">CAGradientLayer</span><span class="p">.</span><span class="kc">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>Mapping contents to CALayer: <code>someLayer.contents = someImage.CGImage</code><ul>
<li>the <code>.contents</code> property is <code>animatable</code></li>
</ul>
</li>
</ul>
<p>Scale (with <code>contentGravity</code> property):</p><figure  style="flex: 102.4390243902439" ><img width="1848" height="902" src="/archives/assets/faa855dd2861cf296eb2c4ef5e8cf430.png" alt="image-20220515014627253"/></figure><ul>
<li>场景一：屏幕向下拉，背景图越变越大（根据设置的填充和变形方式，以及容器的frame）</li>
<li>场景二：类似macOS的docker，鼠标（滑块/slider）在图标上滚过的时候放大，处理为一个滑块，和左右两个layer，分别设置了只显示左边或右边的<code>gravity</code></li>
</ul>
<figure  style="flex: 157.19844357976655" ><img width="1616" height="514" src="/archives/assets/76a10bc63cff42cdd20b5324358b5ce8.png" alt="image-20220515021047122"/></figure><blockquote>
<p>我本以为是两张页码背景图是<strong>重合</strong>的，根据滑块位置来“切”掉对应的左侧图和右侧图，但是显然这个方案是左右两个背景图是<strong>并列</strong>的，它同时改的两个图的frame(其实就是width加起来永远是100%)，然后设置resize的方案是让左边的从左显示起，右边的从中显示起就行了</p><p>但仔细一想，仍然可以理解为两张图是重合的，分别往左右两方去resize使得两张图的frame并不相交而已</p></blockquote>
<p>场景二的其它方案：</p><ul>
<li>Because this method leverages the GPU, it is incredibly performant.</li>
<li>There are other ways you could have gone about doing this.<ul>
<li>For example, using a masking layer, or doing it in Core Graphics.</li>
<li>But, because both of them would have leveraged the CPU, it would have been slower.</li>
</ul>
</li>
</ul>
<p><strong>Bitmap Sampling in CALayer</strong></p><ul>
<li>Core Animation also <strong>exposes settings</strong> that lets you configure which resizing resampling algorithms the GPU uses.</li>
<li>Whenever you change the size of a layer and the size <strong>no longer matches the original size</strong> of the bitmap mapped to it, resampling needs to be done to make sure it does not look <em>jagged</em> or <em>distorted</em>.<ul>
<li>By default, the sampling mode that Core Animation uses is called <strong>bilinear filtering</strong> (<code>kCAFilterLinear</code>), a simple linear interpolation between two pixels. (线性插值最快)</li>
<li>Sometimes, even bilinear filtering is too <code>slow</code>. If you are rapidly resizing a frame during animation, you might get stuttering.<ul>
<li>这时可以使用 nearest (<code>kCAFilterNearest</code>). Nearest mode completely <strong>disables</strong> pixel resampling.</li>
</ul>
</li>
<li>trilinear filtering (<code>kCAFilterTrilinear</code>) 则能提供最好的resampling质量，the GPU will generate <strong>differently sized versions</strong> of the same bitmap, and <strong>blend them together</strong> to create resizing of the texture in question.<ul>
<li>最慢，而且把CPU也拉进来了</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure  style="flex: 83.88030888030887" ><img width="1738" height="1036" src="/archives/assets/dd2c66a62f209303b9177f794efff8cc.png" alt="image-20220515023547309"/></figure><p>最近邻插值图像质量最差，但也最省资源最快速，用在动画切换场景（视频里演示了app退到桌面时，app的icon由当前app界面的截图逐渐变回logo的过程，这个截图显然就不需要高质量的图片）</p><ul>
<li>同时也暗示了在图片展示区域本来就很小时，也没必要应用高质量scale</li>
<li>或者动画相当快时，也尽量用最近邻插值</li>
</ul>
<p><strong>Masking CALayer Objects</strong></p><ul>
<li><p>让一个layer(<strong>A</strong>)成为另一个layer(<strong>B</strong>)的<code>mask</code>属性</p></li>
<li><p>A会被B(涂黑的区域)<code>clip</code>，同时仍然具有功能性，交互性，和动画性</p><figure  style="flex: 164.367816091954" ><img width="1144" height="348" src="/archives/assets/f395601e92129519e7383fb4a3e4b514.png" alt="涂黑就是不显示"/></figure></li>
</ul>
<figure  style="flex: 81.36574074074075" ><img width="1406" height="864" src="/archives/assets/37fbec26917db6079bb03b3ec2db28a3.png" alt="image-20220622143708966"/></figure><p><strong>Adding Shadows to CALayer</strong></p><p>The following code will <strong>indeed</strong> render a shadow. However, because the system has to do <strong>a per pixel</strong> comparison to work out the <strong>size</strong> of the shadow, it will be <strong>incredibly slow</strong> in terms of rendering and animation.</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myLayer</span> <span class="p">=</span> <span class="n">view</span><span class="p">.</span><span class="n">layer</span>
 <span class="n">myLayer</span><span class="p">.</span><span class="n">shadowColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">blackColor</span><span class="p">().</span><span class="n">CGColor</span>
 <span class="n">myLayer</span><span class="p">.</span><span class="n">shadowOpacity</span> <span class="p">=</span> <span class="mf">0.75</span>
 <span class="n">myLayer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="p">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
 <span class="n">myLayer</span><span class="p">.</span><span class="n">shadowRadius</span> <span class="p">=</span> <span class="mi">10</span>

<span class="c1">// IMPORTANT FOR PERFORMANCE</span>
<span class="kd">let</span> <span class="nv">myShadowPath</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">roundedRect</span><span class="p">:</span>
                     <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">cornerRadius</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>

<span class="n">myLayer</span><span class="p">.</span><span class="n">shadowPath</span> <span class="p">=</span> <span class="n">myShadowPath</span><span class="p">.</span><span class="n">CGPath</span>
</pre></div>
<p>As a result, whenever you are working with <strong>shadows in Core Animation</strong>, you should always make sure to set the <code>.shadowPath</code> property. This property will tell Core Animation in advance what the shape of the shadow will be, reducing render time.</p><p><strong>Transforming a CALayer</strong></p><ul>
<li>Core Animation also provides a transform property on <code>CALayer</code>.</li>
<li>Unlike the transform property on UIView, which is purely <strong>2D</strong>, the one on <code>CALayer</code> provides <strong>3D</strong> transformations.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myLayer</span> <span class="p">=</span> <span class="bp">CALayer</span><span class="p">()</span>
<span class="n">myLayer</span><span class="p">.</span><span class="n">contents</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">makeTrySwiftLogoImage</span><span class="p">().</span><span class="n">CGImage</span>

<span class="kd">var</span> <span class="nv">transform</span> <span class="p">=</span> <span class="n">CATransform3DIdentity</span>
<span class="n">transform</span><span class="p">.</span><span class="n">m34</span> <span class="p">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="o">-</span><span class="mi">500</span>
<span class="n">transform</span> <span class="p">=</span> <span class="n">CATransform3DRotate</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="mf">45.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">myLayer</span><span class="p">.</span><span class="n">transform</span> <span class="p">=</span> <span class="n">transform</span>
</pre></div>
<p><strong>Blend Modes with CALayer</strong></p><p>看看就好</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myBlendLayer</span> <span class="p">=</span> <span class="bp">CALayer</span><span class="p">()</span>
<span class="n">myBlendLayer</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">allowsGroupBlending</span><span class="err">”</span><span class="p">)</span> <span class="c1">// PRIVATE</span>
<span class="n">myBlendLayer</span><span class="p">.</span><span class="n">compositingFilter</span> <span class="p">=</span> <span class="err">“</span><span class="n">screenBlendMode</span><span class="s">&quot;</span>
<span class="s">myBlendLayer.allowsGroupOpacity = false</span>
<span class="s">myLayer.addSublayer(myBlendLayer)</span>
</pre></div>
<figure  style="flex: 189.568345323741" ><img width="1054" height="278" src="/archives/assets/333bf0036824a4c48a4badd2371474bd.png" alt="image-20220622145432815"/></figure><p>苹果的&quot;slide to unlick&quot;重度应用了blend mode(注意那道左右跑动的流光)</p><figure  style="flex: 95.98997493734336" ><img width="1532" height="798" src="/archives/assets/98de775b5e16920acd97bd71e0a154d9.png" alt="image-20220622145619139"/></figure><p><strong>Animating with Core Animation</strong></p><p>UIView实现方式：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">trySwiftLayer</span> <span class="p">=</span> <span class="c1">//...</span>

<span class="kd">let</span> <span class="nv">myAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">(</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">“</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="err">”</span><span class="p">)</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="p">=</span> <span class="mi">2</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">fromValue</span> <span class="p">=</span> <span class="n">trySwiftLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="p">=</span> <span class="n">trySwiftLayer</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">500</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="p">=</span> <span class="n">kCAMediaTimingFunctionEaseInEaseOut</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">repeatCount</span> <span class="p">=</span> <span class="p">.</span><span class="n">infinity</span>

<span class="n">trySwiftLayer</span><span class="p">.</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">myAnimation</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">myAnimationKeyName</span><span class="err">”</span><span class="p">)</span>
</pre></div>
<ul>
<li>You can access these animations from the <code>.animationsKeys</code> property of the layer.</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// timing function</span>
<span class="kd">let</span> <span class="nv">timingFunction</span> <span class="p">=</span> <span class="bp">CAMediaTimingFunction</span><span class="p">(</span><span class="n">controlPoints</span><span class="p">:</span> <span class="p">.</span><span class="mi">08</span><span class="p">,</span> <span class="p">.</span><span class="mi">04</span><span class="p">,</span> <span class="p">.</span><span class="mi">08</span><span class="p">,</span> <span class="p">.</span><span class="mi">99</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">myAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">()</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="p">=</span> <span class="n">timingFunction</span>
</pre></div>
<ul>
<li><p>资源: <a href="http://cubic-bezier.com/"><a href="http://cubic-bezier.com">http://cubic-bezier.com</a></a></p></li>
<li><p>如果你要实现一个<code>cross fade</code>的效果，可能想的是两个view，同时切换alpha由0到1（和相反）</p><ul>
<li>当同时达到0.5时，人眼能捕捉到这一刻，两个图片都非常明显</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// animating a calayer&#39;s contents</span>
<span class="kd">let</span> <span class="nv">imageView</span> <span class="p">=</span> <span class="bp">UIImageView</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">onImage</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">offImage</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">()</span>

<span class="kd">let</span> <span class="nv">myCrossfadeAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">(</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">“</span><span class="n">contents</span><span class="err">”</span><span class="p">)</span>
<span class="n">myCrossfadeAnimation</span><span class="p">.</span><span class="n">fromValue</span> <span class="p">=</span> <span class="n">offImage</span><span class="p">.</span><span class="n">CGImage</span>
<span class="n">myCrossfadeAnimation</span><span class="p">.</span><span class="n">toValue</span> <span class="p">=</span> <span class="n">onImage</span><span class="p">.</span><span class="n">CGImage</span>
<span class="n">myCrossfadeAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="p">=</span> <span class="mf">0.15</span>

<span class="n">imageView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">myCrossfadeAnimation</span><span class="p">,</span>
                               <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">myCrossfadeAnimationKeyName</span><span class="err">”</span><span class="p">)</span>

<span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="n">onImage</span>
</pre></div>
<p><strong>CAKeyframeAnimation</strong></p><ul>
<li>you can chain up multiple animation points within one object(本文未阐述).</li>
<li>each keyframe point can have a <code>CG path object</code> assigned, which lets you create animations that are not just linear, point-to-point transitions, but curves.</li>
</ul>
<p>就是你要让view按一个cgpath做移动动画，也可以用<code>CAKeyframeAnimation</code></p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">rect</span> <span class="p">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">circlePath</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalInRect</span><span class="p">:</span><span class="n">rect</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">circleAnimation</span> <span class="p">=</span> <span class="bp">CAKeyframeAnimation</span><span class="p">()</span>
<span class="n">circleAnimation</span><span class="p">.</span><span class="n">keyPath</span> <span class="p">=</span> <span class="err">“</span><span class="n">position</span><span class="err">”</span>
<span class="n">circleAnimation</span><span class="p">.</span><span class="n">path</span> <span class="p">=</span> <span class="n">circlePath</span><span class="p">.</span><span class="n">CGPath</span>
<span class="n">circleAnimation</span><span class="p">.</span><span class="n">duration</span> <span class="p">=</span> <span class="mi">4</span>

<span class="c1">// Manually specify keyframe points</span>
<span class="c1">// circleAnimation.values = //...</span>
<span class="c1">// circleAnimation.keyTimes = //..</span>

<span class="kd">let</span> <span class="nv">trySwiftLayer</span> <span class="p">=</span> <span class="c1">//...</span>
<span class="n">trySwiftLayer</span><span class="p">.</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">circleAnimation</span><span class="p">,</span>
                            <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">position</span><span class="err">”</span><span class="p">)</span>
</pre></div>
<p><strong>CAAnimationGroup</strong></p><p>没多说什么，一个简单应用：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myPositionAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">.</span><span class="n">animation</span><span class="p">(</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">“</span><span class="n">position</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">myAlphaAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">.</span><span class="n">animation</span><span class="p">(</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">“</span><span class="n">opacity</span><span class="err">”</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">animationGroup</span> <span class="p">=</span> <span class="bp">CAAnimationGroup</span><span class="p">()</span>
<span class="n">animationGroup</span><span class="p">.</span><span class="n">timingFunction</span> <span class="p">=</span> <span class="n">kCAMediaTimingFunctionEaseInEaseOut</span>
<span class="n">animationGroup</span><span class="p">.</span><span class="n">duration</span> <span class="p">=</span> <span class="mi">2</span>
<span class="n">animationGroup</span><span class="p">.</span><span class="n">animations</span> <span class="p">=</span> <span class="p">[</span><span class="n">myPositionAnimation</span><span class="p">,</span> <span class="n">myAlphaAnimation</span><span class="p">]</span>

<span class="kd">let</span> <span class="nv">trySwiftLayer</span> <span class="p">=</span> <span class="bp">CALayer</span><span class="p">()</span>
<span class="n">trySwiftLayer</span><span class="p">.</span><span class="n">addAnimation</span><span class="p">(</span><span class="n">animationGroup</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">myAnimations</span><span class="err">”</span><span class="p">)</span>
</pre></div>
<p><strong>Completion Handling</strong></p><div class="highlight"><pre><span></span><span class="c1">// Set a delegate object</span>
<span class="kd">let</span> <span class="nv">myAnimation</span> <span class="p">=</span> <span class="bp">CABasicAnimation</span><span class="p">()</span>
<span class="n">myAnimation</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>

<span class="c1">// Animation completion sent to ‘animationDidStop(anim: finished flag:)</span>

<span class="c1">// ———</span>

<span class="c1">//Set a closure to be executed at the end of this transaction</span>
<span class="bp">CATransaction</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span>

<span class="bp">CATransaction</span><span class="p">.</span><span class="n">setCompletionBlock</span><span class="p">({</span>
   <span class="c1">// Logic to be performed, post animation</span>
<span class="p">})</span>

<span class="bp">CATransaction</span><span class="p">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
<p><strong>Features of Core Animation Subclasses</strong></p><p>本节内容可看一个更好的<a href="https://www.raywenderlich.com/10317653-calayer-tutorial-for-ios-getting-started">RayWenderlich教程</a></p><p>In iOS, Apple provides a variety of CLS subclasses, with many different features.</p><ul>
<li>Some of these subclasses rely on the CPU for the operations which they perform; it may be necessary to test these on certain devices to make sure they fill your specific needs.</li>
<li>To insert a CLS subclass into a UIView, all you need to do is subclass the UIView, and then override its layer class property.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyGradientClass</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
  <span class="kr">override</span> <span class="kd">class</span> <span class="nc">func</span> <span class="n">layerClass</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">AnyClass</span> <span class="p">{</span>
    <span class="k">return</span> <span class="bp">CAGradientLayer</span><span class="p">.</span><span class="kc">self</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>CATileLayer, 基于矢量绘图的层，可以无限放大</li>
<li>CAgradientLayer 运行在GPU上，非常快，通常用在用了3D变形的Layer场景，添加景深投影等效果</li>
<li>CAReplicaterLayer 一个可以被复制多次的layer（on the GPU），而且复制产物还能更改自己的颜色，位置等</li>
<li>CAShapeLayer 拥有一个<code>CGPath</code>属性很容易进行fill, stroke等绘制，参考<a href="https://github.com/UrbanApps/UAProgressView">UAProgressView</a>项目应用</li>
<li>CAEmitterLayer 参考一个<a href="https://itunes.apple.com/es/app/particle-playground/id600661093?l=en&amp;mt=12">Partical Playground</a>的Mac app，能够“发射”出其它的layer，并animat它</li>
<li>CATextLayer</li>
<li>CAScrollayer</li>
<li>CATransformLayer</li>
<li>CAEAGLayer, CAMetalLayer</li>
</ul>
<p><strong>资源</strong></p><ul>
<li><a href="http://www.paintcodeapp.com/">PaintCode</a>,为你创建的图片生成CoreGraphic代码</li>
<li><a href="http://www.coreanimator.com/">Core Animator</a>，为你创建的动画生成CoreAnimatioin代码</li>
<li><a href="(https://github.com/TimOliver/TOGlintyStringView)">slide to unlock 代码复现实例</a></li>
<li><a href="http://revealapp.com/">Reveal</a>，一个视图的线上debug工具</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/advanced-graphics-with-core-animation/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/js-spread-syntax/" target="_self">js spread syntax</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/js-spread-syntax/" target="_self">
                <time class="text-uppercase">
                    April 23 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>前段为这个解析api的dom元素生成的<a href="https://github.com/walkerwzy/code_generator">小工具</a>继confluence, swagger之后又增加了yapi的支持，用到了不少展开语法(<code>...</code>)，特整理记录一下</p><h1>Dictionary</h1>
<div class="highlight"><pre><span></span><span class="c1">// 得到字典所有key的方法：</span><span class="w"></span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">dict</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 得到字典所有key, value的方法： </span><span class="w"></span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">dict</span><span class="p">).</span><span class="nx">map</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">],</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">k</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 根据字段过滤：</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">filtered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">dict</span><span class="p">).</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">v</span><span class="o">&gt;</span><span class="mf">1</span><span class="p">));</span><span class="w"></span>
<span class="c1">// 或者用assign和spread syntax:</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">filtered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">dict</span><span class="p">).</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">v</span><span class="o">&gt;</span><span class="mf">1</span><span class="p">).</span><span class="nx">map</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({[</span><span class="nx">k</span><span class="p">]</span><span class="o">:</span><span class="nx">v</span><span class="p">}))</span><span class="w"></span>
</pre></div>
<h1>Array</h1>
<div class="highlight"><pre><span></span><span class="c1">// HTMLCollection to Array</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="w"> </span><span class="nx">htmlCollection</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">htmlCollection</span><span class="p">);</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Array</span><span class="p">.</span><span class="kr">from</span><span class="p">(</span><span class="nx">htmlCollection</span><span class="p">);</span><span class="w"></span>
<span class="kd">var</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">htmlCollection</span><span class="p">];</span><span class="w"></span>

<span class="c1">// remove duplicates (distinct)</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">chars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">uniqueChars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="ow">new</span><span class="w"> </span><span class="nb">Set</span><span class="p">(</span><span class="nx">chars</span><span class="p">)];</span><span class="w"></span>
</pre></div>
<h1>String</h1>
<div class="highlight"><pre><span></span><span class="c1">// 遍历一个数字的每一位</span><span class="w"></span>
<span class="p">[...</span><span class="mf">1e4</span><span class="o">+</span><span class="s1">&#39;&#39;</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>

<span class="c1">// 首字母大写</span><span class="w"></span>
<span class="kd">function</span><span class="w"> </span><span class="nx">capitalizeFirstLetter</span><span class="p">([</span><span class="nx">first</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">rest</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">first</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">rest</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>很有python的风格啊</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/js-spread-syntax/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cocoapods_private_library/" target="_self">CocoaPods创建私有库过程拾遗</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cocoapods_private_library/" target="_self">
                <time class="text-uppercase">
                    February 27 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>创建私有podspec</h1>
<p>完整教程网上很多，我这里是曲曲折折弄好后的一些要点记录，里面的一些路径和库共同自<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">某篇教程</a>，可以直接看他们的教程。</p><p>想看极简的骨架过程可以参考我下面的笔记，当然肯定缺少很多细节，主要是记录一下核心思路，里面的一些库地址出于隐私我就使用了他们公布在网上的而不是自己的真实地址。</p><p>首先，涉及两个仓库，一个放代码，一个放spec，放spec的就是私有库</p><div class="highlight"><pre><span></span><span class="c1"># 创建私有库 （就是host podspec文件的容器）</span>
pod repo add WTSpecs https://coding.net/wtlucky/WTSpecs.git  <span class="c1">#（这是spec仓库）</span>

<span class="c1">## 如果不是新建，删除和添加已有的语法：</span>
pod repo remove WTSpecs
pod repo add WTSpecs git@coding.net:wtlucky/WTSpecs.git

<span class="c1"># 创建pod lib（就是普通项目文件）</span>
pod lib create podTestLibrary
<span class="c1">### 可以选择尝试编辑一个组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下</span>

<span class="c1"># 推送lib到remote</span>
git add .
git commit -s -m <span class="s2">&quot;Initial Commit of Library&quot;</span>
git remote add origin git@coding.net:wtlucky/podTestLibrary.git  <span class="c1"># 添加远端仓库（这是代码仓库）</span>
git push origin master     <span class="c1"># 提交到远端仓库</span>

<span class="c1"># 打rag，推tag</span>
git tag -m <span class="s2">&quot;first release&quot;</span> <span class="m">0</span>.1.0
git push --tags     <span class="c1">#推送tag到远端仓库</span>

<span class="c1"># 编辑podspec</span>
<span class="c1">### 请查阅相关字段文档，注意编辑tag号与你推的tag号一致</span>
<span class="c1">### 特别注意</span>
<span class="c1">### source_files(源码路径，一般在在libNmae/Classes/**/*), </span>
<span class="c1">### resource_bundles(比如.bundle, .xcassets等)， </span>
<span class="c1">### public_header_files(可以理解为Umbrella Header), </span>
<span class="c1">### prefix_header_file(就是.pch文件)</span>

<span class="c1"># lint podspec（注意allow-warnings)</span>
pod lib lint  --allow-warnings 
<span class="c1">## 如果有私有源：</span>
pod lib lint --sources<span class="o">=</span><span class="s1">&#39;YourSource,https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&#39;</span>
<span class="c1">### 前面是私有源，逗号后是官方源，因为我电脑用的是清华源，这里干脆也了设成一致了（不是必要）</span>

<span class="c1"># 如果不是用pod创建的项目，自行创建podspec文件：</span>
 pod spec create PodTestLibrary git@coding.net:wtlucky/podTestLibrary.git  <span class="c1"># 注意仓库名和仓库地址</span>
</pre></div>
<p>本地测试podspec, in podfile:</p><div class="highlight"><pre><span></span><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">&#39;9.0&#39;</span>

<span class="c1"># 几种方式</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s1">&#39;~/code/Cocoapods/podTest/PodTestLibrary&#39;</span>      <span class="c1"># 指定路径</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="ss">:podspec</span> <span class="o">=&gt;</span> <span class="s1">&#39;~/code/Cocoapods/podTest/PodTestLibrary/PodTestLibrary.podspec&#39;</span>  <span class="c1"># 指定podspec文件</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1"># 向Spec Repo提交podspec(后面的参数是在消警告和错误的过程中加的，你可以尝试无参数先跑，碰到问题再逐个解决)</span>
pod repo push WTSpecs PodTestLibrary.podspec --allow-warnings --use-libraries --skip-import-validation --verbose
<span class="c1">### 完了后本地~/.cocoapods/repos和远端spec仓库都应该出现PodTextLibrary/0.1.0这个文件夹(对应你刚打的tag），里面有（且只有）刚才创建的podspec文件</span>
</pre></div>
<p>使用</p><div class="highlight"><pre><span></span><span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 0.1.0&#39;</span>
</pre></div>
<p><code>lib lint</code>和<code>repo push</code>过程中碰到一些问题导致validation失败的解决：</p><ul>
<li><p><code>--allow-warnings</code>, <code>--use-libraries</code>, <code>--skip-import-validation</code> 等参数灵活使用，目标就是为了通过验证</p></li>
<li><p><code>--no-clean</code> 可以在出错时打印更详细的信息（我加了<code>--verbose</code>后在build失败时会提示你加这个)</p></li>
<li><p>碰到有模块不支持i386什么的架构时，添加这个(<a href="https://blog.nowcoder.net/n/68dac16078184973ac061027817a2d9a?from=nowcoder_improve">更多看这篇文章</a>)：</p></li>
<li>
<pre><code>s.xcconfig = {
    'VALID_ARCHS' =&gt;  'x86_64 armv7 arm64',
  }
  s.pod_target_xcconfig = { 'ARCHS[sdk=iphonesimulator*]' =&gt; '$(ARCHS_STANDARD_64_BIT)' }
</code></pre>
</li>
<li><p><code>pod lint implicit declaration of function 'XXXX' is invalid in C99 [-Werror,-Wimplicit-function-declaration]</code> <a href="https://blog.csdn.net/cnwyt/article/details/105073749">看这里</a></p><ul>
<li>很奇怪的问题，我前面的依赖确实添加了该宏定义的模块`s.dependency 'xxxx' 我目前是在问题文件里重新define一次这个宏解决的，</li>
</ul>
</li>
</ul>
<h1>podspec 进阶</h1>
<div class="highlight"><pre><span></span><span class="c1"># [如果]每个子模块有自己的dependency, public headerfile, pchfile等</span>
<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;NetWorkEngine&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">networkEngine</span><span class="o">|</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/NetworkEngine/**/*&#39;</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/NetworkEngine/**/*.h&#39;</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;AFNetworking&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 2.3&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;DataModel&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">dataModel</span><span class="o">|</span>
    <span class="n">dataModel</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/DataModel/**/*&#39;</span>
    <span class="n">dataModel</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/DataModel/**/*.h&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;CommonTools&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">commonTools</span><span class="o">|</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/CommonTools/**/*&#39;</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/CommonTools/**/*.h&#39;</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;OpenUDID&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 1.0.0&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;UIKitAddition&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">ui</span><span class="o">|</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/UIKitAddition/**/*&#39;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/UIKitAddition/**/*.h&#39;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">resource</span> <span class="o">=</span> <span class="s2">&quot;Pod/Assets/MLSUIKitResource.bundle&quot;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;PodTestLibrary/CommonTools&#39;</span>
<span class="k">end</span>
</pre></div>
<p>体现为：</p><div class="highlight"><pre><span></span>$ pod search PodTestLibrary

-&gt; PodTestLibrary <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
   Just Testing.
   pod <span class="s1">&#39;PodTestLibrary&#39;</span>, <span class="s1">&#39;~&gt; 1.0.0&#39;</span>
   - Homepage: https://coding.net/u/wtlucky/p/podTestLibrary
   - Source:   https://coding.net/wtlucky/podTestLibrary.git
   - Versions: <span class="m">1</span>.0.0, <span class="m">0</span>.1.0 <span class="o">[</span>WTSpecs repo<span class="o">]</span>
   - Sub specs:
     - PodTestLibrary/NetWorkEngine <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/DataModel <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/CommonTools <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/UIKitAddition <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
</pre></div>
<p>使用：</p><div class="highlight"><pre><span></span><span class="n">source</span> <span class="s1">&#39;https://github.com/CocoaPods/Specs.git&#39;</span>  <span class="c1"># 官方库</span>
<span class="n">source</span> <span class="s1">&#39;https://git.coding.net/wtlucky/WTSpecs.git&#39;</span>   <span class="c1"># 私有库</span>
<span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">&#39;9.0&#39;</span>

<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary/NetWorkEngine&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>  <span class="c1">#使用某一个部分</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary/UIKitAddition&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>

<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>   <span class="c1">#使用整个库</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cocoapods_private_library/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/hittest/" target="_self">hitTest示例</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/hittest/" target="_self">
                <time class="text-uppercase">
                    February 19 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>往窗口里添加两个自定义的view，这样每个view的<code>hitTest</code>方法被访问的时候我们就能log一下：</p><div class="highlight"><pre><span></span><span class="kd">import</span> <span class="nc">UIKit</span>

<span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

        <span class="kd">let</span> <span class="nv">view1</span> <span class="p">=</span> <span class="n">View1</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="kd">let</span> <span class="nv">view2</span> <span class="p">=</span> <span class="n">View2</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">yellow</span>
        <span class="n">view2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">red</span>

        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view1</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View1</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;enter v1 </span><span class="si">\(</span><span class="n">point</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View2</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;enter v2, </span><span class="si">\(</span><span class="n">point</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>运行：</p><figure class="vertical-figure" style="flex: 46.42857142857143" ><img width="650" height="700" src="/archives/assets/5b4c2daa70dc2e8941de89fdb19c2bfa.png" alt="image-20220219014246803"/></figure><p>在空白处(<strong>bottom view</strong>)点了一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span>-48.66007995605469, <span class="m">306</span>.0133361816406<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">11</span>.339920043945312, <span class="m">366</span>.0133361816406<span class="o">)</span>
enter v2, <span class="o">(</span>-48.66007995605469, <span class="m">306</span>.0133361816406<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">11</span>.339920043945312, <span class="m">366</span>.0133361816406<span class="o">)</span>
enter v2, <span class="o">(</span>-43.33333333333334, <span class="m">325</span>.3333333333333<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">16</span>.666666666666657, <span class="m">385</span>.3333333333333<span class="o">)</span>
enter v2, <span class="o">(</span>-43.33333333333334, <span class="m">325</span>.3333333333333<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">16</span>.666666666666657, <span class="m">385</span>.3333333333333<span class="o">)</span>
</pre></div>
<p>在红框上(<strong>top view</strong>)点一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span><span class="m">38</span>.66666666666666, <span class="m">48</span>.66666666666666<span class="o">)</span>
enter v2, <span class="o">(</span><span class="m">38</span>.66666666666666, <span class="m">48</span>.66666666666666<span class="o">)</span>
</pre></div>
<p>在黄框(<strong>middle view</strong>)点一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span>-31.210678100585938, -27.8685302734375<span class="o">)</span>
enter v2, <span class="o">(</span>-31.210678100585938, -27.8685302734375<span class="o">)</span>
enter v2, <span class="o">(</span>-25.0, -22.333333333333343<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">35</span>.0, <span class="m">37</span>.66666666666666<span class="o">)</span>
enter v2, <span class="o">(</span>-25.0, -22.333333333333343<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">35</span>.0, <span class="m">37</span>.66666666666666<span class="o">)</span>
</pre></div>
<ul>
<li>我们知道<code>hitTest</code>机制是事件传递链由底向上，响应链由上到下，</li>
<li>所以最底层的<strong>bottom view</strong>最先接到事件就开始找响应者</li>
<li>它开始从它的最顶层subview开始找响应者(<code>v2</code>)，然后再往下(<code>v1</code>)，均没找到，所以就是自己了</li>
<li>为何调了四次呢？（未深究）<blockquote>
Yes, it’s normal. The system may tweak the point being hit tested between the calls. Since hitTest should be a pure function with no side-effects, this should be fine.</blockquote>
</li>
<li>第二次测试，直接在最顶层view就找到了（所谓的找到，就是点击的位置在这个view的bounds内，后面说）</li>
<li>至于为什么坐标会变？（未深究）</li>
<li>第三次测试，点了v1，可以看到日志，在v2那里跑了3次，再跑了v1，不知道为什么还是没返回，还跑了一次v2后才认定v1</li>
</ul>
<p>大体可以知道hitTest的机制了吧？以传递链的终点那个view为基础，在subviews逆向遍历（自顶向下），一直到自己。</p><h2>应用1</h2>
<p>来个简单场景，如果黄色的view是有触摸事件的，并且要求被覆盖的区域也能响应，该怎么做呢？</p><p>思考：</p><ul>
<li>我们知道点击的位置，肯定是在黄框范围内的，所以要的就是一个入口，用来判断这个点与黄框的关系，一旦确认点的范围是在黄框里，就把认为黄框是事件响应者。</li>
<li>因此改下demo，加了事件，还加了一个parent view（这样才能在用属性的方式把黄框引用出来）</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>


        <span class="kd">let</span> <span class="nv">view1</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="kd">let</span> <span class="nv">view2</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">yellow</span>
        <span class="n">view2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">red</span>

        <span class="kd">let</span> <span class="nv">tap</span> <span class="p">=</span> <span class="bp">UITapGestureRecognizer</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="kc">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">tap</span><span class="p">(</span><span class="kc">_</span><span class="p">:)))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">tap</span><span class="p">)</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">isUserInteractionEnabled</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="kd">let</span> <span class="nv">view</span> <span class="p">=</span> <span class="n">View</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">view1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">view2</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">tap</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;view1 taped&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View</span><span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">view1</span><span class="p">:</span> <span class="bp">UIView</span>
    <span class="kd">var</span> <span class="nv">view2</span><span class="p">:</span> <span class="bp">UIView</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="bp">UIView</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">UIView</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view1</span> <span class="p">=</span> <span class="n">a</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view2</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">required</span> <span class="kd">init</span><span class="p">?(</span><span class="n">coder</span><span class="p">:</span> <span class="bp">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">fatalError</span><span class="p">(</span><span class="s">&quot;init(coder:) has not been implemented&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nv">loc_v1</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">view1</span><span class="p">)</span>
          <span class="c1">// 主要就是这一句</span>
        <span class="k">if</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">view1</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">inside</span><span class="p">:</span> <span class="n">loc_v1</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">view1</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li><code>let loc_v1 = self.convert(point, to: self.view1)</code>意思是这个点以view1为坐标系的位置</li>
<li><code>if(self.view1.point(inside: loc_v1, with: event))</code> 这就是判断这个点在不在view1的bounds里面了</li>
</ul>
<p>简单来说，就是简单粗暴地“逮住每一个机会”，问是不是你，是不是你。</p><h2>应用2</h2>
<p>如果一个按钮很小，你要扩大他的点击区域怎么做？网上有很多方法，关联属性啊，交换方法啊，可以去搜搜，我们这里继续上面的例子，知道有一个<code>point(inside:with)</code>方法，顾名思义，就是这个点在不在我的视图区域内</p><p>它当然也是可以被重写，自定义在什么样的范围内，都算<code>inside</code>，下面是网上抄的一段代码</p>
<pre><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event {
   //获取当前button的实际大小
    CGRect bounds = self.bounds;
    //若原热区小于44x44，则放大热区，否则保持原大小不变
    CGFloat widthDelta = MAX(44.0 - bounds.size.width, 0);
    CGFloat heightDelta = MAX(44.0 - bounds.size.height, 0);
    //扩大bounds
    bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);
    //如果点击的点 在 新的bounds里，就返回YES
    return CGRectContainsPoint(bounds, point);
}
</code></pre>
<p>这个例子主要就是利用底层的<code>CGRectContainsPoint</code>方法，传入了新的<code>bounds</code>，可以理解为人为修改入参吧。代码也很明确了，自己根据当前的bounds合理做一个大一点的bounds，交给系统去做就行了。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/hittest/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Layer/" target="_self">Programming iOS 14 - Layer</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Layer/" target="_self">
                <time class="text-uppercase">
                    February 18 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第3章</p><hr />
<h1>Layers</h1>
<ul>
<li>A UIView does not actually <strong>draw itself</strong> onto the screen; it draws itself <strong>into its layer</strong>, and it is the layer that is portrayed on the screen.</li>
<li>a view is not <strong>redrawn</strong> frequently;</li>
<li>instead, its drawing is cached, and the cached version of the drawing (<code>the bitmap backing store</code>) is used where possible.</li>
<li>The cached version is, in fact, the <code>layer</code>.</li>
<li>the view’s graphics context is <code>actually</code> the layer’s graphics context.</li>
<li>a layer is the <code>recipient</code> and <code>presenter</code> of a view’s drawing</li>
<li>Layers are <code>made to be animated</code></li>
<li>View持有layer，是layer的代理（<code>CALayerDeletgate</code>）<ul>
<li>但layer不能找到View</li>
</ul>
</li>
<li>View的大部分属性都只是其<code>underlying layer</code>的便捷方法</li>
<li>layer能操控和改变view的表现，而无需ask the view to redraw itself</li>
</ul>
<p>自定义underlaying layer的方法</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">CompassView</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">class</span> <span class="nc">var</span> <span class="n">layerClass</span> <span class="p">:</span> <span class="nb">AnyClass</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">CompassLayer</span><span class="p">.</span><span class="kc">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>Layers and Sublayers</h2>
<ul>
<li><p>layer的继承树跟view的继承树几乎一致</p></li>
<li><p>layer的<code>masksToBounds</code>属性决定了能否显示sublayer超出了其bounds的部分，这也是view的<code>clipsToBounds</code>的平行属性</p></li>
<li><p><code>sublayers</code>是可写的，而<code>subviews</code>不是</p><ul>
<li>所以设为nil可以移除所有子层，但subview却需要一个个<code>removeFromSuperview</code></li>
</ul>
</li>
<li><p><code>zPostion</code>决定了层级（order），默认值都是0.0</p></li>
<li><p>a layer does not have a center靠<code>position</code>和<code>anchorPoint</code>定位</p><ul>
<li>position: 在superLayer中的位置</li>
<li>anchorPoint: 用小数表示的bound(宽/高)位置，左上(0, 0), 右下(1, 1)， default:(0.5, 0.5)</li>
<li>所以(0.5, 0.5)的anchorPoint，对应的<code>poosition</code>就等同于center了，理解一下<ul>
<li>其实就是说你的“锚点”在superLayer的什么位置的意思</li>
</ul>
</li>
<li>When you get the frame, it is calculated from the <code>bounds size</code> along with the <code>position</code> and <code>anchorPoint</code>.<ul>
<li>When you set the frame, you set the <code>bounds</code> size and <code>position</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// demo, 把一个80x40的layer，左上角放到(130, 120的位置）</span>
<span class="n">let</span><span class="w"> </span><span class="n">layer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="n">cgColor</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">130</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">120</span><span class="p">)</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
<blockquote>
<p>如果一个layer的position是(0, 0)，锚点是(0,0)，刚好显示在左上角
而（0.5，0.5)则只能显示右下角的1/4了
即(0.5, 0.5)到了原来(0,0)的位置。所以说其实就是把自身bounds度量下的哪个位置移到(0,0)</p></blockquote>
<p>这么说来，对锚点的最正确理解其实是，</p><ul>
<li>我把自身坐标系里的哪个点定义为原点，</li>
<li>并且，这个点移到原本“左上角”的位置（想象0.5,0.5)</li>
<li>并且，所有的旋转之类的动画本来是对“左上角”<strong>的位置</strong>进行的，不管现在这个位置是layer上的哪个部分<ul>
<li>或者说，旋转永远是发生在<code>position</code>上的，你把哪个点放到position上它不管</li>
</ul>
</li>
</ul>
<p>理解frame的小练习</p><div class="highlight"><pre><span></span><span class="c1">// 如果我设了layer的frame:</span>
<span class="n">circle</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"></span>

<span class="c1">// 实际上是通过size, position, anchorPoint来实现的：</span>
<span class="n">circle</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"></span>

<span class="c1">// 以左上角为anchorPoint</span>
<span class="n">circle</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">50</span><span class="p">)</span><span class="w"></span>
<span class="n">circle</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 或者，以中心为anchorPoint</span>
<span class="n">circle</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">150</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">150</span><span class="p">)</span><span class="w"></span>
<span class="n">circle</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mf">0.5</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 或者其它任意anchorPoint，前提是自己换算</span>
<span class="c1">// 而且，虽然位置是一样的，但会影响transform</span>
</pre></div>
<p><strong>CAScrollLayer</strong></p><ul>
<li>你想通过移动layer的bounds来重定位sublayers，可以使用<code>CAScrollLayer</code></li>
<li>但是它并不能通过拖拽来移动里面的内容（记得它没有响应链）</li>
<li>而是理解为一个<code>masksToBounds</code>的窗口，你只能看到它bounds里面的内容</li>
<li>能通过本身的<code>scroll(to:)</code>方法，和sublayers的<code>scroll(_:)</code>和<code>scrollRectToVisible(_:)</code>方法来改变scroll layer的bounds，达到显示sublayer指定区域的目的</li>
</ul>
<p><strong>Layer and Delegate</strong></p><ul>
<li>对一个不是UIView的undrelying layer的layer，让（任意）一个对象成为其delegate，可以由它来操控它的layout和drawing</li>
<li>但千万不要让UIView成为不是其underlying的layer的代理，反之亦然</li>
</ul>
<p><strong>Layout of Lyaers</strong></p><ul>
<li>When a layer needs layout, either because its <em>bounds have changed</em> or because you called <code>setNeedsLayout</code></li>
</ul>
<h2>Drawing in a Layer</h2>
<ul>
<li>set <code>contents</code> is the simplest way to draw in a layer -&gt; <code>CGImage</code><ul>
<li>但<code>contents</code>能接受任何类型，所以不正确的content只会<strong>fail silently</strong></li>
</ul>
</li>
<li>layer也有一个<code>draw(_:)方法，它被(自动)调用的时候通常表示要</code>redisplay itself`，什么时候需要redisplay itself?<ul>
<li>如果<code>needsDisplayOnBoundsChange</code>是false，那么就只有在<code>sefNeedDisplay</code>方法（及其<code>inRect</code>衍生方法）里会触发<ul>
<li>如果是非常重要的重绘，那么需要再显式调用一次<code>displayIfNeeded</code></li>
</ul>
</li>
<li>是true的话就如其名，在bounds变化的时候也会重绘</li>
</ul>
</li>
<li>有四个方法能在redisplay的时候调用:<ol>
<li>subclass的<code>display</code>重载，它没有<code>graphics context</code>，所以只能提供图片</li>
<li>delegate的<code>display(in:)</code>方法，同样，只能提供图片</li>
<li>subclass的<code>draw(in:)</code>方法，有context，所以能直接在里面绘图，但不会<code>make current context</code></li>
<li>delegate的<code>draw(_:in)</code>方法，限制也同上</li>
</ol>
</li>
<li>underlaying layer不应调用上面的方法，而交由view的<code>draw(_:)</code>方法<ul>
<li>一定要调也可以，但要显式实现view的<code>draw(_:)</code>方法，方法体为空就行了</li>
</ul>
</li>
</ul>
<p><strong>Drawing-Related Layer Properties</strong></p><ul>
<li>contentsScale: 像素对高分屏的映射，Cocoa管理的layer会自动设置，自定义的类需要注意这个scale</li>
<li>opacity: 就是view的<code>alpha</code><ul>
<li>Changing the isOpaque property has no effect until the layer redisplays itself.</li>
</ul>
</li>
</ul>
<p><strong>Content Resizing and Positioning</strong></p><ul>
<li>A layer’s content is stored (cached) as a bitmap which is then treated like an image:<ul>
<li>如果content来自一张图片，那么缓存的就是图片（CGImage），大小就是图片的point size</li>
<li>如果来自绘图，那么存的是graphics context</li>
</ul>
</li>
<li><code>ContentGravity</code>，类似UIView’s contentMode property，即缩放拉伸<ul>
<li>因为坐标系不同的历史原因，top, bottom是相反的</li>
<li>如果是自己绘制，则这个属性无意义，但结合下面的rect属性又有用了，因为截取了rect大小的绘制</li>
</ul>
</li>
<li><code>contentsRect</code>，结合上一个属性，做购物网站那种截取一小块，绘制到一个大图上去。这里是绘制到view上<ul>
<li>默认是全图(0,0,1,1)</li>
</ul>
</li>
<li><code>contentsCenter</code> ?? 好像是对上述rect属性划成9宫格，不同位置的格子缩放规则不一样，比如四个角落的格子，不会缩放<ul>
<li>所以给了一个center region（rect)，把它的四条边延长，就有9个格子了</li>
</ul>
</li>
</ul>
<p><strong>Layers that Draw Themselves</strong></p><p>系统内置了一些能自我绘制的layer:</p><ul>
<li>CATextLayer，轻量版的UILabel。通过<code>string</code>属性存取，与<code>contenta</code>会冲突，不要同时设。</li>
<li>CAShapeLayer, 有path属性，可以与<code>contents</code>共存，path绘制于content之上，并且不能设融合模式</li>
<li>CAGradientLayer，通过背景色做的渐变，去了解下clip和mask</li>
</ul>
<h2>Transforms</h2>
<ul>
<li>view的transform是根据其<strong>center</strong>来应用的，layer的是根据<code>anchorPoint</code><ul>
<li>所以<code>anchorPoint</code>就两个作用，把它移动到<code>position</code>的位置，和以它为中心进行旋转</li>
</ul>
</li>
</ul>
<ol>
<li>画刻度，核心是把文字先往上挪到圆圈的位置，所以anchorPoint只动y不动x (center, midY/textHeight)</li>
</ol>
<div class="highlight"><pre><span></span><span class="n">let</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCD&quot;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CATextLayer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">center</span><span class="w"> </span><span class="c1">// 这才是核心，一切定位和旋转的基准</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">vert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">midY</span><span class="o">/</span><span class="n">t</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">height</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">vert</span><span class="p">)</span><span class="w"> </span><span class="c1">// 半圆是文字调蓄的多少倍，就上移多少，但隐形的脚（即高跷的支点）仍在position处</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">foregroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="w"></span>

<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">setAffineTransform</span><span class="p">(</span><span class="bp">CGAffineTransform</span><span class="p">(</span><span class="n">rotationAngle</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CGFloat</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">circle</span><span class="p">.</span><span class="n">addSublayer</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>结果如图：
<figure class="vertical-figure" style="flex: 49.51923076923077" ><img width="412" height="416" src="/archives/assets/031ad73f3f956d76b906cf986e36e22e.png" alt=""/></figure></p><ol start="2">
<li>画箭头，演示了复杂的绘制怎么把它代理出去，并且什么时机让它产生绘制：</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1">// the arrow</span>
<span class="n">let</span><span class="w"> </span><span class="n">arrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">contentsScale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">scale</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.8</span><span class="p">)</span><span class="w"> </span><span class="c1">// 箭尾凹进去的位置（所以不可能是1.0）</span>
<span class="n">arrow</span><span class="p">.</span><span class="n">delegate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="w"> </span><span class="c1">// we will draw the arrow in the delegate method</span>
<span class="n">arrow</span><span class="p">.</span><span class="n">setAffineTransform</span><span class="p">(</span><span class="bp">CGAffineTransform</span><span class="p">(</span><span class="n">rotationAngle</span><span class="o">:</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">5.0</span><span class="p">))</span><span class="w"></span>
<span class="nb">self</span><span class="p">.</span><span class="n">addSublayer</span><span class="p">(</span><span class="n">arrow</span><span class="p">)</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span><span class="w"> </span><span class="c1">// draw, please</span>
</pre></div>
<p>** 3D Transforms</p><ul>
<li>A layer’s <code>affineTransform</code> is merely a façade for accessing its <code>transform</code>.</li>
<li>A layer’s <code>transform</code> is a three-dimensional transform, a <code>CATransform3D</code></li>
</ul>
<p>绕Y轴镜像的示例：</p><div class="highlight"><pre><span></span><span class="n">someLayer</span><span class="p">.</span><span class="n">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CATransform3DMakeRotation</span><span class="p">(.</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>一般而言，在Z轴没有分量的平面图，那就只剩旋转的效果了（没有翻转)
<figure  style="flex: 51.151315789473685" ><img width="622" height="608" src="/archives/assets/714bca8197bc1e5f9e71216b3ccd0745.png" alt=""/></figure></p><p>这是把anchorPoint设在了圆心，如果设在(0,0):
<figure class="vertical-figure" style="flex: 45.258620689655174" ><img width="1260" height="1392" src="/archives/assets/8e747494f676181ffca14504623cb89b.png" alt=""/></figure></p><ul>
<li>layer不是为了3D建模而诞生的（考虑<code>Metal</code>），它是2D对象，为<code>speed</code>和<code>simplicity</code>而设计</li>
</ul>
<p><strong>depth</strong></p><p>现实世界<code>z-component</code>的加入会近大远小，layer绘制没有表现出这种距离，而是压平到一个面：<code>orthographic projection</code>，但是使用了一些技巧来制造这种视觉效果。</p><p>[waiting for demo]</p><h2>Futher Layer Features</h2>
<p><strong>shadows</strong></p><ul>
<li>The shadow is normally based on the shape of the layer’s <code>nontransparent</code> region<ul>
<li>所以完全透明的视图是没有阴影的</li>
</ul>
</li>
<li>clip和shadow是不可能同时存在的，技巧是用另一个view叠到底层，让它实现阴影。</li>
</ul>
<p><strong>Borders and Rounded Corners</strong></p><ul>
<li>想要圆角，就必须用<code>masksToBounds</code>来实现clip，同时还要阴影的话，又得借助上图的技巧了。</li>
<li>从iOS 11起，可以单独设置圆角了：<code>maskedCorners</code>，它由minx, miny, maxx, maxy这种风格的描述进行组合，而不是我们期望的top-left之类的。</li>
</ul>
<p><strong>Masks</strong></p><ul>
<li>A CALayer can have a mask. This is itself a <strong>layer</strong>, whose content must be provided somehow.</li>
<li>只有透明部分有作用<ul>
<li>透明的位置，对应的layer位置也是透明的</li>
<li>反过来想不透明的部分，还是被应用mask的layer能显示的部分</li>
<li>这就是photoshop里图层蒙板”涂黑就是显示“的意思</li>
</ul>
</li>
<li>there is no built-in mechanism for <strong>automatically resizing the mask</strong> as the layer is resized.</li>
<li>把一个view当作另一个view的mask属性，底层就是相应的layer</li>
</ul>
<p>下例用mask来制作自己的圆角矩形，注意里面context和path的关系。在context里面，新建的path都是能直接绘制的，而不需要这个path设为谁的属性（drawRect:方法里也是一样，只要新建path，再自行去stoke, fill都行，</p><p>而context上也可以直接绘制</p><div class="highlight"><pre><span></span><span class="n">func</span><span class="w"> </span><span class="nf">mask</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="n">sz</span><span class="o">:</span><span class="n">CGSize</span><span class="p">,</span><span class="w"> </span><span class="n">roundingCorners</span><span class="w"> </span><span class="n">rad</span><span class="o">:</span><span class="n">CGFloat</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">CALayer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="n">origin</span><span class="o">:</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="o">:</span><span class="n">sz</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">bounds</span><span class="o">:</span><span class="n">rect</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="k">in</span><span class="w"></span>
<span class="w">        </span><span class="c1">// context绘制</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">con</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">(</span><span class="n">white</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="o">:</span><span class="mi">0</span><span class="p">).</span><span class="n">cgColor</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">(</span><span class="n">white</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="o">:</span><span class="mi">1</span><span class="p">).</span><span class="n">cgColor</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// path绘制</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">roundedRect</span><span class="o">:</span><span class="n">rect</span><span class="p">,</span><span class="w"> </span><span class="n">cornerRadius</span><span class="o">:</span><span class="n">rad</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">mask</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rect</span><span class="w"></span>
<span class="w">    </span><span class="n">mask</span><span class="p">.</span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">im</span><span class="p">.</span><span class="n">cgImage</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>Layer Efficiency</h2>
<p>由于移动设备算力的影响，大量叠加的半透明图层的渲染是一件很消耗且低效的事，特别是动画的时候。</p><p>debug：</p><ol>
<li>Core Animation template in <strong>Instruments</strong></li>
<li>New in Xcode 12, animation “hitches” can be measured with <code>XCTMetrics</code> during performance testing.</li>
<li>the Simulator’s <code>Debug</code> menu lets you summon <code>colored overlays</code> that provide clues as to possible sources of <strong>inefficient drawing</strong><ul>
<li>真机：Debug → View Debugging → Rendering</li>
</ul>
</li>
<li>New in Xcode 12, the view debugger (“View Debugger” on page 75) can display layers — choose Editor → Show Layers — and can offer suggestions for improving layer rendering efficiency.</li>
</ol>
<p>tips:</p><ol>
<li><strong>opaque drawing</strong> is most efficient.<ul>
<li>Nonopaque drawing is what the Simulator marks when you check Debug → Color Blended Layers.</li>
</ul>
</li>
<li>“freezing” the entirety of the layer’s drawing as a <strong>bitmap</strong>.<ul>
<li>直接绘制效率确实比缓存效率高</li>
<li>但是过深过复杂的继承树，没必要每次都实时计算渲染</li>
<li>by <code>shouldRasterize = true</code> and <code>rasterizationScale = UIScreen.main.scale</code></li>
</ul>
</li>
<li><code>drawsAsynchronously = true</code></li>
</ol>
<h2>Layers and Key-Value Coding</h2>
<div class="highlight"><pre><span></span><span class="n">layer</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>
<span class="c1">// or:</span>
<span class="n">layer</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;mask&quot;</span><span class="p">)</span><span class="w"></span>

<span class="nb">self</span><span class="p">.</span><span class="n">rotationLayer</span><span class="p">.</span><span class="n">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CATransform3DMakeRotation</span><span class="p">(.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="c1">// or:</span>
<span class="nb">self</span><span class="p">.</span><span class="n">rotationLayer</span><span class="p">.</span><span class="n">setValue</span><span class="p">(.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="n">forKeyPath</span><span class="o">:</span><span class="s">&quot;transform.rotation.y&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
<ul>
<li><p>不代表<code>CATransform3D</code>有<code>rotation</code>属性</p><ul>
<li>它没有任何属性</li>
<li>它甚至不是一个对象</li>
<li><code>self.rotationLayer.transform.rotation.y = //... no, sorry</code></li>
</ul>
</li>
<li><p>some transform key:</p></li>
</ul>
<p>• &quot;rotation.x&quot;,&quot;rotation.y&quot;,&quot;rotation.z&quot;
• &quot;rotation&quot; (same as &quot;rotation.z&quot;)
• &quot;scale.x&quot;,&quot;scale.y&quot;,&quot;scale.z&quot;
• &quot;translation.x&quot;,&quot;translation.y&quot;,&quot;translation.z&quot; • &quot;translation&quot; (two-dimensional, a CGSize)</p><ul>
<li>The<code>Quartz Core</code> framework also injects key–value coding compliance into <code>CGPoint</code>, <code>CGSize</code>, and <code>CGRect</code>, allowing you to use keys and key paths matching their <code>struct component names</code>.</li>
</ul>
<blockquote>
<p>see “Core Animation Extensions to Key-Value Coding” in Apple’s Core Animation Programming Guide</p></blockquote>
<ul>
<li>you can treat a <code>CALayer</code> as a kind of <code>dictionary</code>, and get and set the value for any key.<ul>
<li>view有tag，layer就有任意key</li>
</ul>
</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Layer/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">《Effective Objective-C 2.0》笔记第1-2章</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">
                <time class="text-uppercase">
                    January 14 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><figure class="vertical-figure" style="flex: 38.0" ><img width="912" height="1200" src="/archives/assets/ac920d0dab7ba40befbff58ed826b587.png" alt=""/></figure><blockquote>
<p>这个书当然中文版的，也很经典，我也读过了，但是嘛，老规矩，有原版还是读一遍原版，再加上英文水平也只有那么好，有机会能多读读在就多读读吧。一共就7章，52节，200多页，并不多。
此外，因为很多名词其实我们平时直接叫的就是英文，中文版里统统都给了一个中文翻译，反而更陌生了，有种“访达”的即视感。</p></blockquote>
<h1>Chapter 1: Accustoming Yourself to Objective-C</h1>
<h2>Item 1: Familiarize Yourself with Objective-C’s Roots</h2>
<ol>
<li><code>messaging structure</code> v.s. <code>function callihng</code><ul>
<li>in messaging structure, the <strong>runtime</strong> decides which code gets executed, while in function, the  <strong>compiler</strong> decides.</li>
<li><code>dynamic binding</code> v.s. <code>virtual table</code>  &lt;= 多态</li>
</ul>
</li>
<li><code>runtime component</code> v.s. <code>compiler</code><ul>
<li>含有所有让面向对象的OC能工作的 <em>data structures</em> and <em>functions</em><ul>
<li>比如，含有所有的memory-management methods</li>
</ul>
</li>
<li>更新runtime component就能提升性能，而无需重新编译</li>
</ul>
</li>
<li>Objective-C is a superset of C<ul>
<li>所以语法基本类似：<code>NSString *str = @&quot;The String</code></li>
<li>表示声明了一个变量，类型是<em>NSString *</em>，是一个指向NSString的指针</li>
<li>所有OC对象必须如此声明，对象内存也总是分配在heap space上<ul>
<li>这是分配到stack上：<code>NSString stackString</code> &lt;- 报错</li>
</ul>
</li>
<li>但指向这个对象的指针（<strong>pointer</strong>）是分配在<code>stack frame</code>里的，多个指向同一对象的指针就分配了多个内存<ul>
<li>每个内存大小就是一枚指针的大小</li>
<li>值也是一样</li>
</ul>
</li>
</ul>
</li>
<li>The memory allocated in the <code>heap</code> has to be <strong>managed directly</strong><ul>
<li>OC将堆内存管理抽象了出来，<code>runtime</code>进一步抽象成一套内存管理架构：<code>reference counting</code></li>
</ul>
</li>
<li>整个系统框架都要使用结构体，用对象会有额外的开销</li>
</ol>
<h2>Item 2: Minimize Importing Headers in Headers</h2>
<p>Objective-C, just like C and C++, makes use of <code>header files</code> and implementation files.</p><ol>
<li><code>forward declaring</code> -&gt; <code>@class SomeClass</code><ul>
<li>头文件里并不知道知道一些类的实现细节，只需要知道有这么一个类就行了</li>
<li>但是<code>.m</code>文件里就要自行去import一次这个class了</li>
<li>原则就是尽量延后引入头文件的时机，减少编译时间</li>
<li>还解决了互相引用的问题</li>
<li>引用<code>super class</code>, <code>protocol</code>等必须要知道细节，不能应用<code>forward declaring</code><ul>
<li>所以最好把protocol单独放在一个头文件，避免无谓地引用大文件，增加编译时间</li>
<li>但是<code>delegate</code>放到<code>class-continuation category</code>里面写更好（即在<strong>.m</strong>文件里写protocol和import），无需暴露到公共头文件</li>
</ul>
</li>
<li>关键词：<code>减小依赖</code>，<code>缩减编译时间</code></li>
</ul>
</li>
</ol>
<h2>Item 3: Prefer Literal Syntax over the Equivalent Methods</h2>
<ul>
<li>尽量使用字面量语法（<code>Literal Syntax</code>）创建和使用对象</li>
<li>字面量语法只是一个语法糖（<code>syntactic sugar</code>），推荐使用字面量，会减少代码量，但最好知道它对应的原始方法。（但是还是会有所区别，看下例）</li>
<li>用字面量初始数组，如果不是最后一个元素是nil，会报错，而原始的<code>arrayWithObjects:</code>方法则会在碰到第一个nil时当成是终止参数而正常执行（只保留nil前的元素初始化数组）<ul>
<li>作者说这反而是好事，未预料到的情况成功执行比报错更可怕，抛异常能更早地发现错误</li>
</ul>
</li>
<li>只能创建Foundation框架的对象，自定义对象不行（一般也没必要）</li>
<li>使用字面量语法创建出来的String, Array, Dict等都<code>immutable</code>的</li>
</ul>
<h2>Item 4: Prefer Typed Constants to Preprocessor #define</h2>
<ul>
<li><code>#define</code>本质是替换</li>
<li><code>#define</code>出来的是没有类型信息的</li>
<li>如果是声明在头文件中，引用了此头文件的代码都会应用此替换<ul>
<li>即使被重定义了，编译器也不会产生警告</li>
</ul>
</li>
<li>而常量就带了类型信息<ul>
<li><code>static NSString * const MyStringConstants = &quot;Hello world;</code></li>
<li>注意星号的位置，这里表示指针指向的是整个常量</li>
<li>如果把星号写到const后，那表示指针就是那个常量...</li>
</ul>
</li>
<li>定义常量的位置很重要（预处理指令也一样），不打算公开的话就在<code>.m</code>文件里定义</li>
<li>命令也很重要</li>
<li>否则成了全局变量，很可能”不经意“引起变量冲突/覆盖</li>
<li><code>static const</code>要一起使用，单独的<code>const</code>会报错<ul>
<li><code>static</code>不再是别的语言中的<strong>静态变量</strong>，而保是一个作用域声明</li>
<li>一个编译单元（<code>translation unit</code>）个输出一个目标文件（<code>object file</code>）<ul>
<li>考虑你编译一个c++文件，一个文件生成一个目标（二进制）文件，然后再链接。</li>
<li>所以一个编译单元一般是一个<code>.m</code>文件</li>
</ul>
</li>
<li>结合起来，<code>static</code>就是在一个目标文件内可见</li>
<li>如果不加<code>static</code>，编译器会添加一个<code>external symbol</code>（后面有详述），这样就有重定义风险了（<code>duplicate symbol</code>）</li>
</ul>
</li>
<li>最后，事实上<code>static const</code>一起用，编译器做的仍然是<strong>替换</strong>，而没有去创建符号（但此时已经有类型信息了）</li>
</ul>
<p>*如果需要公开，则添加到全局符号表（<code>global symbol table</code>）中：</p><div class="highlight"><pre><span></span><span class="c1">// In the header file</span>
<span class="k">extern</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="p">;</span><span class="w"></span>

<span class="c1">// In the implementation file</span>
<span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">@&quot;VALUE&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>上面解释了<code>static</code>，现在来解释<code>extern</code><ul>
<li><code>extern</code>表示向编译器保证全局符号表中将会有这个符号，其实就是要编译器不要继续检查</li>
<li>它知道链接成二进制文件后，肯定能找到这个常量</li>
</ul>
</li>
<li>所以在<code>.m</code>文件里正常定义和赋值，在<strong>任意</strong><code>.h</code>文件时给编译器打个招呼就行了</li>
<li>命名规范：<ul>
<li>如果是限定可见域的，用<code>k</code>开头就行了</li>
<li>如果会公开的，那么就用函数名作前缀（系统框架都是这么做的）</li>
</ul>
</li>
</ul>
<p><strong>external symbol</strong> V.S. <strong>global symbol</strong></p><blockquote>
<p>前文你已经知道了两种提升作用域的方式，区别在</p><ul>
<li>一个是通过不对const加static（添加external symbol），</li>
<li>一个是额外声明extern（添加到blobal symbol talbe）</li>
</ul>
</blockquote>
<h2>Item 5: Use Enumerations for States, Options, and Status Codes</h2>
<ul>
<li>枚举只是一种常量命名方式</li>
<li>语法很奇葩：<code>enum EOCConnectionState</code> state = EOCConnectionStateDisconnected;<ul>
<li>看高亮的部分，别人只要写一个type，它要连enum带名称写全</li>
</ul>
</li>
<li>所以一般会<code>typedef</code>一下：<code>typedef enum EOCConnectionState EOCConnectionState;</code><ul>
<li>现在就可以用<code>EOCConnectionState</code>这个type来定义变量了</li>
</ul>
</li>
<li>用enum来做选项(options)的时候，因为不是互斥的关系，选择bitwise OR operator来会直观很多（就是每一个二进制位代表一个状态）</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">UIViewAutoresizing</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingNone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleLeftMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleRightMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleTopMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleBottomMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<figure  style="flex: 66.52173913043478" ><img width="918" height="690" src="/archives/assets/4a634eedbb41d909a0b262a8f2f437ee.png" alt=""/></figure><ul>
<li>Foundation框架定义了一些辅助宏，以便支持新的C++标准对宏定义的增强同时还能兼容老的标准: <code>NS_ENUM</code>和<code>NS_OPTIONS</code><ul>
<li>特别是c++对枚举值里的bitwise操作结果需要显式转换</li>
<li>所以用到了<strong>可组合</strong>的option类的枚举，最好用<code>NS_OPTIONS</code>宏，否则用<code>NS_ENUM</code>就够了</li>
</ul>
</li>
<li>对enum应用<code>switch</code>最好不要加<code>default</code>，这样你添加了新的枚举值而忘记了处理，能及时得到错误反馈</li>
</ul>
<h1>Chapter 2: Objects, Messaging, and the Runtime</h1>
<h2>Item 6: Understand Properties</h2>
<ul>
<li><code>Properties</code> are an Objective-C feature providing encapsulation of the data an object contains.<ul>
<li>stored by <code>instance variables</code></li>
<li>accessed through <code>accessor methods</code> (getter, setter)<ul>
<li>can be written by complier automatically &lt;= <code>autosynthesis</code></li>
<li>introduced a <code>dot syntax</code> to  accessing the data</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看一下C++写法：</p><div class="highlight"><pre><span></span><span class="err">@</span><span class="n">interface</span><span class="w"> </span><span class="n">EOCPerson</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">NSObject</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="err">@</span><span class="k">public</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_firstName</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_lastName</span><span class="p">;</span><span class="w"> </span>
<span class="err">@</span><span class="k">private</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_someInternalData</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
<span class="err">@</span><span class="n">end</span><span class="w"></span>
</pre></div>
<ul>
<li>对象布局在编译期就确定了，所以就硬编码了每个属性在对象内存中的偏移量</li>
<li>所以如果对象布局变化了（比如增加了实例变量），这些偏移量就会出错，必须要重新编译。<ul>
<li>如果链接代码时使用了不同版本的类定义，就会产生这种“不兼容”的问题</li>
</ul>
</li>
<li>OC的解决方案是，把偏移量仍由“实例变量”存储<ul>
<li>但是交由“类对象“(class object)保管</li>
<li>偏移量在运行期查找 -&gt; 类的定义变了，偏移量也就变了（实时的）<ul>
<li>甚至可以在运行期向类中新增实例变量</li>
<li>nonfragile Application Binary Interface(ABI)</li>
<li>这样就可以不止在声明文件里定义实例变量，还可以在class-continuation和实现文件里面定义了</li>
</ul>
</li>
<li>尽量不要直接访问实例变量</li>
</ul>
</li>
<li>使用<code>点语法</code>访问属性<ul>
<li>编译器会转换为对存取方法的调用</li>
<li>编译器会为属性生成相应的实例变量，并自动合成（生成相应的存取方法）<ul>
<li>编译期进行，所以你看不到实际的代码</li>
<li>也可以手写同样的代码（这时你就可以自定义实例方法的签名了）</li>
<li><code>@dynamic</code>能阻止合成 &lt;= 相信运行期能找到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Property Attributes</h3>
<ol>
<li>原子性(<code>Atomicity</code>)，读写的时候加锁</li>
<li>读/写权限</li>
<li>内存管理语义<ul>
<li>assign: on scalar type</li>
<li>strong: 拥有关系，设置新值流程：retain new -&gt; release old -&gt; set new</li>
<li>weak: 非拥有关系</li>
<li>unsafe_unretained: 类似assign，但适用于对象类型（而不只有scalar type)<ul>
<li>与weak的区别在目标对象在销毁时，该属性值不会自动清空</li>
</ul>
</li>
<li>copy: 类似strong，但是相比起retain，它直接是复制了一份，通常用于拥有可变类型的变量，比如<code>NSString *</code>，可变版的string也能赋值给NSString，这就会引起赋值后值还自己变了的可能性</li>
</ul>
</li>
<li>方法名<ul>
<li>getter=<name>，需要注意的是有些bool类型的通常会设置为<code>isXXXX</code></li>
<li>setter=<name>，但很少这么做</li>
</ul>
</li>
</ol>
<p>如果自己来实现accessor methods，那么就要自己去保证这些方法符合这些attributes，比如内存管理语义为copy，那么在设置的时候就要拷贝传入的值：</p><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">EOCPerson</span> : <span class="bp">NSManagedObject</span><span class="w"> </span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">firstName</span><span class="p">;</span><span class="w"></span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">lastName</span><span class="p">;</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFirstName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">firstName</span><span class="w"> </span><span class="nf">lastName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">lastName</span><span class="p">;</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>

<span class="c1">// 实现文件：</span>
<span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">initWithFirstName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">firstName</span><span class="w"> </span><span class="n">lastName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">lastName</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nb">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">super</span><span class="w"> </span><span class="n">init</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_firstName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">firstName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">_lastName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">lastName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">self</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
<blockquote>
<ul>
<li>读写操作的原子性并不是线程安全</li>
<li>iOS中使用同步锁开销较大</li>
<li>实际iOS程序碰到多线程读写属性的场景也非常少</li>
<li>所以基本上都是声明为<code>nonatomic</code></li>
</ul>
</blockquote>
<h2>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h2>
<p>在对象内部优先访问实例变量。</p><p>直接访问而不用点语法的影响：</p><ul>
<li>不经过消息派发，速度快（编译器生成的代码会直接访问相应的内存）</li>
<li>不会调用setter，也绕过了相应的内存管理语义</li>
<li>不会触发KVO</li>
<li>没有机会在getter, setter中设置断点来调试</li>
<li>没有机会<code>lazy intialization</code>，而getter机制能在首次被调用到的时候才去初始化实例变量</li>
<li>初始化和dealloc的时候总是要直接用实例变量</li>
</ul>
<p>作者建议尽量在读取实例变量的时候直接访问，设置的时候用属性（会自动考虑内存管理语义）</p><h2>Item 8: Understand Object Equality</h2>
<p>其实就是理解NSObject自带的<code>isEqual:</code>方法。</p><ul>
<li><code>==</code>就是比指针</li>
<li><code>isEqual:</code>比的是<code>hash</code>，所以自定义的类要实现equality就要自行实现这两个方法<ul>
<li>hash不同必然对象不同，但由于有hash collisions的存在，反过来并不成立</li>
<li>尽量用对象的不可变部分来做hash</li>
</ul>
</li>
</ul>
<p>一个做hash的方法：</p><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_firstName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_lastName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">ageHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_age</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">ageHash</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>Item 9: Use the Class Cluster Pattern to Hide Implementation Detail</h2>
<div class="highlight"><pre><span></span><span class="p">+</span> <span class="p">(</span><span class="bp">UIButton</span><span class="o">*</span><span class="p">)</span><span class="nf">buttonWithType:</span><span class="p">(</span><span class="n">UIButtonType</span><span class="p">)</span><span class="nv">type</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>作者将上述这种解释为“类族”，即它的返回值可能是各种button，但归根结底，都是<code>UIButton</code>，就是靠着switch各种type来实例化各种子类。</li>
<li>同时，因为OC没有abstract class，为了避免直接使用抽象基类，一般不提供init方法，并在基类相关方法里干脆抛异常</li>
<li>这里使用<code>isMemberOfClass</code>就要小心，它是kind，但不一定是member</li>
<li>系统框架里有很多<code>class cluster</code>，特别是<code>collection</code><ul>
<li>所以<code>if([anArray class] == [NSArray class])</code>是false（原因就是它是被当作“<strong>抽象基类</strong>来设计的，实际上是隐藏在公共接口后面的某个内部类型）</li>
<li>同样，用<code>isKindOfClass:</code>至少能判断是在这个类族里</li>
</ul>
</li>
</ul>
<h2>Item 10: Use Associated Objects to Attach Custom Data to Existing Classes</h2>
<p>扩展现有类，我们可以继承，但有时候一些特殊机制创建的类却无法继承，可以通过<code>Associated Object</code>来添加这些信息。</p><ul>
<li>以键值对来存储，所以是可以存储多个关联数据的</li>
<li>可以指定storage policy，对应内存管理语义</li>
</ul>
<figure  style="flex: 140.1840490797546" ><img width="914" height="326" src="/archives/assets/820ae39c34d1147867f1dfb6f1d64de3.png" alt=""/></figure><p>方法:</p><div class="highlight"><pre><span></span><span class="c1">// Sets up an association of object to value with the given key and policy.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">objc_AssociationPolicy</span><span class="w"> </span><span class="n">policy</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Retrieves the value for the association on object with the given key.</span>
<span class="kt">id</span><span class="w"> </span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Removes all associations against object.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>书中写了一个例子，alertView的代理方法来处理按了什么键，而一个页面中如果有多个alertView，且用同一个代理对象，那么处理需要更精细（比如需要知道是哪个警告框弹的，我一般用tag）。
而如果把处理方法定义为一个block，并把它关联到UIAlertView类，那么处理逻辑就可以跟定义alertView写在一起了。</p><p>todo, item 11-14</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Drawing/" target="_self">Programming iOS 14 - Drawing</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Drawing/" target="_self">
                <time class="text-uppercase">
                    December 25 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第2章</p><hr />
<h1>Drawing</h1>
<p>Many UIView subclasses, such as a UIButton or a UILabel, know how to draw themselves.</p><p>A <em>pure UIView</em> is all about drawing, and it leaves that drawing largely up to you.</p><h2>Images and Image Views</h2>
<p>图片可以来自文件，代码，或网络。</p><h3>Image Files</h3>
<ul>
<li><code>init(named:)</code>，会从<code>Asset catalog</code>和<code>App bundle</code>的顶层去查找<ul>
<li>返回的是一个Optional，因为不能确定这个路径对应一张图片，或能解码成功</li>
<li>它会将图片缓存<ul>
<li><code>init(contentsOfFile:)</code>则不会缓存，但不从asset catalog加载而是相对于<code>Bundle.main</code>来做路径</li>
</ul>
</li>
</ul>
</li>
<li>从bundle里找时不加扩展名会默认为<em>png</em></li>
<li>直接将图片拖到代码生成的不是Optional的image，调用的是<code>init(imageLiteralResourceName:)</code>方法</li>
<li>文件名里的@表示<code>High-resolution variants</code>，即不同分辨率下采用的图片，比如<code>@2x</code></li>
<li>文件名里的~表示<code>Device type variants</code>，即不同设备类型下采用的图片，比如<code>~ipad</code></li>
</ul>
<blockquote>
<p>尽量把图片放到asset catalog里，对不同的处理器，更宽的色域，等等
不光影响运行时，在Apple Store对你的app对特定设备进行<em>thinning</em>都会用到
不同size class, dark mode, ipad等等trait collection都可以设置对应的图片</p></blockquote>
<p><strong>Vector images</strong></p><ul>
<li>An image file in the asset catalog can be a vector-based PDF or (new in Xcode 12) an SVG.</li>
<li><code>init(systemName:)</code> -&gt; <a href="https://developer.apple.com/sf-symbols/">SF Symbols</a><ul>
<li><code>.withConfiguration(_:) or .applyingSymbolConfiguration(_:)</code> 进行自定义，参数是一个<em>UIImage.SymbolConfiguration</em></li>
<li>Configurations can involve one of nine <code>weights</code>, one of three <code>scales</code>, a font or text <code>style</code>, and a <code>point size</code>, in various combinations</li>
</ul>
</li>
</ul>
<p><strong>Asset catalogs and trait collections</strong></p><p>指定trait collection初始化图片：<code>init(named:in:compatibleWith:)</code></p><ul>
<li>A built-in interface object that displays an image, such as a UIImageView, is <code>automatically trait collection–aware</code>;</li>
<li>it receives the <code>traitCollectionDidChange(_:)</code> message and responds accordingly.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">tcreg</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">verticalSizeClass</span><span class="p">:</span> <span class="p">.</span><span class="n">regular</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tccom</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">verticalSizeClass</span><span class="p">:</span> <span class="p">.</span><span class="n">compact</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">moods</span> <span class="p">=</span> <span class="bp">UIImageAsset</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">frowney</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;frowney&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">smiley</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;smiley&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="n">moods</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">frowney</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">tcreg</span><span class="p">)</span>
<span class="n">moods</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">smiley</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">tccom</span><span class="p">)</span>
</pre></div>
<p>由此也可见，你操作的是“一张图片”，其实它是一<strong>组</strong>带了条件的图片。</p><blockquote>
<p>UIColor也是相同的机制，你用<code>resolvedColor(with:)</code>传入trait collection把对应的颜色取出来使用。</p></blockquote>
<p><strong>Namespacing image files</strong></p><ul>
<li>物理文件夹，虚拟文件夹内的图片访问时，都需要加上文件夹名（namespaing)</li>
<li><code>init(named:)</code>的完全形态其实是<code>init(named:in:)</code>，第二个参数是bundle，比如来自某个framework.</li>
</ul>
<h3>Image Views</h3>
<p>A UIImageView can actually have two images, one assigned to its <code>image</code> property and the other assigned to its <code>highlightedImage</code> property
A UIImageView without an image and without a background color is <em>invisible</em></p><p><strong>Resizable Images</strong></p><p>用inset来设置<strong>不</strong>拉伸的区域，比如一般我们碰到的多为左右随便拉伸的胶囊按钮，需要设计师做的就是左右两个半圆（不拉伸）和中间1像素的可拉伸部分</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">marsTiled</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">resizableImage</span><span class="p">(</span><span class="n">withCapInsets</span><span class="p">:</span>
<span class="n">UIEdgeInsets</span><span class="p">(</span>
    <span class="n">top</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kr">left</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">bottom</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kr">right</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">),</span> <span class="n">resizingMode</span><span class="p">:</span> <span class="p">.</span><span class="n">stretch</span><span class="p">)</span>
</pre></div>
<p>所以如果只是横向拉伸，上面的代码中，top, bottom都可以设为0，或都设为图片高度（而不去除2什么的），只需要保证把UI控件的高度保持跟图片一致即可。</p><p>那么，如果不小心高度大于图片高度了呢？分两种情况，如果设了0，表示没有保留区域，直接竖向拉伸，而如果设成了图片高度，那么表示整个Y方向没有可供拉伸的像素，必然造成拉伸失败：</p><figure  style="flex: 123.51598173515981" ><img width="1082" height="438" src="/archives/assets/be32f2993735b82ac7da004327cf4bad.png" alt=""/></figure><p><strong>Transparency Masks</strong></p><p>The image shown on the screen is formed by combining the image’s <code>transparency</code> values with a single <code>tint color</code>.</p><p>忽略图片各像素上颜色的数值，只保留透明度，就成了一个mask. (renderingMode: <code>alwaysTemplate</code>)</p><ul>
<li>iOS gives every UIView a <code>tintColor</code>, which will be used to <code>tint any template images</code>。所以我们经常用的tintColor其实就是给模板图片染色的意思。</li>
<li>tintColor是向下继承的</li>
<li>The symbol images are always template images</li>
<li>iOS 13起，可以对UIImage直接应用tint color</li>
</ul>
<p><strong>Reversible Images</strong></p><ul>
<li>用<code>imageFlippedForRightToLeftLayoutDirection</code>来创建一个在从右向左的书写系统里会自动翻转的图片。<ul>
<li>但你又可以设置<code>semanticContentAttribute</code>来阻止这个镜像行为</li>
</ul>
</li>
<li>如果不考虑书写系统，可以用<code>withHorizontallyFlippedOrientation</code>强行镜像</li>
</ul>
<h2>Graphics Contexts</h2>
<p>Graphics Contexts是绘图的起点，你能从如下方式得到Graphics Contexts：</p><ol>
<li>进入UIView的 <code>draw(_:)</code>方法时，系统会给你提供一个Graphics Contexts</li>
<li>CALayer的<code>draw(in:)</code>,或其代理的<code>draw(_:in:)</code>方法，<em>in</em>参数就是Graphics Contexts<ul>
<li>但它不是<code>currnet context</code></li>
</ul>
</li>
<li>手动创建一个</li>
</ol>
<p>UIKit 和 Core Graphics是两套绘制工具。</p><ul>
<li>UIKit是大多数情况下你的选择，大部分Cocoa class知道如何绘制自己</li>
<li>只能在current context上绘制</li>
<li>Core Graphics is the full drawing API， often referred to as <code>Quartz (2D)</code></li>
<li>UIKit drawing is built on top of it.</li>
</ul>
<p>两套体系，三种context来源，共计6种殊途同归的方式。</p><h3>Drawing on Demand</h3>
<p>直接上代码：</p><div class="highlight"><pre><span></span><span class="c1">// UIView</span>

<span class="c1">// UIKit</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接绘制</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CG</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 取到context</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CALayer</span>

<span class="c1">// UIKit</span>
 <span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">layer</span><span class="p">:</span> <span class="bp">CALayer</span><span class="p">,</span> <span class="k">in</span> <span class="n">con</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
    <span class="n">UIGraphicsPopContext</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CG</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">layer</span><span class="p">:</span> <span class="bp">CALayer</span><span class="p">,</span> <span class="k">in</span> <span class="n">con</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<h3>Drawing a UIImage</h3>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// im is the blue circle image, do something with it here ...</span>
<span class="n">And</span> <span class="n">here</span><span class="err">’</span><span class="n">s</span> <span class="n">the</span> <span class="n">same</span> <span class="n">thing</span> <span class="n">using</span> <span class="n">Core</span> <span class="n">Graphics</span><span class="p">:</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// im is the blue circle image, do something with it here ...</span>
</pre></div>
<h2>UIImage Drawing</h2>
<p>用已有的图像进行绘制：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">mars</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Mars&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">sz</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
    <span class="n">format</span><span class="p">:</span><span class="n">mars</span><span class="p">.</span><span class="n">imageRendererFormat</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="n">mars</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">mars</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>这里，绘制了两个火星，注意<code>imageRendererFormat</code>的使用</p><h2>CGImage Drawing</h2>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">mars</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Mars&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="c1">// extract each half as CGImage</span>
<span class="kd">let</span> <span class="nv">marsCG</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">cgImage</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">sz</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span>
<span class="kd">let</span> <span class="nv">marsLeft</span> <span class="p">=</span> <span class="n">marsCG</span><span class="p">.</span><span class="n">cropping</span><span class="p">(</span><span class="n">to</span><span class="p">:</span>
    <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">marsRight</span> <span class="p">=</span> <span class="n">marsCG</span><span class="p">.</span><span class="n">cropping</span><span class="p">(</span><span class="n">to</span><span class="p">:</span>
    <span class="n">CGRect</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">CGSize</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
    <span class="n">format</span><span class="p">:</span><span class="n">mars</span><span class="p">.</span><span class="n">imageRendererFormat</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="n">ctx</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span>
    <span class="n">con</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span>
        <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">marsRight</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span>
        <span class="n">CGRect</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>当然, <code>con.draw</code>可以由UIImage来完成：</p><div class="highlight"><pre><span></span><span class="bp">UIImage</span><span class="p">(</span><span class="n">cgImage</span><span class="p">:</span> <span class="n">marsLeft</span><span class="p">!,</span>
<span class="n">scale</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">scale</span><span class="p">,</span>
<span class="n">orientation</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">imageOrientation</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
<h2>Snapshots</h2>
<ul>
<li><code>drawHierarchy(in:afterScreenUpdates:)</code>将整个视图存成一张图片。</li>
<li>更快，语义更好的方法：<code>.snapshotView(afterScreenUpdates:)</code> -&gt; 输出是UIView，不是UIImage</li>
<li><code>resizableSnapshotView(from:after- ScreenUpdates:withCapInsets:)</code>生成可缩放的</li>
</ul>
<h2>Core Image</h2>
<p>The “CI” in <code>CIFilter</code> and <code>CIImage</code> stands for <code>Core Image</code>, a technology for transforming images through <em>mathematical</em> filters. (iOS 5起，从macOS引入)</p><p>用途：</p><ul>
<li>patterns and gradients (可以被别的filter一起使用)</li>
<li>compositing (使用composting blend modes)</li>
<li>color (颜色调整，亮度锐度色温等等)</li>
<li>geometric (几何相关的就是用来变形)</li>
<li>transformation (distort, blur, stylize an image)</li>
<li>transition (一般用于动画，通过设置frame序列)</li>
</ul>
<p>There are more than 200 available <code>CIFilters</code>， A CIFilter is a set of <strong>instructions</strong> for <code>generating</code> a CIImage</p><ul>
<li>基本上，处理的都是<code>CIImage</code>(input)</li>
<li>输出也是<code>CIImage</code>，或者另一个<code>filter</code> -&gt; 链式调用<ul>
<li>最后一层链可以自行转换为bitmap: cg或ui image(by <code>rendering</code>方法)</li>
<li>rendering的时候，所有的数学计算才开始发生</li>
<li>因为只是<strong>instructions</strong></li>
</ul>
</li>
<li><strong>关键词</strong>：filter是用来描述怎么<strong>生成</strong>CIImage的</li>
<li><code>CGImage</code>和<code>UIImage</code>都能得到CIImage</li>
</ul>
<blockquote>
<p>UIImage只有在已经wraps了一个<code>CIImage</code>的情况下<code>.ciImage</code>才有值，而大多数情况下是没有的。</p></blockquote>
<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html">Core Image Filter Reference</a>里有所有的filter的名字，用来初始化一个filter</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">filter</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;CICheckerboardGenerator&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="c1">// or:</span>
<span class="kd">let</span> <span class="nv">filter</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">checkerboardGenerator</span><span class="p">()</span>

<span class="c1">// 用key-value来决定行为：</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="s">&quot;inputWidth&quot;</span><span class="p">)</span>
<span class="c1">// or:</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">width</span> <span class="p">=</span> <span class="mi">30</span>
<span class="c1">// or init with params</span>
<span class="kd">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="n">parameters</span><span class="p">:)</span>

<span class="c1">// apply filter on CIImage(if exists one)</span>
<span class="n">ciimage</span><span class="p">.</span><span class="n">applyingFilter</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span><span class="n">parameters</span><span class="p">:)</span>
<span class="c1">// or output a ciimage</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">outputImage</span>
</pre></div>
<p><strong>Render a CIImage</strong>
CIImage 不是一个<code>displayaable image</code></p><ul>
<li><code>CIContext</code>.init(options:).createCGImage(_:from)<ul>
<li>参数1是CIImage，</li>
<li>参数2是绘制区域（所以没有frame/bounds)，叫<code>extent</code></li>
<li>这是很昂贵的操作，建议在全app生命周期保留这个context复用</li>
</ul>
</li>
<li><code>UIImage</code>.init(ciImage:)</li>
<li>把上一次的uiimage设置成<code>UIImageView</code>的image，也能造成CIImage的渲染。</li>
</ul>
<p>以上说的都是&quot;render&quot; CIImage的时机，所以传入的</p><blockquote>
<p><code>Metal</code>能快速渲染CIImage</p></blockquote>
<p>串起一个demo:</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">moi</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Moi&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">moici</span> <span class="p">=</span> <span class="bp">CIImage</span><span class="p">(</span><span class="n">image</span><span class="p">:</span><span class="n">moi</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">moiextent</span> <span class="p">=</span> <span class="n">moici</span><span class="p">.</span><span class="n">extent</span>
<span class="kd">let</span> <span class="nv">smaller</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">moiextent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">larger</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">moiextent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// first filter</span>
<span class="kd">let</span> <span class="nv">grad</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">radialGradient</span><span class="p">()</span>
<span class="n">grad</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">center</span>
<span class="n">grad</span><span class="p">.</span><span class="n">radius0</span> <span class="p">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">smaller</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="mf">0.7</span>
<span class="n">grad</span><span class="p">.</span><span class="n">radius1</span> <span class="p">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">larger</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
<span class="kd">let</span> <span class="nv">gradimage</span> <span class="p">=</span> <span class="n">grad</span><span class="p">.</span><span class="n">outputImage</span><span class="p">!</span>
<span class="c1">// 到此步为止，并没有moi这个图片参与，等于是一个纯filter</span>

<span class="c1">// second filter</span>
<span class="kd">let</span> <span class="nv">blend</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">blendWithMask</span><span class="p">()</span>
<span class="n">blend</span><span class="p">.</span><span class="n">inputImage</span> <span class="p">=</span> <span class="n">moici</span>  <span class="c1">// 设置了image</span>
<span class="n">blend</span><span class="p">.</span><span class="n">maskImage</span> <span class="p">=</span> <span class="n">gradimage</span> <span class="c1">// 这里演示的是mask filter，按我理解并不是链式的，而且语法上也不是链式的，而是赋值给了maskImage，但书里直接说是链式的</span>
<span class="kd">let</span> <span class="nv">blendimage</span> <span class="p">=</span> <span class="n">blend</span><span class="p">.</span><span class="n">outputImage</span><span class="p">!</span>

<span class="c1">// 两种render方法</span>
<span class="c1">// content</span>
<span class="kd">let</span> <span class="nv">moicg</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">createCGImage</span><span class="p">(</span><span class="n">blendimage</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">moiextent</span><span class="p">)</span><span class="o">!</span> <span class="c1">// *</span>
<span class="kc">self</span><span class="p">.</span><span class="n">iv</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">cgImage</span><span class="p">:</span> <span class="n">moicg</span><span class="p">)</span>

<span class="c1">// UIImage</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">moiextent</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
<span class="kc">self</span><span class="p">.</span><span class="n">iv</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">UIImage</span><span class="p">(</span><span class="n">ciImage</span><span class="p">:</span> <span class="n">blendimage</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">moiextent</span><span class="p">)</span> <span class="c1">// *</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>关于上述代码里我的疑惑，第一个filter并不是chain到第二个filter里的，但书里说是<code>obtain the final CIImage in the chain (blendimage)，看来所谓的chain，并不是fitler的chain，而是</code>outputImage`的chain?
问题是，这是唯一且标准的filter嵌套用法么？-&gt; mask</p></blockquote>
<p>不是的</p><ol>
<li>对filter的outputImage继续应用<code>aplyingFilter(_:parameters)</code>来链式应用一个新的filter<ul>
<li>返回值是CIImage，不再是filter</li>
<li>所以如果继续chain，直接用返回值调apply...方法即可</li>
</ul>
</li>
<li>把上一个filter的outputImage设为下一个filter的inputImage:</li>
</ol>
<div class="highlight"><pre><span></span><span class="bp">CIFilter</span><span class="w"> </span><span class="o">*</span><span class="n">gloom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CIFilter</span><span class="w"> </span><span class="n">filterWithName</span><span class="o">:</span><span class="s">@&quot;CIGloom&quot;</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setDefaults</span><span class="p">];</span><span class="w">                                        </span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputImageKey</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@25.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputRadiusKey</span><span class="p">];</span><span class="w">         </span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@0.75f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputIntensityKey</span><span class="p">];</span><span class="w">      </span>
<span class="c1">// 即outputImage</span>
<span class="bp">CIImage</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">valueForKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIOutputImageKey</span><span class="p">];</span><span class="w">   </span>

<span class="bp">CIFilter</span><span class="w"> </span><span class="o">*</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CIFilter</span><span class="w"> </span><span class="n">filterWithName</span><span class="o">:</span><span class="s">@&quot;CIBumpDistortion&quot;</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setDefaults</span><span class="p">];</span><span class="w">                                              </span>
<span class="c1">// 设置inputImage (with first filter&#39;s output image) </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputImageKey</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="bp">CIVector</span><span class="w"> </span><span class="n">vectorWithX</span><span class="o">:</span><span class="mi">200</span><span class="w"> </span><span class="n">Y</span><span class="o">:</span><span class="mi">150</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="nl">forKey</span><span class="p">:</span><span class="w"> </span><span class="n">kCIInputCenterKey</span><span class="p">];</span><span class="w">                              </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@100.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputRadiusKey</span><span class="p">];</span><span class="w">                </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@3.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputScaleKey</span><span class="p">];</span><span class="w">                   </span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">valueForKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIOutputImageKey</span><span class="p">];</span><span class="w"></span>
</pre></div>
<blockquote>
<p>CIImage能认出EXIF里关于旋转方向的参数，并以正确的方向展示</p></blockquote>
<h2>Blur and Vibrancy Views</h2>
<p>毛玻璃效果，用<code>UIVisualEffectView</code>，这是个抽像类，实际用这两个：<code>UIVisualEffectView</code>和<code>UIVibrancyEffect</code>。</p><p>什么是<code>UIVibrancyEffect</code>?</p><blockquote>
<p>An object that amplifies and adjusts the color of the content layered <code>behind</code> a visual effect view.</p></blockquote>
<p>关键词是<code>behind</code>，即它是配合别的视效一起用的（比如毛玻璃）。文字被毛玻璃覆盖后的效果，并不是由毛玻璃层来确定的，而是由vibrancy effect自定义的。</p><p>总的来说</p><ul>
<li>用effect初始化effect view, effect就是五种<code>material</code></li>
<li>这个view可以当成常规view来定位，布局，添加到subview里，等等</li>
<li>用上一个effect初始化一个vibrancy effect（with style)</li>
<li>用vibrance effect初始化一个view</li>
<li>创建UI控件</li>
<li>让vibView的bounds等于内容的bounds（等于只对内容所有的范围内应用特效），并定位</li>
<li>vibView添加到effectView的contentView的subView里去</li>
<li>需要被vibrancy的内容（比如一个label)，则添加到vibView.contentView.addSubview(label)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">blurEffect</span> <span class="p">=</span> <span class="bp">UIBlurEffect</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="p">.</span><span class="n">systemThinMaterial</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">blurView</span> <span class="p">=</span> <span class="bp">UIVisualEffectView</span><span class="p">(</span><span class="n">effect</span><span class="p">:</span> <span class="n">blurEffect</span><span class="p">)</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">frame</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleWidth</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleHeight</span><span class="p">]</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">blurView</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">vibEffect</span> <span class="p">=</span> <span class="bp">UIVibrancyEffect</span><span class="p">(</span>
    <span class="n">blurEffect</span><span class="p">:</span> <span class="n">blurEffect</span><span class="p">,</span> <span class="n">style</span><span class="p">:</span> <span class="p">.</span><span class="n">label</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">vibView</span> <span class="p">=</span> <span class="bp">UIVisualEffectView</span><span class="p">(</span><span class="n">effect</span><span class="p">:</span><span class="n">vibEffect</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lab</span> <span class="p">=</span> <span class="bp">UILabel</span><span class="p">()</span>
<span class="n">lab</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello, world&quot;</span>
<span class="n">lab</span><span class="p">.</span><span class="n">sizeToFit</span><span class="p">()</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">bounds</span> <span class="p">=</span> <span class="n">lab</span><span class="p">.</span><span class="n">bounds</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span>
    <span class="p">[.</span><span class="n">flexibleTopMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleBottomMargin</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flexibleLeftMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleRightMargin</span><span class="p">]</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">contentView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">vibView</span><span class="p">)</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">contentView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
</pre></div>
<h2>Drawing a UIView</h2>
<p>UIView本身就提供了一个<code>graphics context</code>，在这个context里进行的绘制会直接显示在view里。</p><ul>
<li>subclass UIView's <code>.draw(_:)</code>method<ul>
<li>直到需要时才会被调用</li>
<li>或<code>setNeedsDisplay</code>会调用</li>
<li>一量被draw，就缓存起来了 (<code>bitmap backing store</code>)</li>
</ul>
</li>
<li>实时绘制会吓到一些初学者，绘制是<code>time-comsuming operation</code></li>
</ul>
<p>推荐在<code>draw</code>方法里实时绘制</p><blockquote>
<p>In fact, moving code to draw(_: ) is commonly a way to increase efficiency. This is because it is more efficient for the drawing engine to <em>render directly onto the screen</em> than for it to <em>render offscreen</em> and then copy those pixels onto the screen.</p></blockquote>
<p>几个注意点：</p><ol>
<li>不要手动调用draw方法，<code>setNeedsDisplay</code>会让系统决定下一个合适的时机来draw</li>
<li>不要重载draw方法，比如你无法合并UIImageView的drawing</li>
<li>不要在draw里做任何与绘制无关的事，配置（如背景色，添加子view/layer）项应该在别的地方做，比如<code>layoutSubviews</code></li>
<li>第二个参数是一个rect，默认是view的bounds<ul>
<li>如果你用<code>setNeesDisplay(_:)</code>送入了自定义的CGRect，draw里面的rect也就成了这个，如果你不在这个rect里画（而是在整个view的rect里），超出部分会被clip掉</li>
<li>这也是为了效率，显示提供绘制的区域</li>
</ul>
</li>
<li>手写draw绘制出来的view会有黑色的底色，如果你没有设计背景色，以及<code>isOpaque == true</code>时（<code>UIView.init(frame:)</code>出来的view恰好满足这两个条件， nib里拖出来的则是nil的背景，反而没这问题）<ul>
<li>解决：实现<code>init(frame:)</code>，去设置*isOpaque`为false</li>
</ul>
</li>
</ol>
<h2>Graphics Context Commands</h2>
<blockquote>
<p>Under the hood, Core Graphics commands to a <code>graphics context</code> are global C functions with names like CGContextSetFillColor，但是swift的封装让调用更简单（语法糖）</p></blockquote>
<p>当你在graphics context里绘制时，取的就是当前的设置，因此在任何绘制前，第一步都是先配置context's setting，比如你要画一根红线，再画一根蓝线</p><ol>
<li>设置context line color red, then draw a line</li>
<li>设置context line color blue, then draw a line</li>
</ol>
<p>直觉认为红和蓝只是两条线各自的属性，其实是你绘制<strong>当时</strong>，整个graphics context的设置</p><ul>
<li>这些配置通通存成一个state</li>
<li>这些state又会stack起来<ul>
<li>saveGState将当前state推到栈顶</li>
<li>restoreGstate则将state从栈顶取出，覆盖当前设置</li>
</ul>
</li>
<li>只要先后配置没有冲突的项，就没必要频繁save-restore</li>
</ul>
<h3>Paths and Shapes</h3>
<ul>
<li><p>通过一系列的描述去移动一去想象中的笔，就是构建<code>path</code>的过程。（注意，不是构建<code>CGPath</code>这个封装的过程）</p><ul>
<li>即只要你在context内，就可以用笔画东西了</li>
</ul>
</li>
<li><p>只要你正确地使用<code>move(to:)</code>方法，就不需要像apple文档里动不动就用<code>beginPath</code>来设置新的path的起点</p></li>
<li><p><code>fillPath</code>会自动<code>closePaht</code></p></li>
<li><p>先提供path，再draw，draw的意思要么是stroke，要么是fill，要么是both（<code>drawPath</code>方法），但不能一步步来，因为draw完你的path就空了</p><ul>
<li>衔接第一条，如果你想复用这个path，才需要用<code>CGPath</code>封装起来</li>
</ul>
</li>
<li><p>如果是使用UIKit封装的语法，那么起点就是一个path <code>let path = UIBezierPath()</code></p></li>
<li><p>那么每次draw完，要在别的位置“落笔”的话，要先清一下靠前的path: <code>path.removeAllPoints()</code></p></li>
</ul>
<h3>Clipping</h3>
<ul>
<li>clipping掉的区域就不能被绘制了</li>
<li>通常你无法得知一个graphics context的大小，但是通过<code>boundingBoxOfClipPath</code>却能拿到整个bounding</li>
</ul>
<p>这一节做了几个实验，单独写到了<a href="https://www.jianshu.com/p/ade133568ac0">另一篇博文</a></p><blockquote>
<p>前面说过，没有背景色+isOpaque会导致背景变黑，在draw里面，默认的颜色也是黑色，所以你不带任何设置的绘制你是看不到任何东西的（就是黑笔在黑纸上画）</p></blockquote>
<h3>Gradients</h3>
<p>gradient不能用作path的fill，但可以反过来让gradient沿着path分布，以及被clip等。</p><p>在上面应用clip绘制箭尾的例子里，我们把箭柄变成从左到右是灰-黑-灰的渐变，只需要在<code>addLine</code>并设置了line的宽度后(不要设颜色了），不是去<code>strokePath()</code>，而是：</p><div class="highlight"><pre><span></span><span class="n">con</span><span class="p">.</span><span class="n">replacePathWithStrokedPath</span><span class="p">()</span>  <span class="c1">// 不再strokePath</span>
<span class="n">con</span><span class="p">.</span><span class="n">clip</span><span class="p">()</span>                        <span class="c1">// 再clip一次，奇偶反转</span>
<span class="c1">// draw the gradient</span>
<span class="kd">let</span> <span class="nv">locs</span> <span class="p">:</span> <span class="p">[</span><span class="n">CGFloat</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">]</span>
<span class="kd">let</span> <span class="nv">colors</span> <span class="p">:</span> <span class="p">[</span><span class="n">CGFloat</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span>
        <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// starting color, transparent light gray</span>
        <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="c1">// intermediate color, darker less transparent gray</span>
        <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// ending color, transparent light gray</span>
    <span class="p">]</span>
<span class="kd">let</span> <span class="nv">sp</span> <span class="p">=</span> <span class="n">CGColorSpaceCreateDeviceGray</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">grad</span> <span class="p">=</span> <span class="n">CGGradient</span><span class="p">(</span>
    <span class="n">colorSpace</span><span class="p">:</span><span class="n">sp</span><span class="p">,</span> <span class="n">colorComponents</span><span class="p">:</span> <span class="n">colors</span><span class="p">,</span> <span class="n">locations</span><span class="p">:</span> <span class="n">locs</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span><span class="o">!</span>
<span class="n">con</span><span class="p">.</span><span class="n">drawLinearGradient</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">end</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">options</span><span class="p">:[])</span>
<span class="n">con</span><span class="p">.</span><span class="n">resetClip</span><span class="p">()</span> <span class="c1">// done clipping</span>
</pre></div>
<p>小技巧就是用<code>replacePathWithStrokedPath</code>假装进行了描边（所以只需要线宽并不需要线的颜色），返回了一个新的path，一条粗线变成了一个矩形框。<br />
而一旦添加了这个框，前面的奇偶关系就全反过来了，于是我们再<code>clip</code>一次，这就是头两行代码里做的事。</p><h3>Colors and Patterns</h3>
<p>当你的suer interface sytle changes(比如黑暗模式切换), <code>draw(_:)</code>方法会被立刻调用，被设置<code>UITraitCollection.current</code>，任何支持动态颜色的<code>UIColor</code>能变成相应的颜色，但是<code>CGColor</code>不能，你需要手动触发重绘。</p><p>UIKit使用pattern非常简单，把纹理绘制到图片上，然后从纹理图片提取出颜色信息，就能像别的颜色一样<code>setFill</code>了：</p><div class="highlight"><pre><span></span><span class="c1">// create the pattern image tile</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">stripes</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="n">ctx</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">imcon</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// paint the point of the arrow with it</span>
<span class="kd">let</span> <span class="nv">stripesPattern</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">patternImage</span><span class="p">:</span><span class="n">stripes</span><span class="p">)</span>
<span class="n">stripesPattern</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
</pre></div>
<p>而Core Graphics则要复杂（也更底层）得多，结合注释看代码：</p><div class="highlight"><pre><span></span><span class="n">con</span><span class="p">.</span><span class="n">saveGState</span><span class="p">()</span>
<span class="c1">// 非常重要，设置颜色空间</span>
<span class="kd">let</span> <span class="nv">sp2</span> <span class="p">=</span> <span class="n">CGColorSpace</span><span class="p">(</span><span class="n">patternBaseSpace</span><span class="p">:</span><span class="kc">nil</span><span class="p">)</span><span class="o">!</span>
<span class="n">con</span><span class="p">.</span><span class="n">setFillColorSpace</span><span class="p">(</span><span class="n">sp2</span><span class="p">)</span>
<span class="c1">// 纹理绘制真正发生的地方</span>
<span class="kd">let</span> <span class="nv">drawStripes</span> <span class="p">:</span> <span class="n">CGPatternDrawPatternCallback</span> <span class="p">=</span> <span class="p">{</span> <span class="kc">_</span><span class="p">,</span> <span class="n">con</span> <span class="k">in</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// 包装成一个callback给CGPattern使用</span>
<span class="kd">var</span> <span class="nv">callbacks</span> <span class="p">=</span> <span class="bp">CGPatternCallbacks</span><span class="p">(</span>
    <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">drawPattern</span><span class="p">:</span> <span class="n">drawStripes</span><span class="p">,</span> <span class="n">releaseInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// 一个struct</span>

<span class="c1">// 核心就是构造这个CGPattern</span>
<span class="kd">let</span> <span class="nv">patt</span> <span class="p">=</span> <span class="n">CGPattern</span><span class="p">(</span><span class="n">info</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>  <span class="c1">// cell大小</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="p">.</span><span class="n">identity</span><span class="p">,</span>    <span class="c1">// cell变换，这里没有，就用.identity</span>
    <span class="n">xStep</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">yStep</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>   <span class="c1">// 横向纵向复制cell时的步长</span>
    <span class="n">tiling</span><span class="p">:</span> <span class="p">.</span><span class="n">constantSpacingMinimalDistortion</span><span class="p">,</span>  <span class="c1">// 排列方式</span>
    <span class="n">isColored</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>      <span class="c1">// 是颜色还是画笔模式，选颜色true</span>
    <span class="n">callbacks</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">callbacks</span><span class="p">)</span><span class="o">!</span>  <span class="c1">// 纹理绘制的方法包在callback里面，传指针</span>
<span class="kd">var</span> <span class="nv">alph</span> <span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mf">1.0</span>
<span class="n">con</span><span class="p">.</span><span class="n">setFillPattern</span><span class="p">(</span><span class="n">patt</span><span class="p">,</span> <span class="n">colorComponents</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">alph</span><span class="p">)</span>
<span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="n">con</span><span class="p">.</span><span class="n">restoreGState</span><span class="p">()</span>
</pre></div>
<h3>Graphics Context Transforms</h3>
<p>跟前面的知识点一样，应用<em>Graphics Context Transforms</em>后，也不会影响当前已经绘制的东西。 =&gt; <code>CTM</code>即（<code>current transform matrix</code>)。</p><p>旋转的中心点是原点，大多数情况下不是你想要的，记得先translate一下。</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setShadow</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span> <span class="n">CGSize</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">blur</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">// 顺便演示下sahdow</span>
    <span class="n">con</span><span class="p">.</span><span class="n">beginTransparencyLayer</span><span class="p">(</span><span class="n">auxiliaryInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>  <span class="c1">// 这样重叠的阴影不会叠成黑色</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">arrow</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">3</span> <span class="p">{</span>
        <span class="n">con</span><span class="p">.</span><span class="n">translateBy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">translateBy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">arrow</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// 注意这里是用前面方法生成的箭头图片来draw到指定位置</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<figure  style="flex: 77.47747747747748" ><img width="688" height="444" src="/archives/assets/0059ea4156dffb9df15e77df8a87f971.png" alt=""/></figure><p>注意，语法虽然是先处理context，再绘制，其实只是告知坐标系的变化，绘制的时候自动应用这些变换。</p><h3>Erasing</h3>
<p><code>clear(_:)</code>擦除行为取决于context是透明还是实心的（透明擦成透明，实心擦成黑色），只要不是opaque，通通理解为透明，比如background color是nil, 或0.9999的透明度。</p><h2>Points and Pixels</h2>
<p><code>con.fill(CGRect(100,0,1.0/self.contentScaleFactor,100))</code>应用contentScaleFactor画一条在任何屏幕上都锐利的1像素直线。</p><h2>Content Mode</h2>
<p>the drawing system will <code>avoid</code> asking a view to <code>redraw</code> itself from scratch if possible; instead, it will use the <code>cached</code> result of the previous drawing operation (the <strong>bitmap backing store</strong>).</p><p>If the view is resized, the system may simply stretch or shrink or reposition the cached drawing, if your contentMode setting instructs it to do so.</p><p><code>draw(_:)</code>从原点开始绘制，所以你的<code>contentMode</code>也要相应设置为<code>topLeft</code>。而如果设置为<code>.redraw</code>，则不会使用cached content，每当view被resize的时候，就会调用<code>setNeedsDisplay</code>方法，最终触发<code>draw(_:)</code>进行重绘。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Drawing/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/View/" target="_self">Programming iOS 14 - View</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/View/" target="_self">
                <time class="text-uppercase">
                    December 22 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第1章</p><hr />
<h1>View</h1>
<ul>
<li>A view knows how to draw itself into a rectangular area of the interface.</li>
<li>A view is also a responder</li>
<li>init:<ul>
<li><code>init(frame:)</code>: init from code</li>
<li><code>init(coder:)</code>: init from nib</li>
</ul>
</li>
</ul>
<h2>Window and Root View</h2>
<ul>
<li>Window = top view, ultimate superview<ul>
<li>iPad with iOS 13+ can have multiple window</li>
</ul>
</li>
<li>only one subview: rootViewController's <code>main view</code> -&gt; occupy the entirety of the window</li>
</ul>
<h2>How an App Launches</h2>
<ul>
<li>Swift项目自动调用了<code>UIApplicationMain</code>方法，唯一方法，初始化了必要资源</li>
<li>初始化<code>UIApplicationMain</code>（你<code>UIApplication.shared</code>的来源），及其degate class(<code>@UIApplicationMain</code>)，并持有，贯穿app整个生命周期</li>
<li>UIApplicationMain calls the app delegate’s <code>application(_:didFinish- LaunchingWithOptions:)</code>, giving your code an opportunity run.</li>
<li>UIApplicationMain creates a <code>UISceneSession</code>, a <code>UIWindowScene</code>, and an instance that will serve as the window scene’s <code>delegate</code>.<ul>
<li>delegate由<em>plist.info / Application Scene Manifest / Delegate Class Name</em> 决定 (<code>$(PRODUCT_MODULE_NAME).SceneDelegate</code>)</li>
</ul>
</li>
<li>初始化root view<ul>
<li>UIApplicationMain根据plist判断是否使用了storyboard<ul>
<li>初始化UIWindow，并赋给scene delegate's <code>window</code> property</li>
<li>初始化initial view controller 并赋给window的<code>rootViewController</code>属性</li>
<li>UIAplicationMain call window's <code>makeKeyAndVisible</code>呈现Interface</li>
</ul>
</li>
<li>call scene delegate's <code>scene(_:willConnectTo:options:)</code><ul>
<li>这里也是没用storyboard的话，手动去实现上面几步的地方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Referring to the Windows</strong></p><ul>
<li><code>view.window</code>, if it's nil means it can't be visible to the user</li>
<li>scene delegate's <code>window</code> property</li>
<li><code>UIApplication.shared.windows.first!</code></li>
</ul>
<blockquote>
<p>Do not expect that the window you know about is the app’s only window. The runtime can create <code>additional mysterious windows</code>, such as the <code>UITextEffectsWindow</code> and the <code>UIRemoteKeyboardWindow</code>.</p></blockquote>
<h2>Subview and Superview</h2>
<p><strong>曾经</strong>，一个view拥有它对应的一个矩形区域，不属于它的subview的其它view在这个矩形内是看不见的，因为重绘矩形的时候是不会考虑到其它view的。同样，也不能draw到矩形区域外去。</p><p>OS X10.5起，苹果更新了关于View的架构，iOS也跟着改变了，subview能出现在superview之外（所以反而需要<code>clipping</code>了），一个view也能overlap到另一个view上而无需成为其subview（后来居上）。</p><p>结果就是，你现在看到几个互相重叠的我色块，你再也分辨不出view之间的层次关系了。（<code>isDescendant(of:)</code>可以检查层次关系）</p><p>没有清空subview的方法，所以：<code>myView.subviews.forEach {$0.removeFromSuperview()}</code></p><h2>Color</h2>
<ul>
<li>background color不设置表示这个view是透明的</li>
<li>如果再没有进行任何子view的绘制，那么这个view就看不见了</li>
<li>这种view可以作为容器来使用</li>
</ul>
<p>iOS 13起，引入黑暗模式后，硬编码的颜色就迎来了很大的问题。</p><ul>
<li>纠结的解决方法：</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span> <span class="p">{</span> <span class="n">tc</span> <span class="k">in</span>
        <span class="k">switch</span> <span class="n">tc</span><span class="p">.</span><span class="n">userInterfaceStyle</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">dark</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>其中, tc是<code>trait collection</code>，一系列特征的集合。</p><ul>
<li>而iOS 13起多了很多<code>.system</code>开头的color，可以自适应</li>
<li><em>asset catalog</em>中可以自定义颜色，并设置不同模式下的颜色</li>
</ul>
<h2>Visibility and Opacity</h2>
<p>隐藏一个view:</p><ul>
<li><code>isHidden</code>: view还在，但不会接受触摸事件<ul>
<li><code>alpha = 0</code>也会使得<code>isHidden == true</code></li>
</ul>
</li>
<li><code>isOpaque</code>: 它不影响可见性，但影响<strong>drawing system</strong><ul>
<li><code>opaque == true</code>的view不具有透明度，将拥有最高的渲染效率</li>
</ul>
</li>
<li><code>frame = CGRect.zero</code>的view也是不可见的</li>
</ul>
<h2>Frame, Bounds and Center</h2>
<ul>
<li>就是视图在父视图（坐标系）中的位置和大小。</li>
<li><code>sizeTofit</code>方法来适应内容的大小。</li>
<li><code>bound</code>原点设为(10, 10)意思是坐标系往左上角移了(10,10)的像素，即原来的(10,10)现在到了原点。<ul>
<li><code>bounds.insetBy(dx:dy)</code>是保持中心不变（即同时改变了原点和宽高）</li>
</ul>
</li>
<li><code>center</code>表示的是视图在父级中的位置，所以改变自己的bounds并不改变它的center<ul>
<li>本质上<code>frame</code>是center+宽度的便捷方法</li>
<li>如果v2是v1的子视图，<code>v2.center = v1.center</code> 通常不能生效，因为它们的坐标系不同（各自的父级）</li>
</ul>
</li>
</ul>
<h2>Transform and Transform3D</h2>
<ul>
<li>Transform改变View的绘制，但不改变它的bounds和center.</li>
<li>value is a <code>CGAffineTransform</code>，其实就是一个变换矩阵</li>
<li>CGPoint, CGSize, and CGRect all have an <code>applying(_:)</code> method 用来计算应用Transform后的坐标</li>
<li>3D版的就是多了一个垂直于屏幕的Z轴</li>
</ul>
<h2>Window Coordinates and Screen Coordinates</h2>
<ul>
<li>The device screen has <code>no frame</code>, but it has bounds.</li>
<li>The window has <code>no superview</code>, but its frame is set automatically to match the screen’s bounds.<ul>
<li>continues to fill the screen</li>
</ul>
</li>
</ul>
<p>iOS 7及之前，屏幕的坐标系是不变的，如果有旋转，则是对root view进行了一次rotation的transfrom。
但在iOS 8不再用transform而是制定了两套坐标系，通过<code>UICoordinateSpace</code>协议表示
    * UIScreen's <code>coordinateSpace</code>: 会旋转的bounds
    * UIScreen's <code>fixedCoordinateSpace</code>: 不变</p><p>读取视图v在设备的固定坐标系下的位置：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">screen</span> <span class="p">=</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">fixedCoordinateSpace</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">superview</span><span class="p">!.</span><span class="n">convert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">screen</span><span class="p">)</span>
</pre></div>
<h2>Trait Collections</h2>
<p>将view的一系列环境特征通过view hierarchy层级下传，通过服从<code>UITraitEnvironment</code>协议（提供<code>traitCollection</code>属性和<code>traitCollectionDidChange</code>方法）</p><p><strong>traitCollection</strong></p><ul>
<li><em>displayScale</em>: screen's resolution</li>
<li><em>userInterfaceIdiom</em>: general device type, iPhone, or ipad</li>
<li><em>interfaceStyle</em>: is in light/dark mode</li>
<li><em>userInterfaceLevel</em>: .base / .elevated -&gt; affects dynamic background colors</li>
</ul>
<blockquote>
<p>If you implement traitCollectionDidChange(_: ), <code>always call super in the first line</code>. Forgetting to do this is a common beginner mistake.</p></blockquote>
<p>自定义trait collection只能用下面这种“组合”的方式</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">tcdisp</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">displayScale</span><span class="p">:</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">scale</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tcphone</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceIdiom</span><span class="p">:</span> <span class="p">.</span><span class="n">phone</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tc1</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">traitsFrom</span><span class="p">:</span> <span class="p">[</span><span class="n">tcdisp</span><span class="p">,</span> <span class="n">tcphone</span><span class="p">])</span>  <span class="c1">// 取交集</span>
</pre></div>
<p>自动颜色的底层逻辑：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">yellow</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">systemYellow</span>
<span class="kd">let</span> <span class="nv">light</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">light</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">dark</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">dark</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">yellowLight</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">light</span><span class="p">)</span>
<span class="c1">// 1 0.8 0 1</span>
<span class="kd">let</span> <span class="nv">yellowDark</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">dark</span><span class="p">)</span>
<span class="c1">// 1 0.839216 0.0392157 1</span>
</pre></div>
<h3>Size Classes</h3>
<p>把屏幕针对宽高和比例做几个分类：</p><ul>
<li>.regular(h, v) -&gt; iPad</li>
<li>.compact(h) + .regular(v) -&gt; 竖屏iPhone</li>
<li>.regular(h) + .compact(v) -&gt; 横屏大iPhone</li>
<li>.compact(h, v) -&gt; 横屏小iPhone（5S以前的）</li>
</ul>
<p>所以, size class:</p><ul>
<li>并不能从<code>traitCollectionDidChange</code>获得，因为iPad永远是<code>.regular</code></li>
<li>只关心横竖向突然间.regular和.compact的切换</li>
</ul>
<p><strong>Overriding Trait Collections</strong></p><p>You cannot <code>insert</code> a trait collection directly into the inheritance hierarchy simply by setting a view’s trait collection;</p><p>For the user interface style, there is a simpler facility available both for a UIViewController and for a UIView: the <code>overrideUserInterfaceStyle</code> property. 
    * default <code>.unspecified</code>，意味着interface style会往下传
    * 一旦设为.dark或.light, 就拦截了<code>userInterfaceStyle</code>的继承</p><h2>Layout</h2>
<ul>
<li>Manual layout: <code>layoutSubviews</code>里手动摆放每个视图，可定制最强</li>
<li>Autoresizing: 子视图根据<code>autoresizingMask</code>来调整</li>
<li>Autolayout: 依赖对“约束”的描述来布局，背后仍然是<code>layoutSubviews</code><ul>
<li>需要禁止autoresizing</li>
</ul>
</li>
</ul>
<h3>Autoresizing</h3>
<p>Autoresizing is a matter of conceptually assigning a subview “<strong>springs and struts</strong>.” A spring can expand and contract; a strut can’t. Springs and struts can be assigned internally or externally, horizontally or vertically.</p><p>可变的就叫Spring(有弹性)，不变的就叫Strut（不知道怎么翻译）。</p><ul>
<li>一个居中的子视图，本身也会随着父视图而改变大小:<ul>
<li>意味着它与父视图的四个边距是不变的 -&gt; 4个外部决定的struts</li>
<li>宽高则是可变的 -&gt; 2个内部决定的spring</li>
</ul>
</li>
<li>而如果子视图不随环境改变大小：<ul>
<li>意思着宽高是固定的 -&gt; 2个内部决定的struts</li>
<li>而四个边距通通可变 -&gt; 4个外部决定的spring</li>
</ul>
</li>
<li>一个右下角摆放的OK button<ul>
<li>显然，按钮大小不改变 -&gt; 2个内部struts</li>
<li>与右边和底部距离不变 -&gt; 2个外部struts</li>
<li>与顶部和左边距离可变 -&gt; 2个外部spring</li>
</ul>
</li>
<li>一个顶部占满的text field<ul>
<li>高度不变 -&gt; 1个vertical struts（内部）</li>
<li>宽度可变 -&gt; 1个horizontal spring(内部)</li>
<li>顶，左，右三边距离不变 -&gt; 3个外部struts</li>
<li>底部距离可变 -&gt; 1个外部spring</li>
</ul>
</li>
</ul>
<p>所谓的“内部”，是因为教材里用的是internally，就例子来看，其实就是说衡量的对象只是自己，而“距离”明显需要有一个参照物，那就叫externally了。</p><p>通过<code>autoresizingMask</code>来描述上述例子中的规则，通过bitmask来进行组合，默认为全空（但是等同于<code>flexibleRightMargin</code>)，即普通的流式布局，靠左上对齐，右边距和底边距是动态的。</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">v1</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">194</span><span class="p">))</span>
<span class="n">v1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v2</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">v2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v1b</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">bounds</span>
<span class="kd">let</span> <span class="nv">v3</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="n">v1b</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">v1b</span><span class="p">.</span><span class="n">height</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">v3</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span>
</pre></div>
<p>演示了上例中的&quot;text fiels&quot;和“ok button&quot;，一个置顶，一个靠中下。并且都设置了绝对大小的宽高，那么当你改变v1的frame的时候，比如变宽变高，v2,v3会发生什么呢？</p><p>因为你没有设置autoresizingMask，那么就会默认保持左上的边距，这样v2不再铺满顶部，v3也不再紧贴右下角，想要它们跟着v1变化：</p><div class="highlight"><pre><span></span><span class="n">v2</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">.</span><span class="n">flexibleWidth</span>  <span class="c1">// 宽度可变</span>
<span class="n">v3</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleTopMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleLeftMargin</span><span class="p">]</span> <span class="c1">// 左，顶可变（这样就能尽情往右下贴了）</span>
</pre></div>
<blockquote>
<p>AutoResizing在<code>layoutSubviews</code>被调用之前发生。</p></blockquote>
<h3>Autolayout and Constraints</h3>
<p>autolayout的子view可以不用autolayout，但是父view必须是autolayout，层层向上到<code>main view</code> of it's view controller, which <em>receives autolayout-related events</em></p><p>autolayout描述不同view的属性之间的位置关系，这些view不必是兄弟，也不非得是父子，只需要保证拥有一个共同的祖先。</p><p>谁持有这些约束？</p><ul>
<li>如果是约束自身的宽度（绝对值） -&gt; 属于自身</li>
<li>如果是约束了它对superview的顶部的距离 -&gt; 属于superview</li>
<li>如果约束了几个sibling view的顶部对齐 -&gt; 属于这些view的superview</li>
</ul>
<p>事实上，iOS不需要你关心这个，<code>.activate</code>让你只管描述约束和关系，然后把它加到正确的view上。</p><p>约束基本上是可读的，除了<code>priority</code>, <code>constant</code>, 和 <code>isActive</code>，其它情况你只能移除并重建了。（还有一个跟约束无关的<code>identifier</code>， debug有用）</p><blockquote>
<p>autolayout发生在<code>layoutSubviews</code>，所以如果你提前设置了frame，图像将会发生跳动。如果你是在layoutSubviews里面设置的就不会。当然你最好线用约束。</p></blockquote>
<p>如果你的约束涉及到了别的之前并没用使用autolayout的view， The autolayout engine takes care of this for you:</p><ul>
<li>it <code>reads</code> the view’s <em>frame</em></li>
<li>and <em>autoresizingMask</em> settings and <code>translates</code> them into implicit constraints</li>
</ul>
<p>比如：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">lab1</span> <span class="p">=</span> <span class="bp">UILabel</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">270</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">22</span><span class="p">))</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleLeftMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleBottomMargin</span><span class="p">]</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">lab1</span><span class="p">)</span>
</pre></div>
<p>一个右上的label，如果你的另一个view相对<em>lab1</em>来设置autolayout的约束，那么lab1将会自动产生如下四个约束：</p>
<pre><code>1. &lt;NSAutoresizingMaskLayoutConstraint H:[UILabel:'Hello']-(63)-|&gt;
2. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.minY == 20&gt;
3. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.width == 42&gt;
4. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.height == 22&gt;
</code></pre>
<p>而且约束的具体数值以当前运行设备来定的，比如上例是iPhone8，屏幕宽度是375，那么：</p><ul>
<li>origin(270, 28) 能得到minY = 20 -&gt; 约束2</li>
<li>size(42, 22)能得到height = 22, width = 42 -&gt; 约束3，4</li>
<li>结合屏幕宽度，origin, size， 得到右边距离：(375 - 270 - 42 = 63) -&gt; 约束1</li>
</ul>
<p>但是如果后面还有别的约束的话，很容易千万冲突，毕竟都自动生成的，用户写代码的时候并不会在意当时自动生成的约束在其它场景是否也会有别的约束自动生成</p><p><code>translatesAutoresizingMaskIntoConstraints</code>干的就是这个，所以一般情况下是把它关掉的。</p><p>语法：</p><div class="highlight"><pre><span></span><span class="n">v1</span><span class="p">.</span><span class="n">addConstraint</span><span class="p">(</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">v2</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">relatedBy</span><span class="p">:</span> <span class="p">.</span><span class="bp">equal</span><span class="p">,</span>
        <span class="n">toItem</span><span class="p">:</span> <span class="n">v1</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">multiplier</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">)</span>


<span class="c1">// compact notation</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="n">lab1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
<h3>VFL (Visual format notation)</h3>
<p><code>&quot;V:|-10-[v2(20)]&quot;</code>这代表v2的顶部距离superview 10个point,高度是20。如果描述的是水平方向的，则是<strong>H</strong>，但H是默认的，可以省略。同样，H对应的括号里的数值会被理解为width.</p><p>v2是view的名字，通常你需要准备一个字典，这样就可以在<code>VFL</code>中用简单的文字对应任何view了</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;v2&quot;</span><span class="p">:</span><span class="n">v2</span><span class="p">,</span><span class="s">&quot;v3&quot;</span><span class="p">:</span><span class="n">v3</span><span class="p">]</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|[v2]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:|[v2(10)]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
<span class="p">].</span><span class="n">flatMap</span> <span class="p">{</span><span class="nv">$0</span><span class="p">})</span>
</pre></div>
<p>注意这里的flatMap，因为<code>constraints(withVisualFormat:)</code> 返的是一个数组，而期望是一个值，所以用map把$0取了出来。</p><p><code>&quot;[v1(&gt;=20@400,&lt;=30)]&quot;</code>，@后面接的是优先级</p><h3>new features</h3>
<p>iOS 10引入的<code>anchorWithOffset(to:)</code>，是什么意思？</p><p>它也是创建的一个anchor，也就是说可以应用<code>constrain(equalto:)</code>之类的方法，而它本身是一个dimension，所以dimension当然是可以用来比较的。</p><p>比如，我有一个view(v1)，摆在屏幕上面某位置，现在要摆一个view(v2)，希望它出现在v1和屏幕底部（或v1的superview，设为v0）的中间（即垂直居中），显然，如果要用dimension描述出来的话，那就是：</p><ul>
<li>v1底部到v2中间的距离</li>
<li>等于</li>
<li>v2中部到屏幕底部v0底部的距离</li>
</ul>
<div class="highlight"><pre><span></span><span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">v1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">)</span>
        <span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> 
    <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
<p>刻意写成了三行，与我上文的三段文字描述对应</p><p>iOS 11引入了运行时决定的spacing：</p>
<pre><code>constraint(equalToSystemSpacingAfter:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(lessThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(equalToSystemSpacingBelow:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingBelow:multiplier:)
constraint(lessThanOrEqualToSystemSpacingBelow:multiplier:)
</code></pre>
<h3>Margins and Guides</h3>
<ul>
<li>UIEdgeInsets是对布局的补充，增加“第二条边”</li>
<li>Layout guides -&gt; 没看明白</li>
<li>safe area可以表示为inset，也可以表示为guides<ul>
<li><code>additionalSafeAreaInsets</code>还能增加safe area</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">)</span>
</pre></div>
<p>subview might be positioned with respect to its superview’s <code>margins</code>, especially through an autolayout constraint. By <strong>default</strong>, a view has a margin of 8 on all four edges.
这更像是superview的padding，而iOS并没有padding的概念（因为它并不是CSS的盒子模型）</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">arr</span> <span class="p">=</span> <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|-[v]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">:</span><span class="n">v</span><span class="p">])</span>
</pre></div>
<ul>
<li><code>layoutMarginsGuide</code>是只读的，但UIView提供了<code>layoutMargins</code>属性（一个UIEdgeInsets）<ul>
<li>from iOS11: <code>directionalLayoutMargins</code>(其实就是用了trail, leading等)</li>
</ul>
</li>
<li>VFL中用短横线来代表对齐的是margin</li>
<li>margin会往下传，用<code>preservesSuperviewLayoutMargins</code>控制</li>
<li>margin与safearea不冲突，会自动相加，用<code>insetsLayoutMarginsFromSafeArea</code>关闭</li>
<li>viewController有<code>systemMinimumLayoutMargins</code>可以增加main view的margin(减小的话会静默失败，即无效)<ul>
<li>而<code>viewRespectsSystemMinimumLayoutMargins</code>设为false，就能突破这个限制：（上下为0，左右为16，大屏设备左右为20）</li>
</ul>
</li>
</ul>
<p><strong>Custom layout guides</strong></p><p>书中的例子是垂直平均分配几个view，然后发现是把layout guide当成一个view来做的</p><ul>
<li>每个view（除去最后一个） add一个guide</li>
<li>ABABABA排列，A是view,B是guide</li>
<li>A的底部=B的顶部（除去最后一个A）</li>
<li>A的顶部=B的底部（除去第一个A）</li>
<li>令B的高度相等</li>
</ul>
<p>就把4个A给垂直平均分配了，理解的难点就是guide也当作一个view来用，而语法上又是加到view的属性里的。同时，只要设置guide的高度相等，就会自动占用4个View之外的所有空间平均分配。
<figure  style="flex: 78.66449511400651" ><img width="966" height="614" src="/archives/assets/2629afe5515d8fa7df75f83b138083fa.png" alt=""/></figure></p><p>这么做只是为了演示layout guide，但是虽然理解了，也不知道能用它来干嘛？当成一个隐形的view去做布局？</p><p><strong>Constraint alignment</strong></p><p>通过设置view的<code>alignmentRectInsets</code>，可以改变constrains计算的起点。对我来说，又是一种padding?</p><p>同样的还有自定义baseline的<code>forFirstBaselineLayout and forLastBaselineLayout.</code></p><h3>Intrinsic Content Size</h3>
<p>button, label, image等会根据内容和预设有一个instrinsic content size，而且可以用来<strong>隐式地</strong>产生约束（<code>NSContentSizeLayoutConstraint</code>）</p><ul>
<li><code>contentHuggingPriority(for:)</code> 某方向上阻止扩大到比intrinsic size更大的优先级，默认250</li>
<li><code>contentCompressionResistancePriority(for:)</code>，阻止缩小的优先级，默认750</li>
<li><code>invalidateIntrinsicContentSize</code>就像invalidate a view，会触发重新计算size</li>
</ul>
<p><code>&quot;H:[lab1(&gt;=100)]-(&gt;=20)-[lab2(&gt;=100)]&quot;</code> 这两个label，在屏幕变小时，谁最先缩到100？</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">lab2</span><span class="p">.</span><span class="n">contentCompressionResistancePriority</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">setContentCompressionResistancePriority</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
</pre></div>
<p>这里把lab1阻止缩小的优先级调得更高，那么就是lab2会先缩小</p><h3>Self-Sizing Views</h3>
<p>前面讲的都是superview对subview的影响，这一节反过来，subview的大小影响superview。</p><p>假定一个没有设置宽高的view，包含了一个button，我们知道button是有其intrinsic size的（固定的高，宽度由按钮文字决定），</p><ul>
<li>所以这个view也就有了宽高。</li>
<li>但这个宽高拥有低优先级，不会与显式设定的宽高相冲突。</li>
<li>运行时调用<code>systemLayoutSizeFitting(_:)</code>可以让系统优优先级地去按这个size去layout。这个操作是昂贵和低效的。</li>
</ul>
<h3>Stack Views</h3>
<p>UIStackView仍然是自动布局体系里的，它的作用是（为其<code>arrangedSubviews</code>）生成一系列约束，可以理解为语法糖。</p><ul>
<li><code>arrangedSubviews</code>是<strong>subViews</strong>的一个子集</li>
<li>stackView也可以添加额外的subView</li>
<li><em>setCustomSpacing(_:after:)</em>设置额外的space</li>
<li>不要再对arrangedSubviews手动添加约束，基本会与你看不见的计算出来的约束冲突<ul>
<li>但stackview本身是可以用autolayout来布局的</li>
</ul>
</li>
</ul>
<p>此时再来看看前面的竖向排列元素，并且间隔相等的例子的写法：</p><div class="highlight"><pre><span></span><span class="c1">// give the stack view arranged subviews</span>
<span class="kd">let</span> <span class="nv">sv</span> <span class="p">=</span> <span class="bp">UIStackView</span><span class="p">(</span><span class="n">arrangedSubviews</span><span class="p">:</span> <span class="n">views</span><span class="p">)</span>
<span class="c1">// configure the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">axis</span> <span class="p">=</span> <span class="p">.</span><span class="n">vertical</span>
<span class="n">sv</span><span class="p">.</span><span class="n">alignment</span> <span class="p">=</span> <span class="p">.</span><span class="n">fill</span>
<span class="n">sv</span><span class="p">.</span><span class="n">distribution</span> <span class="p">=</span> <span class="p">.</span><span class="n">equalSpacing</span>
<span class="c1">// constrain the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="p">=</span> <span class="kc">false</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">marg</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span>
<span class="kd">let</span> <span class="nv">safe</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">safe</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
<p>顺便注意以下里对layoutMargin和safearea的引用，都是通过layout guide的。</p><blockquote>
<p>debug会发现stack view其实帮你做了你之前做的事：<code>generating UILayoutGuide objects and using them as spacers</code></p></blockquote>
<p>stack view还有一个特性就是能自适应<code>arrangedSubviews</code>的变化。如果你把它理解为一个计算引擎，可能就好理解了。</p><h3>Internationalization</h3>
<p>使用.leading, .trailing等是为了适应不同语言的左右顺序，引入到布局里却会出现问题，并不是从右到左的语言的横向布局就也要相应反转。UIView.semanticContentAttribute可以人为控制，</p><ul>
<li>默认值是.unspecified，</li>
<li>.playback or .spatial将会不应用翻转。</li>
<li>.forceLeftToRight or .forceRightToLeft则是手动指定一个方向</li>
</ul>
<p>UIView<code>.effectiveUserInterfaceLayoutDirection</code>能report出这个trait</p><blockquote>
<p>You can test your app’s right-to-left behavior easily by changing the scheme’s Run option Application Language to “Right to Left Pseudolanguage.”</p></blockquote>
<h3>Debug autolayout</h3>

<pre><code>(lldb) e -l objc -- [[UIApplication sharedApplication] windows][0]
(UIWindow *) $1 = ...
(lldb) e -l objc -O -- [$1 _autolayoutTrace]
</code></pre>
<p>To get a full list of the constraints responsible for positioning a particular view within its superview, log the results of calling the UIView instance method <code>constraintsAffectingLayout(for:)</code>.</p><h2>Configuring Layout in Nib</h2>
<p>这一部分内容建议打开Xcode对着原文操作，多为界面操作</p><h3>Conditional Interface Design</h3>
<p>wC, HR等用来表示宽高在正常和压缩空间里的不同组合。</p><p>思路：先架构通用的视图和约束，然后用两种方法之一来描述不同size class下的特殊布局：</p><ul>
<li>in the Attributes or Size inspector</li>
<li>design that difference in the canvas:</li>
</ul>
<h2>Xcode View Features</h2>
<h3>Designable Views and Inspectable Properties</h3>
<p>有关Xcode的预览这一节可以看看，以及<code>@IBDesignable</code>方法能在xib里面呈现（教程里是在<code>willMove(toSuperview)</code>方法里调用）</p><h2>Layout Events</h2>
<p><strong>updateConstraints</strong></p><ul>
<li>（向上冒泡）<code>propagated up</code> the hierarchy, starting at the deepest subview</li>
<li>called at launch time，然后几乎不会调用，除非手动</li>
<li>也从不直接调用，而是通过<ul>
<li><code>updateConstraintsIfNeeded</code>方法</li>
<li>或是<code>setNeedsUpdateConstraints</code></li>
</ul>
</li>
</ul>
<p><strong>traitCollectionDidChange(_:)</strong></p><ul>
<li>(向下传播)<code>propagated down</code> the hierarchy of UITraitEnvironments.</li>
</ul>
<p><strong>layoutSubviews</strong></p><ul>
<li>The layoutSubviews message is the moment when <code>layout actually takes place</code>.</li>
<li>（向下传播） <code>propagated down</code> the hierarchy, starting at the top (typically the root view) and working down to the deepest subview.</li>
<li>If you’re not using autolayout, layoutSubviews does <strong>nothing</strong> by default</li>
<li>layoutSubviews is your opportunity to perform manual layout <strong>after</strong> autoresizing has taken place.</li>
<li>If you are using autolayout, you <strong>must</strong> call super or the app will crash (with a helpful error message).</li>
<li>从不直接调用：<ul>
<li><code>layoutIfNeeded</code></li>
<li><code>setNeedsLayout</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>When you’re using autolayout, <code>what happens in layoutSubviews</code>?</p><ol>
<li>The runtime, having examined and resolved all the constraints affecting this view’s subviews,</li>
<li>and having worked out values for their center and bounds,</li>
<li>now simply assigns <code>center</code> and <code>bounds</code> values to them.</li>
</ol>
<p>In other words, layoutSubviews performs <strong>manual layout</strong>!</p></blockquote>
<p>所以如果你需要在auto layout之后微调，<code>layoutSubviews</code>是法定的入口：</p><ol>
<li>call <code>super</code>, causing all the subviews to adopt their new frames</li>
<li>examine those frames, 如果不满意，则对<code>frame</code>进行微调（或者<code>bounds</code>和<code>center</code>）</li>
</ol>
<p>这也是autolayout engine自己的步骤，要注意的是你必须要和autolayout engine来协作，并且<strong>不要</strong>调用<code>setNeedsUpdateConstraints</code>(时机已过)</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/View/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next text-muted">
                <span title="Viewing the first page."><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</span>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/2/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 walker</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="/assets/ExSearch/jquery.min.js"></script>
    <script src="/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="/assets/katex.min.css">
    <script defer src="/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>