<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/1bbb2a43193d2f7fa8ad9f28a2369945.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="AlanDecode" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase link-active" href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/move_from_jianshu/" target="_self">从简书到独立博客</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/move_from_jianshu/" target="_self">
                <time class="text-uppercase">
                    January 15 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><h2>原因</h2>
<p>在简书也写了10万余字了，可见我对简书也没别的意见，风传对程序员的不友好我也没怎么在意过，然而因为如下原因</p><ol>
<li>广告越来越多，为了显示广告，还把正文给藏了起来</li>
<li>没有TOC</li>
<li>会屏蔽文章</li>
<li>导出机制不完善，文章越多越以后想导出越麻烦</li>
<li>别的原因（比如self host)</li>
</ol>
<p>我还是决定迁移一次（上次是因为能用markdown的原因，从博客园迁出）</p><p>本来冲着TOC，是想选择掘金的（样式也好看），却发现掘金已经取消了批量导入的功能，一切的一切，都把我推向了独立博客，好歹至少没有各种限制。</p><p>这次仍然选择<code>githup pages</code>来做静态博客，好处不言而喻的，生成器本想继续用<code>hexo</code>，结果突然发现了一个叫<code>Maverick</code>的，它支持宽泛的md文件的路径和图片路径，并且支持本地图片和下载远程图片，这解决了<code>hexo</code>不支持本地图片的一个痛点，本来就是简单的需求，于是打算入坑这个并不热门的生成器：</p><ol>
<li>热度不高，开发者最近一次更新也至少6个月了</li>
<li>只有两个官方主题，一个没有TOC，一个不怎么好看，还有一个第三方主题，仍然没有TOC，就是目前我用的这个</li>
</ol>
<p>也就是说踩坑机率可能不低，也就是说，我因为<code>TOC</code>出坑，折腾了半天还是没有<code>TOC</code>...</p><h2>迁移记录</h2>
<ol>
<li>Maverick会扫描指定目录下的所有<code>.md</code>文件，不论目录结构，我做了一个<code>posts</code>目录专门用来存放源文件</li>
<li>打包下载简书的所有文章，google了一个导出所有md文件里图片并顺便把文件里的图片链接也改了的<a href="https://juejin.cn/post/6844904110244757511">方案</a><ul>
<li>我根据习惯的vscode笔记插件<code>dendron</code>的风格，使用统一的<code>assets</code>文件夹来保存图片，所以相应的markdown文件里引用图片也就用上了相对路径</li>
<li>原作者是仿照<code>typora</code>风格，每篇文章一个对应的assets文件夹</li>
</ul>
</li>
<li>在读文件的位置顺便把<code>frontmatter</code>加上，我是把文件放到了四个物理文件夹里让它遍历（整理下载文档的时候手动分类了），主要是为了能自动生成每篇文章的<code>category</code>（根据文件夹名）<ul>
<li>什么是<a href="https://github.com/AlanDecode/Maverick#file-arrangement-and-frontmatter">frontmatter</a>?</li>
<li>最终的脚本发布在<a href="https://gist.github.com/walkerwzy/0c75e9b90b0b1806cf0e4aaeb845a17e">这里</a></li>
</ul>
</li>
<li>最终选择了<a href="https://github.com/Reedo0910/Maverick-Theme-Prism">Prism</a>这个主题</li>
<li>标准流程部署完<code>Github Pages</code></li>
<li>绑域名，启用用ssl，这些都能在控制面板完成（DNS做一个CNAME需要去域名后台那边设置）</li>
<li>抄改了一个脚本，用来执行<code>Github Actions</code>，其实就是持续集成啦<ul>
<li>据说<code>xxxx.github.io</code>风格的repo名只能把网站发布在<code>main</code>分支上而不能是<code>gh_pages</code>上，因此，最终逻辑就是，代码往<code>source</code>分支提交，然后把生成的网站往<code>main</code>分支部署</li>
<li>去掉了缓存功能（踩坑了，以后研究）</li>
<li>CI脚本发布在<a href="https://gist.github.com/walkerwzy/3b896e08c64c3d07cfc66d709fae2010">这里</a></li>
</ul>
</li>
</ol>
<h2>排坑记录</h2>
<ol>
<li>简书下载下来的文本有时候有一些莫名其妙的不可打印字符，在build的时候Maverick这个工具都是直接报错处理，我不得不手动把这些字符找出来删除掉</li>
<li>生成<code>frontmatter</code>时如果有格式错误的也会直接挂掉，同样需要你人工排查，再把文本改对</li>
<li>以上都说明这个生成器的容错率是很低的，下面的不算坑，就是目前<code>Maverick</code>其实做得很单纯，就是生成器，而周边功能，比如生成博客模板，本地伺服/预览等功能都没有做，我考虑到各种编辑器都能设置代码片段，也没去干这个活了</li>
<li>缓存的坑，这里就不细说了，毕竟不是常发文，不在意每次build的时候有没有缓存</li>
<li>前面说了，主题太少，而且只有一个支持TOC的，很难看，我也没有去为选中的主题增加TOC了（要写CSS，响应式布局等），暂时目前这样吧</li>
</ol>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/move_from_jianshu/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">《Effective Objective-C 2.0》笔记第1-2章</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">
                <time class="text-uppercase">
                    January 14 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><figure class="vertical-figure" style="flex: 38.0" ><img width="912" height="1200" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ac920d0dab7ba40befbff58ed826b587.png" alt=""/></figure><blockquote>
<p>这个书当然中文版的，也很经典，我也读过了，但是嘛，老规矩，有原版还是读一遍原版，再加上英文水平也只有那么好，有机会能多读读在就多读读吧。一共就7章，52节，200多页，并不多。
此外，因为很多名词其实我们平时直接叫的就是英文，中文版里统统都给了一个中文翻译，反而更陌生了，有种“访达”的即视感。</p></blockquote>
<h1>Chapter 1: Accustoming Yourself to Objective-C</h1>
<h2>Item 1: Familiarize Yourself with Objective-C’s Roots</h2>
<ol>
<li><code>messaging structure</code> v.s. <code>function callihng</code><ul>
<li>in messaging structure, the <strong>runtime</strong> decides which code gets executed, while in function, the  <strong>compiler</strong> decides.</li>
<li><code>dynamic binding</code> v.s. <code>virtual table</code>  &lt;= 多态</li>
</ul>
</li>
<li><code>runtime component</code> v.s. <code>compiler</code><ul>
<li>含有所有让面向对象的OC能工作的 <em>data structures</em> and <em>functions</em><ul>
<li>比如，含有所有的memory-management methods</li>
</ul>
</li>
<li>更新runtime component就能提升性能，而无需重新编译</li>
</ul>
</li>
<li>Objective-C is a superset of C<ul>
<li>所以语法基本类似：<code>NSString *str = @&quot;The String</code></li>
<li>表示声明了一个变量，类型是<em>NSString *</em>，是一个指向NSString的指针</li>
<li>所有OC对象必须如此声明，对象内存也总是分配在heap space上<ul>
<li>这是分配到stack上：<code>NSString stackString</code> &lt;- 报错</li>
</ul>
</li>
<li>但指向这个对象的指针（<strong>pointer</strong>）是分配在<code>stack frame</code>里的，多个指向同一对象的指针就分配了多个内存<ul>
<li>每个内存大小就是一枚指针的大小</li>
<li>值也是一样</li>
</ul>
</li>
</ul>
</li>
<li>The memory allocated in the <code>heap</code> has to be <strong>managed directly</strong><ul>
<li>OC将堆内存管理抽象了出来，<code>runtime</code>进一步抽象成一套内存管理架构：<code>reference counting</code></li>
</ul>
</li>
<li>整个系统框架都要使用结构体，用对象会有额外的开销</li>
</ol>
<h2>Item 2: Minimize Importing Headers in Headers</h2>
<p>Objective-C, just like C and C++, makes use of <code>header files</code> and implementation files.</p><ol>
<li><code>forward declaring</code> -&gt; <code>@class SomeClass</code><ul>
<li>头文件里并不知道知道一些类的实现细节，只需要知道有这么一个类就行了</li>
<li>但是<code>.m</code>文件里就要自行去import一次这个class了</li>
<li>原则就是尽量延后引入头文件的时机，减少编译时间</li>
<li>还解决了互相引用的问题</li>
<li>引用<code>super class</code>, <code>protocol</code>等必须要知道细节，不能应用<code>forward declaring</code><ul>
<li>所以最好把protocol单独放在一个头文件，避免无谓地引用大文件，增加编译时间</li>
<li>但是<code>delegate</code>放到<code>class-continuation category</code>里面写更好（即在<strong>.m</strong>文件里写protocol和import），无需暴露到公共头文件</li>
</ul>
</li>
<li>关键词：<code>减小依赖</code>，<code>缩减编译时间</code></li>
</ul>
</li>
</ol>
<h2>Item 3: Prefer Literal Syntax over the Equivalent Methods</h2>
<ul>
<li>尽量使用字面量语法（<code>Literal Syntax</code>）创建和使用对象</li>
<li>字面量语法只是一个语法糖（<code>syntactic sugar</code>），推荐使用字面量，会减少代码量，但最好知道它对应的原始方法。（但是还是会有所区别，看下例）</li>
<li>用字面量初始数组，如果不是最后一个元素是nil，会报错，而原始的<code>arrayWithObjects:</code>方法则会在碰到第一个nil时当成是终止参数而正常执行（只保留nil前的元素初始化数组）<ul>
<li>作者说这反而是好事，未预料到的情况成功执行比报错更可怕，抛异常能更早地发现错误</li>
</ul>
</li>
<li>只能创建Foundation框架的对象，自定义对象不行（一般也没必要）</li>
<li>使用字面量语法创建出来的String, Array, Dict等都<code>immutable</code>的</li>
</ul>
<h2>Item 4: Prefer Typed Constants to Preprocessor #define</h2>
<ul>
<li><code>#define</code>本质是替换</li>
<li><code>#define</code>出来的是没有类型信息的</li>
<li>如果是声明在头文件中，引用了此头文件的代码都会应用此替换<ul>
<li>即使被重定义了，编译器也不会产生警告</li>
</ul>
</li>
<li>而常量就带了类型信息<ul>
<li><code>static NSString * const MyStringConstants = &quot;Hello world;</code></li>
<li>注意星号的位置，这里表示指针指向的是整个常量</li>
<li>如果把星号写到const后，那表示指针就是那个常量...</li>
</ul>
</li>
<li>定义常量的位置很重要（预处理指令也一样），不打算公开的话就在<code>.m</code>文件里定义</li>
<li>命令也很重要</li>
<li>否则成了全局变量，很可能”不经意“引起变量冲突/覆盖</li>
<li><code>static const</code>要一起使用，单独的<code>const</code>会报错<ul>
<li><code>static</code>不再是别的语言中的<strong>静态变量</strong>，而保是一个作用域声明</li>
<li>一个编译单元（<code>translation unit</code>）个输出一个目标文件（<code>object file</code>）<ul>
<li>考虑你编译一个c++文件，一个文件生成一个目标（二进制）文件，然后再链接。</li>
<li>所以一个编译单元一般是一个<code>.m</code>文件</li>
</ul>
</li>
<li>结合起来，<code>static</code>就是在一个目标文件内可见</li>
<li>如果不加<code>static</code>，编译器会添加一个<code>external symbol</code>（后面有详述），这样就有重定义风险了（<code>duplicate symbol</code>）</li>
</ul>
</li>
<li>最后，事实上<code>static const</code>一起用，编译器做的仍然是<strong>替换</strong>，而没有去创建符号（但此时已经有类型信息了）</li>
</ul>
<p>*如果需要公开，则添加到全局符号表（<code>global symbol table</code>）中：</p><div class="highlight"><pre><span></span><span class="c1">// In the header file</span>
<span class="k">extern</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="p">;</span><span class="w"></span>

<span class="c1">// In the implementation file</span>
<span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">@&quot;VALUE&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>上面解释了<code>static</code>，现在来解释<code>extern</code><ul>
<li><code>extern</code>表示向编译器保证全局符号表中将会有这个符号，其实就是要编译器不要继续检查</li>
<li>它知道链接成二进制文件后，肯定能找到这个常量</li>
</ul>
</li>
<li>所以在<code>.m</code>文件里正常定义和赋值，在<strong>任意</strong><code>.h</code>文件时给编译器打个招呼就行了</li>
<li>命名规范：<ul>
<li>如果是限定可见域的，用<code>k</code>开头就行了</li>
<li>如果会公开的，那么就用函数名作前缀（系统框架都是这么做的）</li>
</ul>
</li>
</ul>
<p><strong>external symbol</strong> V.S. <strong>global symbol</strong></p><blockquote>
<p>前文你已经知道了两种提升作用域的方式，区别在</p><ul>
<li>一个是通过不对const加static（添加external symbol），</li>
<li>一个是额外声明extern（添加到blobal symbol talbe）</li>
</ul>
</blockquote>
<h2>Item 5: Use Enumerations for States, Options, and Status Codes</h2>
<ul>
<li>枚举只是一种常量命名方式</li>
<li>语法很奇葩：<code>enum EOCConnectionState</code> state = EOCConnectionStateDisconnected;<ul>
<li>看高亮的部分，别人只要写一个type，它要连enum带名称写全</li>
</ul>
</li>
<li>所以一般会<code>typedef</code>一下：<code>typedef enum EOCConnectionState EOCConnectionState;</code><ul>
<li>现在就可以用<code>EOCConnectionState</code>这个type来定义变量了</li>
</ul>
</li>
<li>用enum来做选项(options)的时候，因为不是互斥的关系，选择bitwise OR operator来会直观很多（就是每一个二进制位代表一个状态）</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">UIViewAutoresizing</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingNone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleLeftMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleRightMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleTopMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleBottomMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<figure  style="flex: 66.52173913043478" ><img width="918" height="690" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4a634eedbb41d909a0b262a8f2f437ee.png" alt=""/></figure><ul>
<li>Foundation框架定义了一些辅助宏，以便支持新的C++标准对宏定义的增强同时还能兼容老的标准: <code>NS_ENUM</code>和<code>NS_OPTIONS</code><ul>
<li>特别是c++对枚举值里的bitwise操作结果需要显式转换</li>
<li>所以用到了<strong>可组合</strong>的option类的枚举，最好用<code>NS_OPTIONS</code>宏，否则用<code>NS_ENUM</code>就够了</li>
</ul>
</li>
<li>对enum应用<code>switch</code>最好不要加<code>default</code>，这样你添加了新的枚举值而忘记了处理，能及时得到错误反馈</li>
</ul>
<h1>Chapter 2: Objects, Messaging, and the Runtime</h1>
<h2>Item 6: Understand Properties</h2>
<ul>
<li><code>Properties</code> are an Objective-C feature providing encapsulation of the data an object contains.<ul>
<li>stored by <code>instance variables</code></li>
<li>accessed through <code>accessor methods</code> (getter, setter)<ul>
<li>can be written by complier automatically &lt;= <code>autosynthesis</code></li>
<li>introduced a <code>dot syntax</code> to  accessing the data</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看一下C++写法：</p><div class="highlight"><pre><span></span><span class="err">@</span><span class="n">interface</span><span class="w"> </span><span class="n">EOCPerson</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">NSObject</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="err">@</span><span class="k">public</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_firstName</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_lastName</span><span class="p">;</span><span class="w"> </span>
<span class="err">@</span><span class="k">private</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_someInternalData</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
<span class="err">@</span><span class="n">end</span><span class="w"></span>
</pre></div>
<ul>
<li>对象布局在编译期就确定了，所以就硬编码了每个属性在对象内存中的偏移量</li>
<li>所以如果对象布局变化了（比如增加了实例变量），这些偏移量就会出错，必须要重新编译。<ul>
<li>如果链接代码时使用了不同版本的类定义，就会产生这种“不兼容”的问题</li>
</ul>
</li>
<li>OC的解决方案是，把偏移量仍由“实例变量”存储<ul>
<li>但是交由“类对象“(class object)保管</li>
<li>偏移量在运行期查找 -&gt; 类的定义变了，偏移量也就变了（实时的）<ul>
<li>甚至可以在运行期向类中新增实例变量</li>
<li>nonfragile Application Binary Interface(ABI)</li>
<li>这样就可以不止在声明文件里定义实例变量，还可以在class-continuation和实现文件里面定义了</li>
</ul>
</li>
<li>尽量不要直接访问实例变量</li>
</ul>
</li>
<li>使用<code>点语法</code>访问属性<ul>
<li>编译器会转换为对存取方法的调用</li>
<li>编译器会为属性生成相应的实例变量，并自动合成（生成相应的存取方法）<ul>
<li>编译期进行，所以你看不到实际的代码</li>
<li>也可以手写同样的代码（这时你就可以自定义实例方法的签名了）</li>
<li><code>@dynamic</code>能阻止合成 &lt;= 相信运行期能找到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Property Attributes</h3>
<ol>
<li>原子性(<code>Atomicity</code>)，读写的时候加锁</li>
<li>读/写权限</li>
<li>内存管理语义<ul>
<li>assign: on scalar type</li>
<li>strong: 拥有关系，设置新值流程：retain new -&gt; release old -&gt; set new</li>
<li>weak: 非拥有关系</li>
<li>unsafe_unretained: 类似assign，但适用于对象类型（而不只有scalar type)<ul>
<li>与weak的区别在目标对象在销毁时，该属性值不会自动清空</li>
</ul>
</li>
<li>copy: 类似strong，但是相比起retain，它直接是复制了一份，通常用于拥有可变类型的变量，比如<code>NSString *</code>，可变版的string也能赋值给NSString，这就会引起赋值后值还自己变了的可能性</li>
</ul>
</li>
<li>方法名<ul>
<li>getter=<name>，需要注意的是有些bool类型的通常会设置为<code>isXXXX</code></li>
<li>setter=<name>，但很少这么做</li>
</ul>
</li>
</ol>
<p>如果自己来实现accessor methods，那么就要自己去保证这些方法符合这些attributes，比如内存管理语义为copy，那么在设置的时候就要拷贝传入的值：</p><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">EOCPerson</span> : <span class="bp">NSManagedObject</span><span class="w"> </span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">firstName</span><span class="p">;</span><span class="w"></span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">lastName</span><span class="p">;</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFirstName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">firstName</span><span class="w"> </span><span class="nf">lastName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">lastName</span><span class="p">;</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>

<span class="c1">// 实现文件：</span>
<span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">initWithFirstName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">firstName</span><span class="w"> </span><span class="n">lastName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">lastName</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nb">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">super</span><span class="w"> </span><span class="n">init</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_firstName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">firstName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">_lastName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">lastName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">self</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
<blockquote>
<ul>
<li>读写操作的原子性并不是线程安全</li>
<li>iOS中使用同步锁开销较大</li>
<li>实际iOS程序碰到多线程读写属性的场景也非常少</li>
<li>所以基本上都是声明为<code>nonatomic</code></li>
</ul>
</blockquote>
<h2>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h2>
<p>在对象内部优先访问实例变量。</p><p>直接访问而不用点语法的影响：</p><ul>
<li>不经过消息派发，速度快（编译器生成的代码会直接访问相应的内存）</li>
<li>不会调用setter，也绕过了相应的内存管理语义</li>
<li>不会触发KVO</li>
<li>没有机会在getter, setter中设置断点来调试</li>
<li>没有机会<code>lazy intialization</code>，而getter机制能在首次被调用到的时候才去初始化实例变量</li>
<li>初始化和dealloc的时候总是要直接用实例变量</li>
</ul>
<p>作者建议尽量在读取实例变量的时候直接访问，设置的时候用属性（会自动考虑内存管理语义）</p><h2>Item 8: Understand Object Equality</h2>
<p>其实就是理解NSObject自带的<code>isEqual:</code>方法。</p><ul>
<li><code>==</code>就是比指针</li>
<li><code>isEqual:</code>比的是<code>hash</code>，所以自定义的类要实现equality就要自行实现这两个方法<ul>
<li>hash不同必然对象不同，但由于有hash collisions的存在，反过来并不成立</li>
<li>尽量用对象的不可变部分来做hash</li>
</ul>
</li>
</ul>
<p>一个做hash的方法：</p><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_firstName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_lastName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">ageHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_age</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">ageHash</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>Item 9: Use the Class Cluster Pattern to Hide Implementation Detail</h2>
<div class="highlight"><pre><span></span><span class="p">+</span> <span class="p">(</span><span class="bp">UIButton</span><span class="o">*</span><span class="p">)</span><span class="nf">buttonWithType:</span><span class="p">(</span><span class="n">UIButtonType</span><span class="p">)</span><span class="nv">type</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>作者将上述这种解释为“类族”，即它的返回值可能是各种button，但归根结底，都是<code>UIButton</code>，就是靠着switch各种type来实例化各种子类。</li>
<li>同时，因为OC没有abstract class，为了避免直接使用抽象基类，一般不提供init方法，并在基类相关方法里干脆抛异常</li>
<li>这里使用<code>isMemberOfClass</code>就要小心，它是kind，但不一定是member</li>
<li>系统框架里有很多<code>class cluster</code>，特别是<code>collection</code><ul>
<li>所以<code>if([anArray class] == [NSArray class])</code>是false（原因就是它是被当作“<strong>抽象基类</strong>来设计的，实际上是隐藏在公共接口后面的某个内部类型）</li>
<li>同样，用<code>isKindOfClass:</code>至少能判断是在这个类族里</li>
</ul>
</li>
</ul>
<h2>Item 10: Use Associated Objects to Attach Custom Data to Existing Classes</h2>
<p>扩展现有类，我们可以继承，但有时候一些特殊机制创建的类却无法继承，可以通过<code>Associated Object</code>来添加这些信息。</p><ul>
<li>以键值对来存储，所以是可以存储多个关联数据的</li>
<li>可以指定storage policy，对应内存管理语义</li>
</ul>
<figure  style="flex: 140.1840490797546" ><img width="914" height="326" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/820ae39c34d1147867f1dfb6f1d64de3.png" alt=""/></figure><p>方法:</p><div class="highlight"><pre><span></span><span class="c1">// Sets up an association of object to value with the given key and policy.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">objc_AssociationPolicy</span><span class="w"> </span><span class="n">policy</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Retrieves the value for the association on object with the given key.</span>
<span class="kt">id</span><span class="w"> </span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Removes all associations against object.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>书中写了一个例子，alertView的代理方法来处理按了什么键，而一个页面中如果有多个alertView，且用同一个代理对象，那么处理需要更精细（比如需要知道是哪个警告框弹的，我一般用tag）。
而如果把处理方法定义为一个block，并把它关联到UIAlertView类，那么处理逻辑就可以跟定义alertView写在一起了。</p><p>todo, item 11-14</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/View/" target="_self">View</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/View/" target="_self">
                <time class="text-uppercase">
                    December 22 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第1章</p><hr />
<h1>View</h1>
<ul>
<li>A view knows how to draw itself into a rectangular area of the interface.</li>
<li>A view is also a responder</li>
<li>init:<ul>
<li><code>init(frame:)</code>: init from code</li>
<li><code>init(coder:)</code>: init from nib</li>
</ul>
</li>
</ul>
<h2>Window and Root View</h2>
<ul>
<li>Window = top view, ultimate superview<ul>
<li>iPad with iOS 13+ can have multiple window</li>
</ul>
</li>
<li>only one subview: rootViewController's <code>main view</code> -&gt; occupy the entirety of the window</li>
</ul>
<h2>How an App Launches</h2>
<ul>
<li>Swift项目自动调用了<code>UIApplicationMain</code>方法，唯一方法，初始化了必要资源</li>
<li>初始化<code>UIApplicationMain</code>（你<code>UIApplication.shared</code>的来源），及其degate class(<code>@UIApplicationMain</code>)，并持有，贯穿app整个生命周期</li>
<li>UIApplicationMain calls the app delegate’s <code>application(_:didFinish- LaunchingWithOptions:)</code>, giving your code an opportunity run.</li>
<li>UIApplicationMain creates a <code>UISceneSession</code>, a <code>UIWindowScene</code>, and an instance that will serve as the window scene’s <code>delegate</code>.<ul>
<li>delegate由<em>plist.info / Application Scene Manifest / Delegate Class Name</em> 决定 (<code>$(PRODUCT_MODULE_NAME).SceneDelegate</code>)</li>
</ul>
</li>
<li>初始化root view<ul>
<li>UIApplicationMain根据plist判断是否使用了storyboard<ul>
<li>初始化UIWindow，并赋给scene delegate's <code>window</code> property</li>
<li>初始化initial view controller 并赋给window的<code>rootViewController</code>属性</li>
<li>UIAplicationMain call window's <code>makeKeyAndVisible</code>呈现Interface</li>
</ul>
</li>
<li>call scene delegate's <code>scene(_:willConnectTo:options:)</code><ul>
<li>这里也是没用storyboard的话，手动去实现上面几步的地方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Referring to the Windows</strong></p><ul>
<li><code>view.window</code>, if it's nil means it can't be visible to the user</li>
<li>scene delegate's <code>window</code> property</li>
<li><code>UIApplication.shared.windows.first!</code></li>
</ul>
<blockquote>
<p>Do not expect that the window you know about is the app’s only window. The runtime can create <code>additional mysterious windows</code>, such as the <code>UITextEffectsWindow</code> and the <code>UIRemoteKeyboardWindow</code>.</p></blockquote>
<h2>Subview and Superview</h2>
<p><strong>曾经</strong>，一个view拥有它对应的一个矩形区域，不属于它的subview的其它view在这个矩形内是看不见的，因为重绘矩形的时候是不会考虑到其它view的。同样，也不能draw到矩形区域外去。</p><p>OS X10.5起，苹果更新了关于View的架构，iOS也跟着改变了，subview能出现在superview之外（所以反而需要<code>clipping</code>了），一个view也能overlap到另一个view上而无需成为其subview（后来居上）。</p><p>结果就是，你现在看到几个互相重叠的我色块，你再也分辨不出view之间的层次关系了。（<code>isDescendant(of:)</code>可以检查层次关系）</p><p>没有清空subview的方法，所以：<code>myView.subviews.forEach {$0.removeFromSuperview()}</code></p><h2>Color</h2>
<ul>
<li>background color不设置表示这个view是透明的</li>
<li>如果再没有进行任何子view的绘制，那么这个view就看不见了</li>
<li>这种view可以作为容器来使用</li>
</ul>
<p>iOS 13起，引入黑暗模式后，硬编码的颜色就迎来了很大的问题。</p><ul>
<li>纠结的解决方法：</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span> <span class="p">{</span> <span class="n">tc</span> <span class="k">in</span>
        <span class="k">switch</span> <span class="n">tc</span><span class="p">.</span><span class="n">userInterfaceStyle</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">dark</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>其中, tc是<code>trait collection</code>，一系列特征的集合。</p><ul>
<li>而iOS 13起多了很多<code>.system</code>开头的color，可以自适应</li>
<li><em>asset catalog</em>中可以自定义颜色，并设置不同模式下的颜色</li>
</ul>
<h2>Visibility and Opacity</h2>
<p>隐藏一个view:</p><ul>
<li><code>isHidden</code>: view还在，但不会接受触摸事件<ul>
<li><code>alpha = 0</code>也会使得<code>isHidden == true</code></li>
</ul>
</li>
<li><code>isOpaque</code>: 它不影响可见性，但影响<strong>drawing system</strong><ul>
<li><code>opaque == true</code>的view不具有透明度，将拥有最高的渲染效率</li>
</ul>
</li>
<li><code>frame = CGRect.zero</code>的view也是不可见的</li>
</ul>
<h2>Frame, Bounds and Center</h2>
<ul>
<li>就是视图在父视图（坐标系）中的位置和大小。</li>
<li><code>sizeTofit</code>方法来适应内容的大小。</li>
<li><code>bound</code>原点设为(10, 10)意思是坐标系往左上角移了(10,10)的像素，即原来的(10,10)现在到了原点。<ul>
<li><code>bounds.insetBy(dx:dy)</code>是保持中心不变（即同时改变了原点和宽高）</li>
</ul>
</li>
<li><code>center</code>表示的是视图在父级中的位置，所以改变自己的bounds并不改变它的center<ul>
<li>本质上<code>frame</code>是center+宽度的便捷方法</li>
<li>如果v2是v1的子视图，<code>v2.center = v1.center</code> 通常不能生效，因为它们的坐标系不同（各自的父级）</li>
</ul>
</li>
</ul>
<h2>Transform and Transform3D</h2>
<ul>
<li>Transform改变View的绘制，但不改变它的bounds和center.</li>
<li>value is a <code>CGAffineTransform</code>，其实就是一个变换矩阵</li>
<li>CGPoint, CGSize, and CGRect all have an <code>applying(_:)</code> method 用来计算应用Transform后的坐标</li>
<li>3D版的就是多了一个垂直于屏幕的Z轴</li>
</ul>
<h2>Window Coordinates and Screen Coordinates</h2>
<ul>
<li>The device screen has <code>no frame</code>, but it has bounds.</li>
<li>The window has <code>no superview</code>, but its frame is set automatically to match the screen’s bounds.<ul>
<li>continues to fill the screen</li>
</ul>
</li>
</ul>
<p>iOS 7及之前，屏幕的坐标系是不变的，如果有旋转，则是对root view进行了一次rotation的transfrom。
但在iOS 8不再用transform而是制定了两套坐标系，通过<code>UICoordinateSpace</code>协议表示
    * UIScreen's <code>coordinateSpace</code>: 会旋转的bounds
    * UIScreen's <code>fixedCoordinateSpace</code>: 不变</p><p>读取视图v在设备的固定坐标系下的位置：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">screen</span> <span class="p">=</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">fixedCoordinateSpace</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">superview</span><span class="p">!.</span><span class="n">convert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">screen</span><span class="p">)</span>
</pre></div>
<h2>Trait Collections</h2>
<p>将view的一系列环境特征通过view hierarchy层级下传，通过服从<code>UITraitEnvironment</code>协议（提供<code>traitCollection</code>属性和<code>traitCollectionDidChange</code>方法）</p><p><strong>traitCollection</strong></p><ul>
<li><em>displayScale</em>: screen's resolution</li>
<li><em>userInterfaceIdiom</em>: general device type, iPhone, or ipad</li>
<li><em>interfaceStyle</em>: is in light/dark mode</li>
<li><em>userInterfaceLevel</em>: .base / .elevated -&gt; affects dynamic background colors</li>
</ul>
<blockquote>
<p>If you implement traitCollectionDidChange(_: ), <code>always call super in the first line</code>. Forgetting to do this is a common beginner mistake.</p></blockquote>
<p>自定义trait collection只能用下面这种“组合”的方式</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">tcdisp</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">displayScale</span><span class="p">:</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">scale</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tcphone</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceIdiom</span><span class="p">:</span> <span class="p">.</span><span class="n">phone</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tc1</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">traitsFrom</span><span class="p">:</span> <span class="p">[</span><span class="n">tcdisp</span><span class="p">,</span> <span class="n">tcphone</span><span class="p">])</span>  <span class="c1">// 取交集</span>
</pre></div>
<p>自动颜色的底层逻辑：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">yellow</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">systemYellow</span>
<span class="kd">let</span> <span class="nv">light</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">light</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">dark</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">dark</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">yellowLight</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">light</span><span class="p">)</span>
<span class="c1">// 1 0.8 0 1</span>
<span class="kd">let</span> <span class="nv">yellowDark</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">dark</span><span class="p">)</span>
<span class="c1">// 1 0.839216 0.0392157 1</span>
</pre></div>
<h3>Size Classes</h3>
<p>把屏幕针对宽高和比例做几个分类：</p><ul>
<li>.regular(h, v) -&gt; iPad</li>
<li>.compact(h) + .regular(v) -&gt; 竖屏iPhone</li>
<li>.regular(h) + .compact(v) -&gt; 横屏大iPhone</li>
<li>.compact(h, v) -&gt; 横屏小iPhone（5S以前的）</li>
</ul>
<p>所以, size class:</p><ul>
<li>并不能从<code>traitCollectionDidChange</code>获得，因为iPad永远是<code>.regular</code></li>
<li>只关心横竖向突然间.regular和.compact的切换</li>
</ul>
<p><strong>Overriding Trait Collections</strong></p><p>You cannot <code>insert</code> a trait collection directly into the inheritance hierarchy simply by setting a view’s trait collection;</p><p>For the user interface style, there is a simpler facility available both for a UIViewController and for a UIView: the <code>overrideUserInterfaceStyle</code> property. 
    * default <code>.unspecified</code>，意味着interface style会往下传
    * 一旦设为.dark或.light, 就拦截了<code>userInterfaceStyle</code>的继承</p><h2>Layout</h2>
<ul>
<li>Manual layout: <code>layoutSubviews</code>里手动摆放每个视图，可定制最强</li>
<li>Autoresizing: 子视图根据<code>autoresizingMask</code>来调整</li>
<li>Autolayout: 依赖对“约束”的描述来布局，背后仍然是<code>layoutSubviews</code><ul>
<li>需要禁止autoresizing</li>
</ul>
</li>
</ul>
<h3>Autoresizing</h3>
<p>Autoresizing is a matter of conceptually assigning a subview “<strong>springs and struts</strong>.” A spring can expand and contract; a strut can’t. Springs and struts can be assigned internally or externally, horizontally or vertically.</p><p>可变的就叫Spring(有弹性)，不变的就叫Strut（不知道怎么翻译）。</p><ul>
<li>一个居中的子视图，本身也会随着父视图而改变大小:<ul>
<li>意味着它与父视图的四个边距是不变的 -&gt; 4个外部决定的struts</li>
<li>宽高则是可变的 -&gt; 2个内部决定的spring</li>
</ul>
</li>
<li>而如果子视图不随环境改变大小：<ul>
<li>意思着宽高是固定的 -&gt; 2个内部决定的struts</li>
<li>而四个边距通通可变 -&gt; 4个外部决定的spring</li>
</ul>
</li>
<li>一个右下角摆放的OK button<ul>
<li>显然，按钮大小不改变 -&gt; 2个内部struts</li>
<li>与右边和底部距离不变 -&gt; 2个外部struts</li>
<li>与顶部和左边距离可变 -&gt; 2个外部spring</li>
</ul>
</li>
<li>一个顶部占满的text field<ul>
<li>高度不变 -&gt; 1个vertical struts（内部）</li>
<li>宽度可变 -&gt; 1个horizontal spring(内部)</li>
<li>顶，左，右三边距离不变 -&gt; 3个外部struts</li>
<li>底部距离可变 -&gt; 1个外部spring</li>
</ul>
</li>
</ul>
<p>所谓的“内部”，是因为教材里用的是internally，就例子来看，其实就是说衡量的对象只是自己，而“距离”明显需要有一个参照物，那就叫externally了。</p><p>通过<code>autoresizingMask</code>来描述上述例子中的规则，通过bitmask来进行组合，默认为全空（但是等同于<code>flexibleRightMargin</code>)，即普通的流式布局，靠左上对齐，右边距和底边距是动态的。</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">v1</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">194</span><span class="p">))</span>
<span class="n">v1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v2</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">v2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v1b</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">bounds</span>
<span class="kd">let</span> <span class="nv">v3</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="n">v1b</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">v1b</span><span class="p">.</span><span class="n">height</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">v3</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span>
</pre></div>
<p>演示了上例中的&quot;text fiels&quot;和“ok button&quot;，一个置顶，一个靠中下。并且都设置了绝对大小的宽高，那么当你改变v1的frame的时候，比如变宽变高，v2,v3会发生什么呢？</p><p>因为你没有设置autoresizingMask，那么就会默认保持左上的边距，这样v2不再铺满顶部，v3也不再紧贴右下角，想要它们跟着v1变化：</p><div class="highlight"><pre><span></span><span class="n">v2</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">.</span><span class="n">flexibleWidth</span>  <span class="c1">// 宽度可变</span>
<span class="n">v3</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleTopMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleLeftMargin</span><span class="p">]</span> <span class="c1">// 左，顶可变（这样就能尽情往右下贴了）</span>
</pre></div>
<blockquote>
<p>AutoResizing在<code>layoutSubviews</code>被调用之前发生。</p></blockquote>
<h3>Autolayout and Constraints</h3>
<p>autolayout的子view可以不用autolayout，但是父view必须是autolayout，层层向上到<code>main view</code> of it's view controller, which <em>receives autolayout-related events</em></p><p>autolayout描述不同view的属性之间的位置关系，这些view不必是兄弟，也不非得是父子，只需要保证拥有一个共同的祖先。</p><p>谁持有这些约束？</p><ul>
<li>如果是约束自身的宽度（绝对值） -&gt; 属于自身</li>
<li>如果是约束了它对superview的顶部的距离 -&gt; 属于superview</li>
<li>如果约束了几个sibling view的顶部对齐 -&gt; 属于这些view的superview</li>
</ul>
<p>事实上，iOS不需要你关心这个，<code>.activate</code>让你只管描述约束和关系，然后把它加到正确的view上。</p><p>约束基本上是可读的，除了<code>priority</code>, <code>constant</code>, 和 <code>isActive</code>，其它情况你只能移除并重建了。（还有一个跟约束无关的<code>identifier</code>， debug有用）</p><blockquote>
<p>autolayout发生在<code>layoutSubviews</code>，所以如果你提前设置了frame，图像将会发生跳动。如果你是在layoutSubviews里面设置的就不会。当然你最好线用约束。</p></blockquote>
<p>如果你的约束涉及到了别的之前并没用使用autolayout的view， The autolayout engine takes care of this for you:</p><ul>
<li>it <code>reads</code> the view’s <em>frame</em></li>
<li>and <em>autoresizingMask</em> settings and <code>translates</code> them into implicit constraints</li>
</ul>
<p>比如：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">lab1</span> <span class="p">=</span> <span class="bp">UILabel</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">270</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">22</span><span class="p">))</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleLeftMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleBottomMargin</span><span class="p">]</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">lab1</span><span class="p">)</span>
</pre></div>
<p>一个右上的label，如果你的另一个view相对<em>lab1</em>来设置autolayout的约束，那么lab1将会自动产生如下四个约束：</p>
<pre><code>1. &lt;NSAutoresizingMaskLayoutConstraint H:[UILabel:'Hello']-(63)-|&gt;
2. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.minY == 20&gt;
3. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.width == 42&gt;
4. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.height == 22&gt;
</code></pre>
<p>而且约束的具体数值以当前运行设备来定的，比如上例是iPhone8，屏幕宽度是375，那么：</p><ul>
<li>origin(270, 28) 能得到minY = 20 -&gt; 约束2</li>
<li>size(42, 22)能得到height = 22, width = 42 -&gt; 约束3，4</li>
<li>结合屏幕宽度，origin, size， 得到右边距离：(375 - 270 - 42 = 63) -&gt; 约束1</li>
</ul>
<p>但是如果后面还有别的约束的话，很容易千万冲突，毕竟都自动生成的，用户写代码的时候并不会在意当时自动生成的约束在其它场景是否也会有别的约束自动生成</p><p><code>translatesAutoresizingMaskIntoConstraints</code>干的就是这个，所以一般情况下是把它关掉的。</p><p>语法：</p><div class="highlight"><pre><span></span><span class="n">v1</span><span class="p">.</span><span class="n">addConstraint</span><span class="p">(</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">v2</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">relatedBy</span><span class="p">:</span> <span class="p">.</span><span class="bp">equal</span><span class="p">,</span>
        <span class="n">toItem</span><span class="p">:</span> <span class="n">v1</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">multiplier</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">)</span>


<span class="c1">// compact notation</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="n">lab1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
<h3>VFL (Visual format notation)</h3>
<p><code>&quot;V:|-10-[v2(20)]&quot;</code>这代表v2的顶部距离superview 10个point,高度是20。如果描述的是水平方向的，则是<strong>H</strong>，但H是默认的，可以省略。同样，H对应的括号里的数值会被理解为width.</p><p>v2是view的名字，通常你需要准备一个字典，这样就可以在<code>VFL</code>中用简单的文字对应任何view了</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;v2&quot;</span><span class="p">:</span><span class="n">v2</span><span class="p">,</span><span class="s">&quot;v3&quot;</span><span class="p">:</span><span class="n">v3</span><span class="p">]</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|[v2]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:|[v2(10)]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
<span class="p">].</span><span class="n">flatMap</span> <span class="p">{</span><span class="nv">$0</span><span class="p">})</span>
</pre></div>
<p>注意这里的flatMap，因为<code>constraints(withVisualFormat:)</code> 返的是一个数组，而期望是一个值，所以用map把$0取了出来。</p><p><code>&quot;[v1(&gt;=20@400,&lt;=30)]&quot;</code>，@后面接的是优先级</p><h3>new features</h3>
<p>iOS 10引入的<code>anchorWithOffset(to:)</code>，是什么意思？</p><p>它也是创建的一个anchor，也就是说可以应用<code>constrain(equalto:)</code>之类的方法，而它本身是一个dimension，所以dimension当然是可以用来比较的。</p><p>比如，我有一个view(v1)，摆在屏幕上面某位置，现在要摆一个view(v2)，希望它出现在v1和屏幕底部（或v1的superview，设为v0）的中间（即垂直居中），显然，如果要用dimension描述出来的话，那就是：</p><ul>
<li>v1底部到v2中间的距离</li>
<li>等于</li>
<li>v2中部到屏幕底部v0底部的距离</li>
</ul>
<div class="highlight"><pre><span></span><span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">v1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">)</span>
        <span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> 
    <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
<p>刻意写成了三行，与我上文的三段文字描述对应</p><p>iOS 11引入了运行时决定的spacing：</p>
<pre><code>constraint(equalToSystemSpacingAfter:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(lessThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(equalToSystemSpacingBelow:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingBelow:multiplier:)
constraint(lessThanOrEqualToSystemSpacingBelow:multiplier:)
</code></pre>
<h3>Margins and Guides</h3>
<ul>
<li>UIEdgeInsets是对布局的补充，增加“第二条边”</li>
<li>Layout guides -&gt; 没看明白</li>
<li>safe area可以表示为inset，也可以表示为guides<ul>
<li><code>additionalSafeAreaInsets</code>还能增加safe area</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">)</span>
</pre></div>
<p>subview might be positioned with respect to its superview’s <code>margins</code>, especially through an autolayout constraint. By <strong>default</strong>, a view has a margin of 8 on all four edges.
这更像是superview的padding，而iOS并没有padding的概念（因为它并不是CSS的盒子模型）</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">arr</span> <span class="p">=</span> <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|-[v]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">:</span><span class="n">v</span><span class="p">])</span>
</pre></div>
<ul>
<li><code>layoutMarginsGuide</code>是只读的，但UIView提供了<code>layoutMargins</code>属性（一个UIEdgeInsets）<ul>
<li>from iOS11: <code>directionalLayoutMargins</code>(其实就是用了trail, leading等)</li>
</ul>
</li>
<li>VFL中用短横线来代表对齐的是margin</li>
<li>margin会往下传，用<code>preservesSuperviewLayoutMargins</code>控制</li>
<li>margin与safearea不冲突，会自动相加，用<code>insetsLayoutMarginsFromSafeArea</code>关闭</li>
<li>viewController有<code>systemMinimumLayoutMargins</code>可以增加main view的margin(减小的话会静默失败，即无效)<ul>
<li>而<code>viewRespectsSystemMinimumLayoutMargins</code>设为false，就能突破这个限制：（上下为0，左右为16，大屏设备左右为20）</li>
</ul>
</li>
</ul>
<p><strong>Custom layout guides</strong></p><p>书中的例子是垂直平均分配几个view，然后发现是把layout guide当成一个view来做的</p><ul>
<li>每个view（除去最后一个） add一个guide</li>
<li>ABABABA排列，A是view,B是guide</li>
<li>A的底部=B的顶部（除去最后一个A）</li>
<li>A的顶部=B的底部（除去第一个A）</li>
<li>令B的高度相等</li>
</ul>
<p>就把4个A给垂直平均分配了，理解的难点就是guide也当作一个view来用，而语法上又是加到view的属性里的。同时，只要设置guide的高度相等，就会自动占用4个View之外的所有空间平均分配。
<figure  style="flex: 78.66449511400651" ><img width="966" height="614" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2629afe5515d8fa7df75f83b138083fa.png" alt=""/></figure></p><p>这么做只是为了演示layout guide，但是虽然理解了，也不知道能用它来干嘛？当成一个隐形的view去做布局？</p><p><strong>Constraint alignment</strong></p><p>通过设置view的<code>alignmentRectInsets</code>，可以改变constrains计算的起点。对我来说，又是一种padding?</p><p>同样的还有自定义baseline的<code>forFirstBaselineLayout and forLastBaselineLayout.</code></p><h3>Intrinsic Content Size</h3>
<p>button, label, image等会根据内容和预设有一个instrinsic content size，而且可以用来<strong>隐式地</strong>产生约束（<code>NSContentSizeLayoutConstraint</code>）</p><ul>
<li><code>contentHuggingPriority(for:)</code> 某方向上阻止扩大到比intrinsic size更大的优先级，默认250</li>
<li><code>contentCompressionResistancePriority(for:)</code>，阻止缩小的优先级，默认750</li>
<li><code>invalidateIntrinsicContentSize</code>就像invalidate a view，会触发重新计算size</li>
</ul>
<p><code>&quot;H:[lab1(&gt;=100)]-(&gt;=20)-[lab2(&gt;=100)]&quot;</code> 这两个label，在屏幕变小时，谁最先缩到100？</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">lab2</span><span class="p">.</span><span class="n">contentCompressionResistancePriority</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">setContentCompressionResistancePriority</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
</pre></div>
<p>这里把lab1阻止缩小的优先级调得更高，那么就是lab2会先缩小</p><h3>Self-Sizing Views</h3>
<p>前面讲的都是superview对subview的影响，这一节反过来，subview的大小影响superview。</p><p>假定一个没有设置宽高的view，包含了一个button，我们知道button是有其intrinsic size的（固定的高，宽度由按钮文字决定），</p><ul>
<li>所以这个view也就有了宽高。</li>
<li>但这个宽高拥有低优先级，不会与显式设定的宽高相冲突。</li>
<li>运行时调用<code>systemLayoutSizeFitting(_:)</code>可以让系统优优先级地去按这个size去layout。这个操作是昂贵和低效的。</li>
</ul>
<h3>Stack Views</h3>
<p>UIStackView仍然是自动布局体系里的，它的作用是（为其<code>arrangedSubviews</code>）生成一系列约束，可以理解为语法糖。</p><ul>
<li><code>arrangedSubviews</code>是<strong>subViews</strong>的一个子集</li>
<li>stackView也可以添加额外的subView</li>
<li><em>setCustomSpacing(_:after:)</em>设置额外的space</li>
<li>不要再对arrangedSubviews手动添加约束，基本会与你看不见的计算出来的约束冲突<ul>
<li>但stackview本身是可以用autolayout来布局的</li>
</ul>
</li>
</ul>
<p>此时再来看看前面的竖向排列元素，并且间隔相等的例子的写法：</p><div class="highlight"><pre><span></span><span class="c1">// give the stack view arranged subviews</span>
<span class="kd">let</span> <span class="nv">sv</span> <span class="p">=</span> <span class="bp">UIStackView</span><span class="p">(</span><span class="n">arrangedSubviews</span><span class="p">:</span> <span class="n">views</span><span class="p">)</span>
<span class="c1">// configure the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">axis</span> <span class="p">=</span> <span class="p">.</span><span class="n">vertical</span>
<span class="n">sv</span><span class="p">.</span><span class="n">alignment</span> <span class="p">=</span> <span class="p">.</span><span class="n">fill</span>
<span class="n">sv</span><span class="p">.</span><span class="n">distribution</span> <span class="p">=</span> <span class="p">.</span><span class="n">equalSpacing</span>
<span class="c1">// constrain the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="p">=</span> <span class="kc">false</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">marg</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span>
<span class="kd">let</span> <span class="nv">safe</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">safe</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
<p>顺便注意以下里对layoutMargin和safearea的引用，都是通过layout guide的。</p><blockquote>
<p>debug会发现stack view其实帮你做了你之前做的事：<code>generating UILayoutGuide objects and using them as spacers</code></p></blockquote>
<p>stack view还有一个特性就是能自适应<code>arrangedSubviews</code>的变化。如果你把它理解为一个计算引擎，可能就好理解了。</p><h3>Internationalization</h3>
<p>使用.leading, .trailing等是为了适应不同语言的左右顺序，引入到布局里却会出现问题，并不是从右到左的语言的横向布局就也要相应反转。UIView.semanticContentAttribute可以人为控制，</p><ul>
<li>默认值是.unspecified，</li>
<li>.playback or .spatial将会不应用翻转。</li>
<li>.forceLeftToRight or .forceRightToLeft则是手动指定一个方向</li>
</ul>
<p>UIView<code>.effectiveUserInterfaceLayoutDirection</code>能report出这个trait</p><blockquote>
<p>You can test your app’s right-to-left behavior easily by changing the scheme’s Run option Application Language to “Right to Left Pseudolanguage.”</p></blockquote>
<h3>Debug autolayout</h3>

<pre><code>(lldb) e -l objc -- [[UIApplication sharedApplication] windows][0]
(UIWindow *) $1 = ...
(lldb) e -l objc -O -- [$1 _autolayoutTrace]
</code></pre>
<p>To get a full list of the constraints responsible for positioning a particular view within its superview, log the results of calling the UIView instance method <code>constraintsAffectingLayout(for:)</code>.</p><h2>Configuring Layout in Nib</h2>
<p>这一部分内容建议打开Xcode对着原文操作，多为界面操作</p><h3>Conditional Interface Design</h3>
<p>wC, HR等用来表示宽高在正常和压缩空间里的不同组合。</p><p>思路：先架构通用的视图和约束，然后用两种方法之一来描述不同size class下的特殊布局：</p><ul>
<li>in the Attributes or Size inspector</li>
<li>design that difference in the canvas:</li>
</ul>
<h2>Xcode View Features</h2>
<h3>Designable Views and Inspectable Properties</h3>
<p>有关Xcode的预览这一节可以看看，以及<code>@IBDesignable</code>方法能在xib里面呈现（教程里是在<code>willMove(toSuperview)</code>方法里调用）</p><h2>Layout Events</h2>
<p><strong>updateConstraints</strong></p><ul>
<li>（向上冒泡）<code>propagated up</code> the hierarchy, starting at the deepest subview</li>
<li>called at launch time，然后几乎不会调用，除非手动</li>
<li>也从不直接调用，而是通过<ul>
<li><code>updateConstraintsIfNeeded</code>方法</li>
<li>或是<code>setNeedsUpdateConstraints</code></li>
</ul>
</li>
</ul>
<p><strong>traitCollectionDidChange(_:)</strong></p><ul>
<li>(向下传播)<code>propagated down</code> the hierarchy of UITraitEnvironments.</li>
</ul>
<p><strong>layoutSubviews</strong></p><ul>
<li>The layoutSubviews message is the moment when <code>layout actually takes place</code>.</li>
<li>（向下传播） <code>propagated down</code> the hierarchy, starting at the top (typically the root view) and working down to the deepest subview.</li>
<li>If you’re not using autolayout, layoutSubviews does <strong>nothing</strong> by default</li>
<li>layoutSubviews is your opportunity to perform manual layout <strong>after</strong> autoresizing has taken place.</li>
<li>If you are using autolayout, you <strong>must</strong> call super or the app will crash (with a helpful error message).</li>
<li>从不直接调用：<ul>
<li><code>layoutIfNeeded</code></li>
<li><code>setNeedsLayout</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>When you’re using autolayout, <code>what happens in layoutSubviews</code>?</p><ol>
<li>The runtime, having examined and resolved all the constraints affecting this view’s subviews,</li>
<li>and having worked out values for their center and bounds,</li>
<li>now simply assigns <code>center</code> and <code>bounds</code> values to them.</li>
</ol>
<p>In other words, layoutSubviews performs <strong>manual layout</strong>!</p></blockquote>
<p>所以如果你需要在auto layout之后微调，<code>layoutSubviews</code>是法定的入口：</p><ol>
<li>call <code>super</code>, causing all the subviews to adopt their new frames</li>
<li>examine those frames, 如果不满意，则对<code>frame</code>进行微调（或者<code>bounds</code>和<code>center</code>）</li>
</ol>
<p>这也是autolayout engine自己的步骤，要注意的是你必须要和autolayout engine来协作，并且<strong>不要</strong>调用<code>setNeedsUpdateConstraints</code>(时机已过)</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/View/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_self">翻转二叉树</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_self">
                <time class="text-uppercase">
                    December 08 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>最近在找工作，所以这些算法梗又出现在了我的阅读视野里，比如经典的homebrew作者吐槽的翻转二叉树的问题。
<figure  style="flex: 86.71052631578948" ><img width="659" height="380" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4b282d39e440d597c619d781ee3b690e.png" alt=""/></figure></p><p>我本以为是根和叶节点倒转过来，原来是同层里面的左右翻转。</p><p>那么就是把左边换到右边，右边换到左边呗，可以考虑递归。我一直用一个原则理解递归，就是把命令传达下去（比如上面的左右互换，就完了），而不关心细节，只有最末端的那个大头兵才是真正做业务的人，写了一下，递归加业务也就4行代码：</p><figure  style="flex: 80.10335917312662" ><img width="1240" height="774" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8defc3430ca00b8a8501fb6d8356c6fb.png" alt=""/></figure><p>具体到这个问题，就是我把left和right互换就是了
然后left和right你们做好自己的子级的互换，我不管，所以核心代码就一句
<code>left, right = right, left</code>，前面是为了稳妥，通过了之后，直接用python这种左右互换的特性，那就真是一句代码了：</p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">理解Core-Graphics的Clipping和填充模式</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">
                <time class="text-uppercase">
                    November 28 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>先来看一个例子
<figure class="vertical-figure" style="flex: 38.76146788990825" ><img width="338" height="436" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d5fdc49bd6037d399e4685d3cf9d72bf.png" alt=""/></figure>
画一个箭头，其中箭尾有分叉，一般来说，是画一个三角，画一个矩形（实心矩形一般也直接用很粗的线条），最后再叠一个三角（with <code>CGBlendModel.clear</code>)，这里就不多介绍了：</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>       
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">()</span>
    <span class="c1">// shaft</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">lineWidth</span> <span class="p">=</span> <span class="mi">20</span>
    <span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>

    <span class="c1">// point</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>

    <span class="c1">// snip</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">with</span><span class="p">:</span><span class="n">CGBlendMode</span><span class="p">.</span><span class="n">clear</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>我们来看看<code>clipping</code>怎么用</p><ol>
<li>fill三角箭头（出于堆叠上目的可以最后画）</li>
<li>找到箭尾的三个顶点<ul>
<li>用<code>boundingBoxOfClipPath</code>来创建整个画板大小的矩形</li>
<li>应用<code>clipping</code>把小三角挖掉</li>
</ul>
</li>
</ol>
<p>3，画一根黄色箭柄粗细的线（从底向上）
    * 因为小三角区域被clipping掉了，结果就成了图示的模样</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// obtain the current graphics context</span>
        <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>

        <span class="c1">// punch triangular hole in context clipping region</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">90</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">90</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">closePath</span><span class="p">()</span>
        <span class="c1">// 添加整个区域为rect</span>
        <span class="c1">// 然后再clip设定为不渲染的区域</span>
        <span class="c1">// 后续的渲染全会避开这个区域</span>
        <span class="c1">// 我们后面把这个rect设为蓝色试试(顺便改为一个小一点的rect)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">con</span><span class="p">.</span><span class="n">boundingBoxOfClipPath</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">using</span><span class="p">:.</span><span class="n">evenOdd</span><span class="p">)</span>
<span class="c1">//        con.fillPath()</span>

        <span class="c1">// draw the vertical line</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setStrokeColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">19</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">strokePath</span><span class="p">()</span>

        <span class="c1">// draw the red triangle, the point of the arrow</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">120</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
    <span class="p">}</span>
</pre></div>
<p>能够完美run起来，但是我对clipping的机制还是有点不理解，一些关键点的讲解，和我的问题，一条条过：</p><ol>
<li>我们用构建了箭尾的三角形，然后<code>closePath</code>，那是因为我们只画了两条线，如果事实上第三条线连回了原点，那么这个<code>closePath</code>就不需要了</li>
</ol>
<ul>
<li>（图一）演示了不close的话就直接只有两条线了</li>
</ul>
<ol start="2">
<li>我想看看clipping到底发生了啥，于是注释掉了clip的那一行，得到了（图二）</li>
</ol>
<ul>
<li>之所以长那样是因为随后设置了stroke的参数（20像素的黄色）</li>
<li>stroke时，画板上有三个元素：一个三角，一个矩形，一条线段，全部用20宽的黄线描边了，一切如预期</li>
</ul>
<ol start="3">
<li>于是我尝试添加rect时只取了中间一小块，并涂成蓝色，不clip试试，得到（图三）。</li>
<li>知道了新rect的位置，把clip加回来，发现箭尾有了，箭头却没了（图四）</li>
<li>rect与clip的关系已经出来了，尝试把红三角的y通通加50，移到了蓝矩形范围内，得到证明（图五）</li>
</ol>
<figure  style="flex: 58.108108108108105" ><img width="774" height="666" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/83a72f77f3c1af59c2e83c0616699ca5.png" alt=""/></figure><p>那么clipping到底能对哪些起作用呢？是上面的rect吗？<strong>当然不是</strong>！</p><p>在clip方法被调用的时候，画布里有多少封闭元素，就会被应用clip。由于我们选择的是<code>evenOdd</code>模式，那么就会简单计数，某像素覆盖奇数次显示，偶数次则不显示。</p><p>上例中，<code>con.clip(using:)</code>方法调用时，画布里有两个封闭元素，一个三角，一个矩形，三角包在矩形里，那么计数为2，就不予显示了。</p><blockquote>
<p>事实上，判定奇偶的依据是该点向外做无限长的射线，判定有几条边与射线相交。同时，同样的设定可以用来解释<code>.winding</code>模式，即不但与相交的边有交，还与相交时，那条边是顺时针方向绘制的（+1）还是逆时针方向绘制的（-1）,总结果为0则不填充。<a href="https://www.jianshu.com/p/5cf8048b083b">参考</a></p></blockquote>
<p>那就玩一玩验证下吧</p><ol>
<li>把矩形改成了圆圈，线宽也改小一点，得到（图一）<em>绿色三角形是我后加的，因为被黄实线盖住了</em></li>
<li>再在里面添加了一个小圆，得到（图二）</li>
<li>这时候按照奇偶原则，小圆里的像素是偶数，而小圆里的三角则是奇数了，那么应该就只有大圆减掉小圆的部分，和小圆内的三角会被渲染了（图三），与预期一致</li>
</ol>
<figure  style="flex: 137.00564971751413" ><img width="970" height="354" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/84aa194f6e13d2f92fe6e9929e5c7110.png" alt=""/></figure><p>现在再来回顾书上先套一个画布大小的矩形，再画一个三角形，你大概应该知道目的了（凑奇偶），我们矩形区域过小时绘制不了红色三角，纯粹也是因为奇数，往下移到矩形区域内，立马变偶数了。(当然，要在原位置渲染我们可以先中止clip:<code>con.resetClip()</code>再绘图）</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Thread-in-iOS/" target="_self">Thread-in-iOS</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Thread-in-iOS/" target="_self">
                <time class="text-uppercase">
                    November 26 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第25章</p><hr />
<h1>Thread</h1>
<p>Thread在开发过程中基本上线程是隐形的，你感知不到，因为大多数情况下，程序只（需要）跑在主线程上，这是没有问题的：</p><ul>
<li>你的代码事实上执行得非常快，你感知不到</li>
<li>响应逻辑过程锁死UI，是安全的操作</li>
</ul>
<p>原生的后台线程：</p><ul>
<li>动画：The Core Animation framework is running the animation and updating the presentation layer on a background thread.</li>
<li>网络：A web view’s fetching and loading of its content is asynchronous</li>
<li>影音：Sounds are played asynchronously. Loading, preparation, and playing of movies happens asynchronously.</li>
<li>存盘：UIDocument saves and reads on a background thread.</li>
</ul>
<p>但所有的<code>complete functions / delegations / notification</code> 都是在主线程被调用的</p><p>多线程的问题</p><ul>
<li>调用时机/顺序不可控，次数也不可控，随时可能被执行</li>
<li>数据的线程安全，不得不借助“锁”的机制来保证（race condition）<ul>
<li>a lock is an <code>invitation</code> to <em>forget</em> to use the lock, or to <em>forget</em> to remove the lock after you’ve set it.</li>
</ul>
</li>
<li>The lifetime of a thread is independent of the lifetimes of other objects in your app.<ul>
<li>一个对象的退出不能保证有后台线程将来会调用它 -&gt; 闪退或Zombie</li>
</ul>
</li>
<li>Hard to debug.</li>
</ul>
<p>XCode对debug的支持：</p><ul>
<li>Debug navigator</li>
<li><code>NSLog / os_log / Logger</code> outputs</li>
<li>Instruments &gt; Time Profiler</li>
<li>Thread Sanitizer, Main Thread Checker (项目配置 &gt; Diagnostics)</li>
</ul>
<p>执行后台线程的方法：</p><h2>Manual Threading</h2>
<p><code>performSelector(inBackground:with:)</code></p><ul>
<li>只能传一个参数，多个参数要打包</li>
<li>手动管理内存 -&gt; wrap every thing in an autorelease pool</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
        <span class="c1">// 这里打包参数为一个字典</span>
        <span class="kd">let</span> <span class="nv">d</span> <span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">]</span> <span class="p">=</span>
            <span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">:</span><span class="n">center</span><span class="p">,</span> <span class="s">&quot;bounds&quot;</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="s">&quot;zoom&quot;</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">inBackground</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">reallyDraw</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">}</span>
<span class="c1">// trampoline, background thread entry point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">reallyDraw</span><span class="p">(</span><span class="kc">_</span> <span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// 手动控制内存</span>
    <span class="n">autoreleasepool</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGPoint</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;bounds&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGRect</span><span class="p">,</span>
            <span class="n">zoom</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;zoom&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGFloat</span><span class="p">)</span>
        <span class="c1">// 手动回调主线程</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">onMainThread</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">allDone</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
            <span class="n">waitUntilDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>

<span class="p">}</span>
<span class="c1">// called on main thread! background thread exit point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">allDone</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>即便如此，还是没有解决不同线程使用同一个实例变量（如<code>bitmapContext</code>）造成程序非常脆弱的问题，得进一步使用<code>lock</code>等机制。</p><h2>Operation</h2>
<ul>
<li>将<code>thread</code>封装成<code>task</code>，表示成<code>Operation</code> 通过 <code>OperationQueue</code>来操作。</li>
<li>回调机制变成了通知机制（或<code>KVO</code>）</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">queue</span> <span class="p">:</span> <span class="n">OperationQueue</span> <span class="p">=</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
    <span class="c1">// ... further configurations can go here ...</span>
    <span class="k">return</span> <span class="n">q</span>
<span class="p">}()</span>

<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="c1">// 也可以用 BlcokOperation</span>
    <span class="c1">// 来执行你的耗时操作</span>
    <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">MyMandelbrotOperation</span><span class="p">(</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 通知/回调</span>
    <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
        <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">operationFinished</span><span class="p">),</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
    <span class="c1">// 结合起来</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>而一个<code>Operation</code>子类包含两个部分：</p><ol>
<li>A designated initializer<ul>
<li>你可以把需要的参数设计成对应的属性，并初始化好它</li>
</ul>
</li>
<li>A main method<ul>
<li>耗程序真正执行的地方，OperationQueue执行到这个Operation的时候就会被自动执行</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">MyMandelbrotOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">mandelOpFinished</span> <span class="p">=</span> <span class="n">Notification</span><span class="p">.</span><span class="n">Name</span><span class="p">(</span><span class="s">&quot;mandelOpFinished&quot;</span><span class="p">)</span>

    <span class="c1">// 1. params -&gt; arguments</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">center</span> <span class="p">:</span> <span class="n">CGPoint</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">:</span> <span class="n">CGRect</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">zoom</span> <span class="p">:</span> <span class="n">CGFloat</span>
    <span class="kd">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">bitmapContext</span> <span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span> <span class="p">=</span> <span class="kc">nil</span>  <span class="c1">// 封装成了类属性，不再线程共享</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">center</span> <span class="n">c</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span> <span class="n">b</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span> <span class="n">z</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">c</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span> <span class="p">=</span> <span class="n">z</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// 1.1 logic</span>
    <span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
    <span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>

    <span class="c1">// 2. main</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 首先要检查isCancelled</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span><span class="p">}</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="p">{</span>
            <span class="c1">// 完成通知，也可以用KVO机制</span>
            <span class="c1">// 主线程接收到后要立即处理，因为OpearationQueue将会立即释放这个Operation</span>
            <span class="c1">// 此外，接收通知可能也不在主线程，-&gt; GCD</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 3. observer</span>
<span class="c1">// 就是前面在主线程里注册监听消息的方法</span>
<span class="c1">// warning! called on background thread</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">operationFinished</span><span class="p">(</span><span class="kc">_</span> <span class="n">n</span><span class="p">:</span><span class="n">Notification</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">MyMandelbrotOperation</span> <span class="p">{</span>
        <span class="c1">// 1. 主线程（GCD）</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="c1">// 2. 移除通知监听</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">op</span><span class="p">.</span><span class="n">bitmapContext</span>  <span class="c1">// 传回这个之前是线程共享的变量</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>注意<code>bitmapContext</code>这个之前主线程设置，然后后台线程共享的变量，现在由Operation这个类自己持有，结束时才赋值回主线程。</p><p>此外，还能限制并发数量：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
<span class="n">q</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="p">=</span> <span class="mi">1</span>
</pre></div>
<p>This turns the OperationQueue into a <code>serial queue</code>.</p><p>最后，解决最后一个问题，即你的调用者都没了，比如ViewController没了，调用者没了，后台任务也理应取消（下载、存盘类不需要UI交互的除外）</p><div class="highlight"><pre><span></span><span class="kd">deinit</span><span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">cancelAllOperations</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>至此，前面提到的一些多线程会带来的问题如调用时机和数量不可控，跨线程数据安全，以及生命周期等问题，<code>Operation</code>都完美解决并封装了。</p><p>设置优先级，QoS, 依赖等一些进阶示例：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">backgroundOperation</span> <span class="p">=</span> <span class="bp">NSOperation</span><span class="p">()</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">queuePriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">Low</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">qualityOfService</span> <span class="p">=</span> <span class="p">.</span><span class="n">Background</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">backgroundOperation</span><span class="p">)</span>

<span class="c1">// dependence</span>
<span class="kd">let</span> <span class="nv">networkingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="kd">let</span> <span class="nv">resizingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="n">resizingOperation</span><span class="p">.</span><span class="n">addDependency</span><span class="p">(</span><span class="n">networkingOperation</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="c1">// 虽然resizing添加了network为依赖，但是还是需要全部加到队列里</span>
<span class="c1">// 不要以为加了尾部operation就能把依赖全加进去</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperations</span><span class="p">([</span><span class="n">networkingOperation</span><span class="p">,</span> <span class="n">resizingOperation</span><span class="p">],</span> <span class="n">waitUntilFinished</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
</pre></div>
<h2>Grand Central Dispatch</h2>
<p>可以认为GCD是更底层的Operation，它甚至直接嵌入了操作系统，能被任何代码执行而且非常高效。调用过程也与Operation差不多:</p><ul>
<li>表示一个task</li>
<li>加入一个queue<ul>
<li>GCD Queue也被表示成了<em>dispatch queue</em></li>
<li>a lightweight opaque pseudo-object consisting essentially of <code>a list of functions</code> to be executed.</li>
<li>如果自定义这个queue，它默认状态下是<code>serial queue</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
<span class="kd">var</span> <span class="nv">bitmapContext</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">draw_queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;com.neuburg.mandeldraw&quot;</span><span class="p">)</span>

<span class="c1">// 改造一个返回前述跨线程变量的方法</span>
<span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">CGContext</span> <span class="p">{</span>
    <span class="c1">// ... as before ...</span>
    <span class="kd">let</span> <span class="nv">context</span> <span class="p">=</span> <span class="n">CGContext</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">),</span> <span class="n">height</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
        <span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bytesPerRow</span><span class="p">:</span> <span class="n">bitmapBytesPerRow</span><span class="p">,</span>
        <span class="n">space</span><span class="p">:</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">prem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">!</span>
<span class="p">}</span>
<span class="c1">// 相应方法增加这个context参数，而不是从环境里取</span>
<span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span><span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... as before, but we refer to local context, not self.bitmapContext</span>
<span class="p">}</span>

<span class="c1">// 剩下的，一个block搞定：</span>
<span class="c1">// UI触发的事件</span>
<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// 下面两行代码虽然用到了self，但是它们没有改变任何属性，是线程安全的</span>
        <span class="kd">let</span> <span class="nv">bitmap</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">bitmap</span><span class="p">)</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">bitmap</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>可以看到，相比Operation把代码结构都改了，GCD几乎只是包了一层block，代码变动非常少。（唯一的发动就是把所有执行代码的变量都需要通过参数机制传进去）。</p><p>同时， <em>center, bounds</em>等参数，直接从环境里取，这是block机制带来的便利；同样的机制也被用在了线程共享的变量传回主线程时，因为对第二层block而言，第一层block就是它的<code>higher surrounding scope</code>，是能看到它的<em>bitmap</em>变量的。 -&gt; 我们并没有从头到尾retrive一个<code>self.bitmap</code>变量，也就不存在data sharing。</p><p>不像Operation把耗时操作写在别处，GCD的方式易读性更高。</p><p>除了有<code>.async(execute:)</code>，还有<code>asyncAfter(deadline:execute:)</code>和<code>sync(execute:)</code>，望文生义，就不多介绍了。</p><h3>Dispatch Groups</h3>
<p>group提供了监听(wait)一组后台线程全部执行结束的功能：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">outerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;outer&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">innerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;inner&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">group</span> <span class="p">=</span> <span class="n">DispatchGroup</span><span class="p">()</span>
<span class="n">outerQueue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">series</span> <span class="p">=</span> <span class="s">&quot;123456789&quot;</span>
    <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">series</span> <span class="p">{</span>
        <span class="n">group</span><span class="p">.</span><span class="n">enter</span><span class="p">()</span>  <span class="c1">// flag 1</span>
        <span class="n">innerQueue</span><span class="p">.</span><span class="n">asyncAfter</span><span class="p">(</span>
            <span class="n">deadline</span><span class="p">:.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">milliseconds</span><span class="p">(</span><span class="nb">Int</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="k">in</span><span class="p">:</span> <span class="mf">1.</span><span class="p">..</span><span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">terminator</span><span class="p">:</span><span class="s">&quot;&quot;</span><span class="p">)</span>
                <span class="n">group</span><span class="p">.</span><span class="n">leave</span><span class="p">()</span> <span class="c1">// flag 2</span>
        <span class="p">}</span> 
        <span class="n">group</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>  <span class="c1">// 一旦加了这句话，这9个线程就变成线性的了，注释掉，就是9个线程随机先后执行</span>
    <span class="p">}</span>
    <span class="c1">// 可见这个notify等同于wait_all</span>
    <span class="c1">// 当enter次数与leave次数一致时触发</span>
    <span class="n">group</span><span class="p">.</span><span class="n">notify</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">done&quot;</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<h3>One-Time Execution</h3>
<p>Objective-C中实现单例的<code>dispatch_once</code>其实就是GCD的内容，而在Swift中这个方法就没有了，也没用GCD去实现了:</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">globalOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in a lifetime&quot;</span><span class="p">)</span> <span class="c1">// once, at most</span>
<span class="p">}()</span>
</pre></div>
<p>这个print只会打印一次。而如果是用在对象中，可以声明为<code>lazy</code>：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
        <span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">instanceOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in an instance&quot;</span><span class="p">)</span> <span class="c1">// once per instance, at most</span>
        <span class="p">}()</span>
<span class="c1">// ... }</span>
</pre></div>
<p><code>instanceOnce</code>这个变量也只会初始化一次。</p><p><strong>Bonus</strong></p><div class="highlight"><pre><span></span><span class="c1">// 并发</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;queue&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">:</span> <span class="p">.</span><span class="n">concurrent</span><span class="p">)</span>
<span class="c1">// 条件， check the queue</span>
<span class="n">dispatchPrecondition</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="p">.</span><span class="n">onQueue</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">))</span>
</pre></div>
<h2>App Backgrounding</h2>
<ul>
<li>应用进入后台时，iOS系统会给应用<code>小于5秒</code>的时间来结束当前的任务</li>
<li>可以用<code>UIApplication.shared.beginBackgroundTask(expirationHandler:)</code>来申请更长的时间（<code>不超过30秒</code>），返回一个identifier<ul>
<li><code>expirationHandler</code>是一个超时还没处理完的话，系统会调的方法，</li>
</ul>
</li>
<li>任务执行完后需要调用<code>UIApplication.shared.endBackgroundTask(_:)</code>方法来结束后台时间的申请<ul>
<li><code>expirationHandler</code>里同样需要显式<code>endBackgroundTask</code></li>
<li>所以正常方法体和超时方法体都会有endBackgroundTask的调用</li>
</ul>
</li>
</ul>
<p>把这个特性直接封装到一个operation里去：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">BackgroundTaskOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">whatToDo</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kd">var</span> <span class="nv">cleanup</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="kd">var</span> <span class="nv">bti</span> <span class="p">:</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="p">=</span> <span class="p">.</span><span class="n">invalid</span>
        <span class="n">bti</span> <span class="p">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">beginBackgroundTask</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cleanup</span><span class="p">?()</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// cancellation</span>
        <span class="p">}</span>
        <span class="k">guard</span> <span class="n">bti</span> <span class="o">!=</span> <span class="p">.</span><span class="n">invalid</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">whatToDo</span><span class="p">?()</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// completion</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 调用</span>
<span class="kd">let</span> <span class="nv">task</span> <span class="p">=</span> <span class="n">BackgroundTaskOperation</span><span class="p">()</span>
<span class="n">task</span><span class="p">.</span><span class="n">whatToDo</span> <span class="p">=</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">myQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
<p>这样，</p><ul>
<li>正常情况下会执行<code>whatToDo()</code></li>
<li>如果应用被挂到后台，因为注册过后台任务，有小于30秒的时间跑完任务</li>
<li>如果顺利跑完，你把应用切到前台，会发现UI已经更新了</li>
<li>超时也没跑完，就会进入超时的block里去取消任务了，UI上也得不到结果</li>
</ul>
<blockquote>
<p>最后，要知道所谓的申请时长，并不是在<em>didEnterBackground</em>之类的方法里去做的，而是做任务的时候就直接注册了，是不是很麻烦？</p></blockquote>
<h2>Background Processing</h2>
<p>相比向系统申请少得可怜的后台挂起时间，iOS 从13开始引入了后台任务机制，方便你执行一些用户不需要感知的任务，比如下载，或数据清理：</p><ul>
<li>路径：target &gt; Signing &amp; Capabilities &gt; Background processing</li>
<li>use <code>Background Task framework</code>, need to import <code>BackgroundTasks</code></li>
<li><em>Info.plist</em> &gt; add &quot;Permitted background task schedule identifiers&quot; key (<code>BTTaskSchedulerPermittedIdentifiers</code>), 任意标识字符串，比如反域名</li>
<li>在<code>appDelegate</code>里面去实现需要后台执行的方法</li>
</ul>
<p>涉及到两个类:</p><ul>
<li><code>BGProcessingTaskRequest</code><ul>
<li>在<code>didEnterBackground</code>方法里调用</li>
<li>需要match <em>plist.info</em>里的id</li>
<li>注册是否通电/有网/延迟执行（ExternalPower / Network / earliestBeginDate）</li>
</ul>
</li>
<li><code>BGTaskScheduler</code><ul>
<li><code>application(_:didFinishLaunchingWithOptions:)</code>里执行</li>
<li><code>register(forTaskWithIdentifier:using:launchHandler:)</code>方法<ul>
<li>id: matching plist.info</li>
<li>using: dispatch queue</li>
<li>handler: <code>BGTask</code> object</li>
</ul>
</li>
<li>在<code>BGTask</code>的超时方法里，和正常执行的代码里，均需调用<code>setTaskCompleted(_:bool)</code>方法</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">taskid</span> <span class="p">=</span> <span class="s">&quot;com.neuburg.matt.lengthy&quot;</span>
<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">,</span>
    <span class="n">didFinishLaunchingWithOptions</span> <span class="n">launchOptions</span><span class="p">:</span>
    <span class="p">[</span><span class="bp">UIApplication</span><span class="p">.</span><span class="n">LaunchOptionsKey</span> <span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
<span class="p">}</span>
<span class="c1">// let v = MyView()</span>
<span class="kd">let</span> <span class="nv">ok</span> <span class="p">=</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">forTaskWithIdentifier</span><span class="p">:</span> <span class="n">taskid</span><span class="p">,</span>
    <span class="n">using</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:</span> <span class="p">.</span><span class="n">background</span><span class="p">))</span> <span class="p">{</span> <span class="n">task</span> <span class="k">in</span>
        <span class="n">task</span><span class="p">.</span><span class="n">expirationHandler</span> <span class="p">=</span> <span class="p">{</span>
            <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//... my task logic</span>
        <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// might check `ok` here</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">applicationDidEnterBackground</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// might check to see whether it&#39;s time to submit this request</span>
    <span class="kd">let</span> <span class="nv">req</span> <span class="p">=</span> <span class="bp">BGProcessingTaskRequest</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">taskid</span><span class="p">)</span>
    <span class="k">try</span><span class="p">?</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3>Debug</h3>
<ol>
<li>打满<em>print</em>和断点</li>
<li>设备上，把应用送到后台再拉到前台</li>
<li>Xcode上暂停app</li>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟launching<ul>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟超时</li>
</ul>
</li>
<li>控制台输入<code>continue</code>, 运行task function</li>
<li>当<code>task.setTaskComplete(success: true)</code> 被调用，控制台输出：“Marking simulated task complete,”</li>
</ol>
<h3>BGAppRefreshTaskRequest</h3>
<p>not mentioned</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Thread-in-iOS/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">数据结构篇九：Indexed Priority Queue</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Indexed Priority Queue</h1>
<ul>
<li>a traditional priority queue variant</li>
<li>top node supports <code>quick update and deletions of key-value paris</code></li>
</ul>
<figure  style="flex: 77.8894472361809" ><img width="1240" height="796" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5e238bf5e89b7b2188cfb748c4e5990e.png" alt=""/></figure><p>观察这个图，数据是Anna, Bella...等等，</p><ul>
<li>首先，为这一堆数据进行任意排序，得到一堆索引(0,1,...)</li>
<li>然后组一个binary heap，这样每个元素又获得一个索引，就是在heap上的序号（<code>Position Map</code>）</li>
</ul>
<p>通过两组索引迅速找到key（就是人名）在堆中的位置，比如：</p><ul>
<li>George，ki = 6, pm = 1</li>
<li>kelly, ki = 10, pm = 10</li>
<li>...</li>
</ul>
<p>现在能迅速找到数据源在堆上的位置了，那么如果反过来呢？比如堆上索引3是数据源的谁？</p><ul>
<li>pm = 3 -&gt; ki = 8 -&gt; Issac <strong>BINGO!!!</strong></li>
</ul>
<p>但神奇的事发生了，有人希望复用ki这个自然数序列（闲的蛋疼？），于是多做了一个数组，把ki定义为heap上的索引，与元素原来的ki进行映射（<code>Inverse Map</code>）:IM
<figure  style="flex: 68.88888888888889" ><img width="1240" height="900" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/71be1add8c1a0cde72e08fc72adbd071.png" alt=""/></figure></p><p>可以看到，这张图上张个ki到im的映射，与pm到ki的映射其实是一样的，也就是说重定义了一下，并没有引入新的东西。(pm表里找到3，对应的第一行ki表里就是8）</p><p>这个时候，我们直接用ki的3就能找到im的8，继而找到数据源的<em>Issac</em>了。</p><h2>Insertion</h2>
<p>上面的数组，我们往里面添加第12条数据试试:</p><ul>
<li>{ki:12, pm: 12, im:12, value:2}</li>
<li>显然违反了binary heap的 invariant，向上冒泡，也就是跟{ki:12, pm:5, im:2, value:4}的节点互换</li>
<li>此时，数据源肯定不会变，但是节点变了，pm的值就要交换（5， 12 互换）</li>
<li>pm变了，把pm当成ki的映射表im也要变（12， 11互换）</li>
</ul>
<figure  style="flex: 224.63768115942028" ><img width="1240" height="276" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/47da2e700214e5e2de16aa42f5b92fb3.png" alt=""/></figure><p>仔细观察图片，搞清楚第一行ki在两次互换时的身份就明白了</p><ul>
<li>pm的互换是直观的，就是节点的位置</li>
<li>知道pm互换的依据后（2，5），在第一行找2，5对应的im值互换，因为在这个映射里，相当于pm与原ki的映射，pm此时是（2，5）了。</li>
</ul>
<p>同样逻辑继续冒泡就是了。</p><p>pseudo code:</p><div class="highlight"><pre><span></span><span class="c1"># Inserts a value into the min indexed binary </span>
<span class="c1"># heap. The key index must not already be in </span>
<span class="c1"># the heap and the value must not be null. </span>
<span class="n">function</span> <span class="n">insert</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># ‘sz’ is the current size of the heap</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz</span>  <span class="c1"># 对应上图，意思就第一行索引器是ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="n">ki</span>  <span class="c1"># 对应上图，意思就是一行索引器是pm</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span>     <span class="c1"># 这里传进去的pm，即heap上节点的索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 添加成功，size加1</span>
</pre></div>
<p>理论上，添加元素到最后一个, sz和ki应该是相等的（因为都是尾巴上）</p><div class="highlight"><pre><span></span><span class="c1"># Swims up node i (zero based) until heap </span>
<span class="c1"># invariant is satisfied.</span>
<span class="n">function</span> <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 比父节点小就冒泡，注意入参i是节点上的索引，即pm</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)):</span> 
        <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># 所以这里传的也是pm</span>
        <span class="n">i</span><span class="o">=</span><span class="n">p</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">function</span> <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> 
    <span class="c1"># 我们交换了节点，需要交换pm表里的值，和im表里的值</span>
    <span class="c1"># 交换pm的值需要数据源的索引，即ki，而ki能从im表里用pm算出来</span>
    <span class="c1"># 所以ki = im[pm] 这里i,j是pm，所以im[i]自然就是i对应ki</span>
    <span class="c1"># pm[ki]当然就是pm[im[i]]了：</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
    <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">function</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
<p>还是那句话，理解清楚那三行映射表里第一行的动态含义，就不会有问题。</p><ul>
<li>pm表要key index来索引</li>
<li>im表要node index来索引</li>
</ul>
<p>在操作时，只需要知道传入的是哪种索引，及时转化就行了。</p><p>有了索引，lookup的时间复杂度就是常量时间了：O(1)</p><h2>Polling and Removals</h2>
<p>没有什么特殊的,仍然是找到节点,与最后一个交换,移除最后一个节点,然后再看最后一个在堆里是上升还是下降.
仍然是记得每一步交换,相应的几个索引值也需要随之交换.(polling 其实就是移除第1个节点,本质上还是 removal)
<figure class="vertical-figure" style="flex: 36.70811130846655" ><img width="1240" height="1689" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/581b8563020c36307eae7a9bf618a7e0.png" alt=""/></figure></p><p>pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Deletes the node with the key index ki</span>
<span class="c1"># in the heap. The key index ki must exist </span>
<span class="c1"># and be present in the heap.</span>
<span class="n">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">ki</span><span class="p">):</span>
    <span class="c1"># 注意，这里送进来的是ki，而不是node index(pm)</span>
    <span class="c1"># 说明业务需求一般是操作数据源，而不是操作堆</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>    <span class="c1"># 转成节点索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># 与最后一个元素交换，用size来做节点索引</span>

    <span class="c1"># 下面三个子函数送入的就是节点索引了</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> 
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span>  <span class="c1"># 数据源对应的值置空，所以用ki</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 数据源对应的节点置空，所以用ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 反查表用节点索引，此处size就是最后一个节点的索引</span>
</pre></div>
<p>sink pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Sinks the node at index i by swapping </span>
<span class="c1"># itself with the smallest of the left </span>
<span class="c1"># or the right child node.</span>
<span class="n">function</span> <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 这是堆操作,传入的索引也是节点索引,没问题</span>
    <span class="c1"># sink是下沉，但不是跟BTS一样找左侧最大右则最小那种直接换</span>
    <span class="c1"># 而是一层层往下换</span>
    <span class="c1"># 即一次while只跟左右子级比大小，确实比子级还小的话，就替换，然后再跟下一层比较</span>
    <span class="k">while</span> <span class="n">true</span><span class="p">:</span>
        <span class="c1"># 利用二叉树特性算出子节点</span>
        <span class="c1"># 默认左边最小，然后再看右边是不是更小</span>
        <span class="n">left</span> <span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">left</span>
    <span class="c1"># 右边不越界，且小于左边，就设右边</span>
    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sz</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">right</span>
    <span class="c1"># 左侧都越界了，或已经比最小值大了，说明不需要下沉了</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">sz</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">smallest</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="c1"># 只要没有break，说明能交换，然后把交换后的作为下一个循环的起点</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">smallest</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">smallest</span>
</pre></div>
<h2>Updates</h2>
<p>更新节点要简单的多:</p><ul>
<li>用ki找到value，把值更新</li>
<li>然后根据新value实际情况上浮或下沉</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># Updates the value of a key in the binary </span>
<span class="c1"># heap. The key index must exist and the</span>
<span class="c1"># value must not be null.</span>
<span class="n">function</span> <span class="n">update</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<h2>Decrease and Increase key</h2>
<p>不好说，先看代码吧：</p><div class="highlight"><pre><span></span><span class="c1"># For both these functions assume ki and value </span>
<span class="c1"># are valid inputs and we are dealing with a</span>
<span class="c1"># min indexed binary heap.</span>
<span class="n">function</span> <span class="n">decreaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]):</span> 
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">swim</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>

<span class="n">function</span> <span class="n">increaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">],</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">sink</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
</pre></div>
<p>代码里是跟一个固定值比较，只要ki对应的值比它大(desreaseKey)或小(increaseKey），就用这个固定值来替换它，并且在value改变后根据实际情况上浮或下沉。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/" target="_self">数据结构篇八：Balanced Binary Search Trees(BBST)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Balanced Binary Search Trees (BBST)</h1>
<ul>
<li>满足low (logarithmic) height for fast insertions and deletions</li>
<li>clever usage of a <code>tree invairant</code> and <code>tree rotation</code></li>
</ul>
<h2>AVL Tree</h2>
<p>一种BBST，满足O(log n)的插入删除和查找复杂度，也是第一种BBST，后续出现的更多的：2-3 tree, AA tree, scapegoat tree, red-black tree(avl的最主要竞争对手)</p><p>能保持平衡的因子：Balance Factor (<code>BF</code>)</p><ul>
<li>BF(node) = H(node.right) - H(node.left)</li>
<li>H(x) = height of node = # of edges between (x, furthest leaf)</li>
<li>平衡就是左右平均分配，所以要么均分，要么某一边多一个，BF其实就是(-1, 0, 1)里的一个了 &lt;- avl tree invariant</li>
</ul>
<p>一个node需要存：</p><ul>
<li>本身的(comparable) value</li>
<li>balance factor</li>
<li>the <code>height</code> of this node</li>
<li>left/right pointer</li>
</ul>
<p>使树保持左右平衡主要是靠rotation，极简情况下（三个node），我们有两种基本情况（left-left, right-right），有其它情况就旋转一次变成这两种情况之一：
<figure  style="flex: 87.44710860366713" ><img width="1240" height="709" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/3b702bd1d181c924971298b096c7c548.png" alt=""/></figure></p><h2>Insertion</h2>
<p>一次插入需要考虑的是，插在哪边，以及插入后对bf, height和balance的破坏
<figure  style="flex: 60.546875" ><img width="1240" height="1024" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/7aec7390101d933c2d50971e2733effe.png" alt=""/></figure></p><p>其中修复平衡就是上图中几个基本结构的转换</p><h2>Removal</h2>
<p>avl树就是一棵BST，删除节点分两步：</p><ol>
<li>按照bst的方法查找节点，即小的在左边找，大的在右边找</li>
<li>也按bst的原则删除元素，即找到元素后，把左边的最大值或右边的最小值拿过来补上删除的位置</li>
<li>这一步是多出来的，显然是要更新一下节点的bf和height，及重新balance一次了。</li>
</ol>
<p>前两部分参考BST一章，流程伪代码：</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="o">...</span>
    <span class="c1"># Code for BST item removal here</span>
    <span class="o">...</span>
    <span class="c1"># Update balance factor</span>
    <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="c1"># Rebalance tree</span>
    <span class="k">return</span> <span class="n">balance</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AB%EF%BC%9ABalanced-Binary-Search-Trees%28BBST%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">数据结构篇七：Suffix Array, Longest Common Prefix (LCP) array</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Suffix Array</h1>
<ul>
<li>字符串的所有子字符串后缀组成数组</li>
<li>对子串根据首字母进行排序</li>
<li>排序后原有的index就被打乱了</li>
<li>这个乱序的indices就是<code>Suffix Array</code></li>
</ul>
<p>做尾缀子串的时候通常是从单个字母开始越找越多，这就有了一个原生顺序，然后用首字母排序后，这个顺序就被打乱了</p><p>提供了一种<code>compressd representation</code> of sorted suffixes而无需真的把这些子串存起来。</p><ul>
<li>A space efficient alternative to a <code>suffix tree</code><ul>
<li>a compressd version of a <code>trie</code>?</li>
</ul>
</li>
</ul>
<p>能做所有<code>suffix tree</code>能做的事，并加添加了<code>Longest Common Prefix</code>(LCP) array</p><h1>Longest Common Prefix (LCP) array</h1>
<p>继续上面的Suffix Array，字母排序后，我们一个个地用每一个元素同上一个元素比，标记相同前缀的字母个数，这个数字序列就是<code>LCP</code></p><p>比如adc, adfgadc, 前缀<code>ab</code>是相同的，那就是2。</p><p>第一个元素没有“上一个”去比，所以LCP数组第1位永远是0？（是的，其实是undefined，但一般设0）</p><p>衡量的是相邻的suffix array元素的前缀间有多少个字母相同。</p><p>当前也可以和下一个元素比（这样最后一个元素的LCP肯定是0了，原理同上）</p><h2>Find unique substrings</h2>
<p>找到（或计数）一个数组的所有（不重复的）子元素。可以逐个substring遍历，$O(n^2)$，下面看看更快也更省空间的LCP方案。</p><p>找“AZAZA”的不重复子串:
A,AZ,AZA,AZAZ,AZAZA,Z,ZA,ZAZ,ZAZA,<code>A,AZ,AZA,Z,AZ,A</code>，把重复的标注了出来。
LCP是这样的：
LCP|Sorted Suffixes|
-|-
0|A
1|AZA
3|AZAZA
0|ZA
2|ZAZA</p><p>我们知道第一列指的是“重复个数”，也就是说，如果按我们手写的那样去遍历，至少有这么多重复的子串，重复的既是“个数”，也是“组合方式”。</p><p>所以如果我们只需要计数的话，把右边的数出来就知道有会有多少个重复的了，此例为6.</p><p>$$\tt unique\ count = \underbrace{\frac{n(n+1)}{2}}_{substr\ count} - \underbrace{\sum_{i=1}^n LCP[i]}_{duplicates}$$</p>
<p>这是LCP的应用之一，利用了LCP本身就是在数重复次数的特征。</p><h2>K common substring problem</h2>
<p>n个字符串，找出一个子串，它至少是k个字符串的子串，求最大子串。$2\leq k \leq n$</p><p>即如果有k=2，那么这个子串只需要是其中两个的子串就行了，如果k=n，那么就需要是每一个字符串的子串。</p><p>直接上图
<figure  style="flex: 50.4885993485342" ><img width="1240" height="1228" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/b7cb01449aa00a46b95ca35f28751a33.png" alt=""/></figure></p><ul>
<li>图1演示k=3时，找到了<code>ca</code>，即3个串里都有的是<code>ca</code></li>
<li>图2演示k=2时，找到了<code>bca</code>，即<code>bca</code>存在2个串里</li>
<li>图3演示的是用了size=4的滑窗才包含了3个字符串，以及最大匹配是<code>AG</code></li>
</ul>
<p>步骤：</p><ol>
<li>首先，用几个分隔符把字符串拼接起来<ul>
<li>分隔符字符串里不会出现</li>
<li>分隔符的排序要小于所有字符</li>
</ul>
</li>
<li>图中染色的依据是prefix是哪个串里的就染成什么颜色</li>
<li>开始滑窗比较<ul>
<li>滑窗必须要能包含k种颜色</li>
<li>所以滑窗大小不是固定的，有时候相邻几个都是来自同一个字符串</li>
<li>滑窗里除0外的最小值，就是符合条件的最大共同长度，如图3，最大匹配长度是2</li>
<li>课程里动画演示滑窗其实不是用滑的，而是用的爬行<ul>
<li>即下界往下，包含了所有颜色之后，上界也往下，这样蠕行前进，每一步判断滑窗里的内容</li>
</ul>
</li>
</ul>
</li>
<li>额外需要一个hash table来保存切片与颜色的映射关系。<ul>
<li>如果是例子这么简单，我可以直接检查第一个出现的分隔符，是#就是绿色，出现$就是蓝色，%就是红色</li>
</ul>
</li>
</ol>
<p>核心就是：</p><ul>
<li>取子串是从后向前取的</li>
<li>但比较是从前向后比的</li>
<li>前面的元素可能来自任何一个子串（只要足够长）</li>
<li>从前面排序，客观上就把来自不同字符串的相同字母打头的子串给排到一起了</li>
</ul>
<p>这就是为什么在<code>Suffix</code> Array的内容里面出现Longest Common <code>Prefix</code>的内容的原因了.</p><p>聪明。</p><h2>Longest Repeated Substring (LRS)</h2>
<figure  style="flex: 72.68464243845251" ><img width="1240" height="853" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ef47276f994f76ccabc2c60900227916.png" alt=""/></figure><p>这个比暴力遍历要简单太多，直接找LCP最大值即可</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B8%83%EF%BC%9ASuffix-Array%2C-Longest-Common-Prefix-%28LCP%29-array/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">数据结构篇六：Fenwick Tree (Binary Indexed Tree)</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/" target="_self">
                <time class="text-uppercase">
                    November 12 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Fenwick Tree (Binary Indexed Tree)</h1>
<p>树状数组</p><p><strong>Motivation</strong></p><figure  style="flex: 118.0952380952381" ><img width="1240" height="525" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2591209692305dbd9d640a53765581e1.png" alt=""/></figure><ul>
<li>计算数组里任意连续片段的和，最直观的方案当然是累加：线性时间O(n)</li>
<li>但是如果你有一个记录了每个节点到当前位置时的累加和的数组（<code>prefix sum</code>），立刻变成了常量时间</li>
<li>问题是更新数据变成了线性时间（后续所有的求和都要改一遍）<ul>
<li>great for <code>static arrays</code></li>
</ul>
</li>
</ul>
<p>所以引入了:
<code>Fenwick Tree</code> is an efficient data structure for performing range/point queries/updates.(即在上面的动机上，还考虑了update的效率)</p><p>前面的例子在update时效率不高，所以Fenwick Tree用了一种聪明的方式，不是累加所有的值，而是分段累加，具体实现看下图：
<figure  style="flex: 67.24511930585683" ><img width="1240" height="922" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/eb45cb86abbe7a62cd8cc8d3fc2a8f06.png" alt=""/></figure></p><ul>
<li>把索引值用二进制表示</li>
<li><code>LSB</code>的解释看图，实际应用上，就是看从低位到高位第一个1的右边有几个0，假设为<code>n</code>个</li>
<li>那么该cell上存的值就是前$2^n$个cell的值的和</li>
</ul>
<p>图中例子是索引10，不直观，我们换成12， 二进制是1100， 最右边有2个零，那么它保存它$2^2=4$个位置的和。
也就是说，如果你要求和，如果用了cell 12位置的值的话，至少可以省掉3次累加。</p><p>当然，它还有更牛逼的特性，结合range query一起来看吧：
<figure  style="flex: 67.3913043478261" ><img width="1240" height="920" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/0a9944a0140262760c9fb4a45cb3d75e.png" alt=""/></figure></p><p>蓝线表示的是当然位置上累加了前几个位置的值，已经很有规律了</p><p>假如计算前11个值的和，过程是：</p><ol>
<li>11的索引是1011，右边没有0，所以当前的和为A[11]</li>
<li>根据$2^0$来移位，来到10。<ul>
<li>右边一个0，所以它管$2^1$个presum，目前A[11] + A[10]</li>
<li>下一个索引自然要减2了，来到8</li>
</ul>
</li>
<li>8是1000，3个零，所以它存了$2^3=8$个值的和，那就是全部了</li>
</ol>
<p>所以：sum = A[11] + A[10] + A[8]</p><ul>
<li>心算sum(0,7)巩固一下</li>
<li>用sum(11,15)演示子区间，其实就是多减1次，至于是减到10还是减到11，看描述，比如这里11是要参与计算的，那就是把前10个减掉就行了。</li>
</ul>
<p>上面演示的都是<code>worst</code>的情况，即首位为1，除了这种情况，别的位都至少存了前$2^n$个元素的值（比如16，直接得到16个元素的和）</p><blockquote>
<p>这里都没讲你是怎么做这个tree的，而是怎么使用它。先弄清楚使用场景再谈构建。</p></blockquote>
<h2>Point Update</h2>
<p>复习一下<code>LSB</code>，虽然可以直接数最右边的零的个数，但数学其实是：</p><ul>
<li>13 = 1101 ($2^3 + 2^2 + 2^0 \Rightarrow 10^3 + 10^2 + 10^0 $)</li>
<li>减去最右边的1和0 =&gt; 1100 （$2^3+2^2=12$) 所以下一个数是12</li>
<li>减去最右边的1和0 =&gt; 1000 就是8了</li>
<li>再减就是0了</li>
</ul>
<p>而按$2^n$来计算个数的话就是这样的：</p><ul>
<li>13 = 1101, 没有0，就是移1位，变成12</li>
<li>12 = 1100， 2个0， 就是移4位，变成8</li>
<li>8 = 1000， 3个0， 移8位，变成0</li>
</ul>
<p>现在来讲update，前面知道，update会级联影响到所以把该cell考虑进去的节点，因此，它需要反着往上找（极端情况当然是找到最后一个元素，通常这个元素就是整个数组的值，所以任何元素的更改，肯定都会影响到它）</p><p>前面找下一个节点用的是减法，现在就要用加法了，比如我更新了cell 9, 用以上两种任意一种方法来计算：</p><ul>
<li>$9 = 2^3 + 1 \Rightarrow 10^3 + 1 = 1001, +1 = 1010 = 10$</li>
<li>1010 + 10 = 1100 = 12</li>
<li>1100 + 100 = 10000 = 16 到顶了，</li>
</ul>
<p>所以需要把9, 10, 12, 16分别应用这个point的更新，也就是说只有这几个cell把9计算进去了。</p><figure  style="flex: 66.59505907626209" ><img width="1240" height="931" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/57cf2e654121e8c54e9f6cd1eeb60d9b.png" alt=""/></figure><p>当然，可以看一下左边的示意图，更直观</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> 
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> 
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<p>代码非常简单，就是不断通过LSB找下一个位置去更新就行了。</p><h2>Construction</h2>
<p>现在来讲构建</p><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">construct</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">length</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="c1"># Clone the values array since we’re # doing in place operations</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">deepCopy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">...</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">LSB</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
<p>几乎就一句话，就是把元素按原数据摆好（即不加别的节点）后，每次找到当前元素影响的上一级（不再向上冒泡）</p><ul>
<li>比如1，把1算进去的有2，虽然上面还有4， 8， 16，但只把1更新到2</li>
<li>到2的上一级是4 (2 + lsb(2) = 4), 把节点2的现值（已经加了节点1）加到4去</li>
<li>所以核心算法始终只有两个变量，i，j代表最近的包含关系</li>
</ul>
<p><strong>一些算法换成位运算</strong></p><ul>
<li>lsb(i): <code>i &amp; -i</code></li>
<li>i -= lsb(i) =&gt; <code>i &amp;= ~lsb(i)</code></li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E5%85%AD%EF%BC%9AFenwick-Tree-%28Binary-Indexed-Tree%29/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next text-muted">
                <span title="Viewing the first page."><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</span>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/2/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 AlanDecode</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>