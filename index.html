<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/0792c859af00d57f17774077bdd3dbf1.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="AlanDecode" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase link-active" href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cocoapods_private_library/" target="_self">CocoaPods创建私有库过程携带遗</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cocoapods_private_library/" target="_self">
                <time class="text-uppercase">
                    February 27 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>创建私有podspec</h1>
<p>完整教程网上很多，我这里是曲曲折折弄好后的一些要点记录，里面的一些路径和库共同自<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">某篇教程</a>，可以直接看他们的教程。</p><p>想看极简的骨架过程可以参考我下面的笔记，当然肯定缺少很多细节，主要是记录一下核心思路，里面的一些库地址出于隐私我就使用了他们公布在网上的而不是自己的真实地址。</p><p>首先，涉及两个仓库，一个放代码，一个放spec，放spec的就是私有库</p><div class="highlight"><pre><span></span><span class="c1"># 创建私有库 （就是host podspec文件的容器）</span>
pod repo add WTSpecs https://coding.net/wtlucky/WTSpecs.git  <span class="c1">#（这是spec仓库）</span>

<span class="c1">## 删除和添加已有的：</span>
pod repo remove WTSpecs
pod repo add WTSpecs git@coding.net:wtlucky/WTSpecs.git

<span class="c1"># 创建pod lib（就是普通项目文件）</span>
pod lib create podTestLibrary
<span class="c1">### 可以选择尝试编辑一个组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下</span>

<span class="c1"># 推送lib到remote</span>
git add .
git commit -s -m <span class="s2">&quot;Initial Commit of Library&quot;</span>
git remote add origin git@coding.net:wtlucky/podTestLibrary.git  <span class="c1"># 添加远端仓库（这是代码仓库）</span>
git push origin master     <span class="c1"># 提交到远端仓库</span>

<span class="c1"># 打rag，推tag</span>
git tag -m <span class="s2">&quot;first release&quot;</span> <span class="m">0</span>.1.0
git push --tags     <span class="c1">#推送tag到远端仓库</span>

<span class="c1"># 编辑podspec</span>
<span class="c1">### 请查阅相关字段文档，注意编辑tag号与你推的tag号一致</span>
<span class="c1">### 特别注意</span>
<span class="c1">### source_files(源码路径，一般在在libNmae/Classes/**/*), </span>
<span class="c1">### resource_bundles(比如.bundle, .xcassets等)， </span>
<span class="c1">### public_header_files(可以理解为Umbrella Header), </span>
<span class="c1">### prefix_header_file(就是.pch文件)</span>

<span class="c1"># lint podspec（注意allow-warnings)</span>
pod lib lint  --allow-warnings 
<span class="c1">## 如果有私有源：</span>
pod lib lint --sources<span class="o">=</span><span class="s1">&#39;YourSource,https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&#39;</span>
<span class="c1">### 前面是私有源，逗号后是官方源，当然，因为我电脑用的是清华源，这里干脆也了往成一致了（不是必要）</span>

<span class="c1"># 如果不是用pod创建的项目，自行创建podspec文件：</span>
 pod spec create PodTestLibrary git@coding.net:wtlucky/podTestLibrary.git  <span class="c1"># 注意仓库名和仓库地址</span>
</pre></div>
<p>本地测试podspec, in podfile:</p><div class="highlight"><pre><span></span><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">&#39;9.0&#39;</span>

<span class="c1"># 几种方式</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s1">&#39;~/code/Cocoapods/podTest/PodTestLibrary&#39;</span>      <span class="c1"># 指定路径</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="ss">:podspec</span> <span class="o">=&gt;</span> <span class="s1">&#39;~/code/Cocoapods/podTest/PodTestLibrary/PodTestLibrary.podspec&#39;</span>  <span class="c1"># 指定podspec文件</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="c1"># 向Spec Repo提交podspec(后面的参数是在消警告和错误的过程中加的，你可以尝试无参数先跑，碰到问题再逐个解决)</span>
pod repo push WTSpecs PodTestLibrary.podspec --allow-warnings --use-libraries --skip-import-validation --verbose
<span class="c1">### 完了后本地~/.cocoapods/repos和远端spec仓库都应该出现PodTextLibrary/0.1.0这个文件夹(对应你刚打的tag），里面有（且只有）刚才创建的podspec文件</span>
</pre></div>
<p>使用</p><div class="highlight"><pre><span></span><span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 0.1.0&#39;</span>
</pre></div>
<ul>
<li><p><code>--allow-warnings</code>, <code>--use-libraries</code>, <code>--skip-import-validation</code> 等参数灵活使用，目标就是为了通过验证</p></li>
<li><p><code>--no-clean</code> 可以在出错时打印更详细的信息（我加了<code>--verbose</code>后在build失败时会提示你加这个)</p></li>
<li><p>碰到有模块不支持i386什么的架构时，添加这个(<a href="https://blog.nowcoder.net/n/68dac16078184973ac061027817a2d9a?from=nowcoder_improve">更多看这篇文章</a>)：</p></li>
<li>
<pre><code>s.xcconfig = {
    'VALID_ARCHS' =&gt;  'x86_64 armv7 arm64',
  }
  s.pod_target_xcconfig = { 'ARCHS[sdk=iphonesimulator*]' =&gt; '$(ARCHS_STANDARD_64_BIT)' }
</code></pre>
</li>
<li><p><code>pod lint implicit declaration of function 'XXXX' is invalid in C99 [-Werror,-Wimplicit-function-declaration]</code> <a href="https://blog.csdn.net/cnwyt/article/details/105073749">看这里</a></p><ul>
<li>很奇怪的问题，我前面的依赖确实添加了该宏定义的模块`s.dependency 'xxxx' 我目前是在问题文件里重新define一次这个宏解决的，</li>
</ul>
</li>
</ul>
<h1>podspec 进阶</h1>
<div class="highlight"><pre><span></span><span class="c1"># [如果]每个子模块有自己的dependency, public headerfile, pchfile等</span>
<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;NetWorkEngine&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">networkEngine</span><span class="o">|</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/NetworkEngine/**/*&#39;</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/NetworkEngine/**/*.h&#39;</span>
    <span class="n">networkEngine</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;AFNetworking&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 2.3&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;DataModel&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">dataModel</span><span class="o">|</span>
    <span class="n">dataModel</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/DataModel/**/*&#39;</span>
    <span class="n">dataModel</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/DataModel/**/*.h&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;CommonTools&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">commonTools</span><span class="o">|</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/CommonTools/**/*&#39;</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/CommonTools/**/*.h&#39;</span>
    <span class="n">commonTools</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;OpenUDID&#39;</span><span class="p">,</span> <span class="s1">&#39;~&gt; 1.0.0&#39;</span>
<span class="k">end</span>

<span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">&#39;UIKitAddition&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">ui</span><span class="o">|</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/UIKitAddition/**/*&#39;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">public_header_files</span> <span class="o">=</span> <span class="s1">&#39;Pod/Classes/UIKitAddition/**/*.h&#39;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">resource</span> <span class="o">=</span> <span class="s2">&quot;Pod/Assets/MLSUIKitResource.bundle&quot;</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">&#39;PodTestLibrary/CommonTools&#39;</span>
<span class="k">end</span>
</pre></div>
<p>体现为：</p><div class="highlight"><pre><span></span>$ pod search PodTestLibrary

-&gt; PodTestLibrary <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
   Just Testing.
   pod <span class="s1">&#39;PodTestLibrary&#39;</span>, <span class="s1">&#39;~&gt; 1.0.0&#39;</span>
   - Homepage: https://coding.net/u/wtlucky/p/podTestLibrary
   - Source:   https://coding.net/wtlucky/podTestLibrary.git
   - Versions: <span class="m">1</span>.0.0, <span class="m">0</span>.1.0 <span class="o">[</span>WTSpecs repo<span class="o">]</span>
   - Sub specs:
     - PodTestLibrary/NetWorkEngine <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/DataModel <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/CommonTools <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
     - PodTestLibrary/UIKitAddition <span class="o">(</span><span class="m">1</span>.0.0<span class="o">)</span>
</pre></div>
<p>使用：</p><div class="highlight"><pre><span></span><span class="n">source</span> <span class="s1">&#39;https://github.com/CocoaPods/Specs.git&#39;</span>  <span class="c1"># 官方库</span>
<span class="n">source</span> <span class="s1">&#39;https://git.coding.net/wtlucky/WTSpecs.git&#39;</span>   <span class="c1"># 私有库</span>
<span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">&#39;9.0&#39;</span>

<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary/NetWorkEngine&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>  <span class="c1">#使用某一个部分</span>
<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary/UIKitAddition&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>

<span class="n">pod</span> <span class="s1">&#39;PodTestLibrary&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0&#39;</span>   <span class="c1">#使用整个库</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cocoapods_private_library/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/hittest/" target="_self">hitTest示例</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/hittest/" target="_self">
                <time class="text-uppercase">
                    February 19 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>往窗口里添加两个自定义的view，这样每个view的<code>hitTest</code>方法被访问的时候我们就能log一下：</p><div class="highlight"><pre><span></span><span class="kd">import</span> <span class="nc">UIKit</span>

<span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

        <span class="kd">let</span> <span class="nv">view1</span> <span class="p">=</span> <span class="n">View1</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="kd">let</span> <span class="nv">view2</span> <span class="p">=</span> <span class="n">View2</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">yellow</span>
        <span class="n">view2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">red</span>

        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view1</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View1</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;enter v1 </span><span class="si">\(</span><span class="n">point</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View2</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;enter v2, </span><span class="si">\(</span><span class="n">point</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>运行：</p><figure class="vertical-figure" style="flex: 46.42857142857143" ><img width="650" height="700" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5b4c2daa70dc2e8941de89fdb19c2bfa.png" alt="image-20220219014246803"/></figure><p>在空白处(<strong>bottom view</strong>)点了一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span>-48.66007995605469, <span class="m">306</span>.0133361816406<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">11</span>.339920043945312, <span class="m">366</span>.0133361816406<span class="o">)</span>
enter v2, <span class="o">(</span>-48.66007995605469, <span class="m">306</span>.0133361816406<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">11</span>.339920043945312, <span class="m">366</span>.0133361816406<span class="o">)</span>
enter v2, <span class="o">(</span>-43.33333333333334, <span class="m">325</span>.3333333333333<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">16</span>.666666666666657, <span class="m">385</span>.3333333333333<span class="o">)</span>
enter v2, <span class="o">(</span>-43.33333333333334, <span class="m">325</span>.3333333333333<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">16</span>.666666666666657, <span class="m">385</span>.3333333333333<span class="o">)</span>
</pre></div>
<p>在红框上(<strong>top view</strong>)点一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span><span class="m">38</span>.66666666666666, <span class="m">48</span>.66666666666666<span class="o">)</span>
enter v2, <span class="o">(</span><span class="m">38</span>.66666666666666, <span class="m">48</span>.66666666666666<span class="o">)</span>
</pre></div>
<p>在黄框(<strong>middle view</strong>)点一下，输出：</p><div class="highlight"><pre><span></span>enter v2, <span class="o">(</span>-31.210678100585938, -27.8685302734375<span class="o">)</span>
enter v2, <span class="o">(</span>-31.210678100585938, -27.8685302734375<span class="o">)</span>
enter v2, <span class="o">(</span>-25.0, -22.333333333333343<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">35</span>.0, <span class="m">37</span>.66666666666666<span class="o">)</span>
enter v2, <span class="o">(</span>-25.0, -22.333333333333343<span class="o">)</span>
enter v1, <span class="o">(</span><span class="m">35</span>.0, <span class="m">37</span>.66666666666666<span class="o">)</span>
</pre></div>
<ul>
<li>我们知道<code>hitTest</code>机制是事件传递链由底向上，响应链由上到下，</li>
<li>所以最底层的<strong>bottom view</strong>最先接到事件就开始找响应者</li>
<li>它开始从它的最顶层subview开始找响应者(<code>v2</code>)，然后再往下(<code>v1</code>)，均没找到，所以就是自己了</li>
<li>为何调了四次呢？（未深究）<blockquote>
Yes, it’s normal. The system may tweak the point being hit tested between the calls. Since hitTest should be a pure function with no side-effects, this should be fine.</blockquote>
</li>
<li>第二次测试，直接在最顶层view就找到了（所谓的找到，就是点击的位置在这个view的bounds内，后面说）</li>
<li>至于为什么坐标会变？（未深究）</li>
<li>第三次测试，点了v1，可以看到日志，在v2那里跑了3次，再跑了v1，不知道为什么还是没返回，还跑了一次v2后才认定v1</li>
</ul>
<p>大体可以知道hitTest的机制了吧？以传递链的终点那个view为基础，在subviews逆向遍历（自顶向下），一直到自己。</p><h2>应用1</h2>
<p>来个简单场景，如果黄色的view是有触摸事件的，并且要求被覆盖的区域也能响应，该怎么做呢？</p><p>思考：</p><ul>
<li>我们知道点击的位置，肯定是在黄框范围内的，所以要的就是一个入口，用来判断这个点与黄框的关系，一旦确认点的范围是在黄框里，就把认为黄框是事件响应者。</li>
<li>因此改下demo，加了事件，还加了一个parent view（这样才能在用属性的方式把黄框引用出来）</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>


        <span class="kd">let</span> <span class="nv">view1</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">110</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="kd">let</span> <span class="nv">view2</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">170</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">150</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">150</span><span class="p">))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">yellow</span>
        <span class="n">view2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="p">.</span><span class="n">red</span>

        <span class="kd">let</span> <span class="nv">tap</span> <span class="p">=</span> <span class="bp">UITapGestureRecognizer</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="kc">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">tap</span><span class="p">(</span><span class="kc">_</span><span class="p">:)))</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">tap</span><span class="p">)</span>
        <span class="n">view1</span><span class="p">.</span><span class="n">isUserInteractionEnabled</span> <span class="p">=</span> <span class="kc">true</span>

        <span class="kd">let</span> <span class="nv">view</span> <span class="p">=</span> <span class="n">View</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">view1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">view2</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">tap</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;view1 taped&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">View</span><span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">view1</span><span class="p">:</span> <span class="bp">UIView</span>
    <span class="kd">var</span> <span class="nv">view2</span><span class="p">:</span> <span class="bp">UIView</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="bp">UIView</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">UIView</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view1</span> <span class="p">=</span> <span class="n">a</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view2</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">required</span> <span class="kd">init</span><span class="p">?(</span><span class="n">coder</span><span class="p">:</span> <span class="bp">NSCoder</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">fatalError</span><span class="p">(</span><span class="s">&quot;init(coder:) has not been implemented&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hitTest</span><span class="p">(</span><span class="kc">_</span> <span class="n">point</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">,</span> <span class="n">with</span> <span class="n">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="bp">UIView</span><span class="p">?</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nv">loc_v1</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">view1</span><span class="p">)</span>
          <span class="c1">// 主要就是这一句</span>
        <span class="k">if</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">view1</span><span class="p">.</span><span class="n">point</span><span class="p">(</span><span class="n">inside</span><span class="p">:</span> <span class="n">loc_v1</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">view1</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">hitTest</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li><code>let loc_v1 = self.convert(point, to: self.view1)</code>意思是这个点以view1为坐标系的位置</li>
<li><code>if(self.view1.point(inside: loc_v1, with: event))</code> 这就是判断这个点在不在view1的bounds里面了</li>
</ul>
<p>简单来说，就是简单粗暴地“逮住每一个机会”，问是不是你，是不是你。</p><h2>应用2</h2>
<p>如果一个按钮很小，你要扩大他的点击区域怎么做？网上有很多方法，关联属性啊，交换方法啊，可以去搜搜，我们这里继续上面的例子，知道有一个<code>point(inside:with)</code>方法，顾名思义，就是这个点在不在我的视图区域内</p><p>它当然也是可以被重写，自定义在什么样的范围内，都算<code>inside</code>，下面是网上抄的一段代码</p>
<pre><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event {
   //获取当前button的实际大小
    CGRect bounds = self.bounds;
    //若原热区小于44x44，则放大热区，否则保持原大小不变
    CGFloat widthDelta = MAX(44.0 - bounds.size.width, 0);
    CGFloat heightDelta = MAX(44.0 - bounds.size.height, 0);
    //扩大bounds
    bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);
    //如果点击的点 在 新的bounds里，就返回YES
    return CGRectContainsPoint(bounds, point);
}
</code></pre>
<p>这个例子主要就是利用底层的<code>CGRectContainsPoint</code>方法，传入了新的<code>bounds</code>，可以理解为人为修改入参吧。代码也很明确了，自己根据当前的bounds合理做一个大一点的bounds，交给系统去做就行了。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/hittest/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Layer/" target="_self">Programming iOS 14 - Layer</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Layer/" target="_self">
                <time class="text-uppercase">
                    February 18 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第3章</p><hr />
<h1>Layers</h1>
<ul>
<li>A UIView does not actually <strong>draw itself</strong> onto the screen; it draws itself <strong>into its layer</strong>, and it is the layer that is portrayed on the screen.</li>
<li>a view is not <strong>redrawn</strong> frequently;</li>
<li>instead, its drawing is cached, and the cached version of the drawing (<code>the bitmap backing store</code>) is used where possible.</li>
<li>The cached version is, in fact, the <code>layer</code>.</li>
<li>the view’s graphics context is <code>actually</code> the layer’s graphics context.</li>
<li>a layer is the <code>recipient</code> and <code>presenter</code> of a view’s drawing</li>
<li>Layers are <code>made to be animated</code></li>
<li>View持有layer，是layer的代理（<code>CALayerDeletgate</code>）<ul>
<li>但layer不能找到View</li>
</ul>
</li>
<li>View的大部分属性都只是其<code>underlying layer</code>的便捷方法</li>
<li>layer能操控和改变view的表现，而无需ask the view to redraw itself</li>
</ul>
<p>自定义underlaying layer的方法</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">CompassView</span> <span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">class</span> <span class="nc">var</span> <span class="n">layerClass</span> <span class="p">:</span> <span class="nb">AnyClass</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">CompassLayer</span><span class="p">.</span><span class="kc">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>Layers and Sublayers</h2>
<ul>
<li><p>layer的继承树跟view的继承树几乎一致</p></li>
<li><p>layer的<code>masksToBounds</code>属性决定了能否显示sublayer超出了其bounds的部分，这也是view的<code>clipsToBounds</code>的平行属性</p></li>
<li><p><code>sublayers</code>是可写的，而<code>subviews</code>不是</p><ul>
<li>所以设为nil可以移除所有子层，但subview却需要一个个<code>removeFromSuperview</code></li>
</ul>
</li>
<li><p><code>zPostion</code>决定了层级（order），默认值都是0.0</p></li>
<li><p>a layer does not have a center靠<code>position</code>和<code>anchorPoint</code>定位</p><ul>
<li>position: 在superLayer中的位置</li>
<li>anchorPoint: 用小数表示的bound(宽/高)位置，左上(0, 0), 右下(1, 1)， default:(0.5, 0.5)</li>
<li>所以(0.5, 0.5)的anchorPoint，对应的<code>poosition</code>就等同于center了，理解一下<ul>
<li>其实就是说你的“锚点”在superLayer的什么位置的意思</li>
</ul>
</li>
<li>When you get the frame, it is calculated from the <code>bounds size</code> along with the <code>position</code> and <code>anchorPoint</code>.<ul>
<li>When you set the frame, you set the <code>bounds</code> size and <code>position</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// demo, 把一个80x40的layer，左上角放到(130, 120的位置）</span>
<span class="n">let</span><span class="w"> </span><span class="n">layer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="n">cgColor</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">130</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">120</span><span class="p">)</span><span class="w"></span>
<span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
<blockquote>
<p>如果一个layer的position是(0, 0)，锚点是(0,0)，刚好显示在左上角
而（0.5，0.5)则只能显示右下角的1/4了
即(0.5, 0.5)到了原来(0,0)的位置。所以说其实就是把自身bounds度量下的哪个位置移到(0,0)</p></blockquote>
<p>这么说来，对锚点的最正确理解其实是，</p><ul>
<li>我把自身坐标系里的哪个点定义为原点，</li>
<li>并且，这个点移到原本“左上角”的位置（想象0.5,0.5)</li>
<li>并且，所有的旋转之类的动画本来是对“左上角”<strong>的位置</strong>进行的，不管现在这个位置是layer上的哪个部分<ul>
<li>或者说，旋转永远是发生在<code>position</code>上的，你把哪个点放到position上它不管</li>
</ul>
</li>
</ul>
<p>理解frame的小练习</p><div class="highlight"><pre><span></span><span class="c1">// 如果我设了layer的frame:</span>
<span class="n">circle</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"></span>

<span class="c1">// 实际上是通过size, position, anchorPoint来实现的：</span>
<span class="n">circle</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"></span>

<span class="c1">// 以左上角为anchorPoint</span>
<span class="n">circle</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">50</span><span class="p">)</span><span class="w"></span>
<span class="n">circle</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 或者，以中心为anchorPoint</span>
<span class="n">circle</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mi">150</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">150</span><span class="p">)</span><span class="w"></span>
<span class="n">circle</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mf">0.5</span><span class="p">)</span><span class="w"></span>
<span class="c1">// 或者其它任意anchorPoint，前提是自己换算</span>
<span class="c1">// 而且，虽然位置是一样的，但会影响transform</span>
</pre></div>
<p><strong>CAScrollLayer</strong></p><ul>
<li>你想通过移动layer的bounds来重定位sublayers，可以使用<code>CAScrollLayer</code></li>
<li>但是它并不能通过拖拽来移动里面的内容（记得它没有响应链）</li>
<li>而是理解为一个<code>masksToBounds</code>的窗口，你只能看到它bounds里面的内容</li>
<li>能通过本身的<code>scroll(to:)</code>方法，和sublayers的<code>scroll(_:)</code>和<code>scrollRectToVisible(_:)</code>方法来改变scroll layer的bounds，达到显示sublayer指定区域的目的</li>
</ul>
<p><strong>Layer and Delegate</strong></p><ul>
<li>对一个不是UIView的undrelying layer的layer，让（任意）一个对象成为其delegate，可以由它来操控它的layout和drawing</li>
<li>但千万不要让UIView成为不是其underlying的layer的代理，反之亦然</li>
</ul>
<p><strong>Layout of Lyaers</strong></p><ul>
<li>When a layer needs layout, either because its <em>bounds have changed</em> or because you called <code>setNeedsLayout</code></li>
</ul>
<h2>Drawing in a Layer</h2>
<ul>
<li>set <code>contents</code> is the simplest way to draw in a layer -&gt; <code>CGImage</code><ul>
<li>但<code>contents</code>能接受任何类型，所以不正确的content只会<strong>fail silently</strong></li>
</ul>
</li>
<li>layer也有一个<code>draw(_:)方法，它被(自动)调用的时候通常表示要</code>redisplay itself`，什么时候需要redisplay itself?<ul>
<li>如果<code>needsDisplayOnBoundsChange</code>是false，那么就只有在<code>sefNeedDisplay</code>方法（及其<code>inRect</code>衍生方法）里会触发<ul>
<li>如果是非常重要的重绘，那么需要再显式调用一次<code>displayIfNeeded</code></li>
</ul>
</li>
<li>是true的话就如其名，在bounds变化的时候也会重绘</li>
</ul>
</li>
<li>有四个方法能在redisplay的时候调用:<ol>
<li>subclass的<code>display</code>重载，它没有<code>graphics context</code>，所以只能提供图片</li>
<li>delegate的<code>display(in:)</code>方法，同样，只能提供图片</li>
<li>subclass的<code>draw(in:)</code>方法，有context，所以能直接在里面绘图，但不会<code>make current context</code></li>
<li>delegate的<code>draw(_:in)</code>方法，限制也同上</li>
</ol>
</li>
<li>underlaying layer不应调用上面的方法，而交由view的<code>draw(_:)</code>方法<ul>
<li>一定要调也可以，但要显式实现view的<code>draw(_:)</code>方法，方法体为空就行了</li>
</ul>
</li>
</ul>
<p><strong>Drawing-Related Layer Properties</strong></p><ul>
<li>contentsScale: 像素对高分屏的映射，Cocoa管理的layer会自动设置，自定义的类需要注意这个scale</li>
<li>opacity: 就是view的<code>alpha</code><ul>
<li>Changing the isOpaque property has no effect until the layer redisplays itself.</li>
</ul>
</li>
</ul>
<p><strong>Content Resizing and Positioning</strong></p><ul>
<li>A layer’s content is stored (cached) as a bitmap which is then treated like an image:<ul>
<li>如果content来自一张图片，那么缓存的就是图片（CGImage），大小就是图片的point size</li>
<li>如果来自绘图，那么存的是graphics context</li>
</ul>
</li>
<li><code>ContentGravity</code>，类似UIView’s contentMode property，即缩放拉伸<ul>
<li>因为坐标系不同的历史原因，top, bottom是相反的</li>
<li>如果是自己绘制，则这个属性无意义，但结合下面的rect属性又有用了，因为截取了rect大小的绘制</li>
</ul>
</li>
<li><code>contentsRect</code>，结合上一个属性，做购物网站那种截取一小块，绘制到一个大图上去。这里是绘制到view上<ul>
<li>默认是全图(0,0,1,1)</li>
</ul>
</li>
<li><code>contentsCenter</code> ?? 好像是对上述rect属性划成9宫格，不同位置的格子缩放规则不一样，比如四个角落的格子，不会缩放<ul>
<li>所以给了一个center region（rect)，把它的四条边延长，就有9个格子了</li>
</ul>
</li>
</ul>
<p><strong>Layers that Draw Themselves</strong></p><p>系统内置了一些能自我绘制的layer:</p><ul>
<li>CATextLayer，轻量版的UILabel。通过<code>string</code>属性存取，与<code>contenta</code>会冲突，不要同时设。</li>
<li>CAShapeLayer, 有path属性，可以与<code>contents</code>共存，path绘制于content之上，并且不能设融合模式</li>
<li>CAGradientLayer，通过背景色做的渐变，去了解下clip和mask</li>
</ul>
<h2>Transforms</h2>
<ul>
<li>view的transform是根据其<strong>center</strong>来应用的，layer的是根据<code>anchorPoint</code><ul>
<li>所以<code>anchorPoint</code>就两个作用，把它移动到<code>position</code>的位置，和以它为中心进行旋转</li>
</ul>
</li>
</ul>
<ol>
<li>画刻度，核心是把文字先往上挪到圆圈的位置，所以anchorPoint只动y不动x (center, midY/textHeight)</li>
</ol>
<div class="highlight"><pre><span></span><span class="n">let</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCD&quot;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CATextLayer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">center</span><span class="w"> </span><span class="c1">// 这才是核心，一切定位和旋转的基准</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">vert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">circle</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">midY</span><span class="o">/</span><span class="n">t</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">height</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="n">vert</span><span class="p">)</span><span class="w"> </span><span class="c1">// 半圆是文字调蓄的多少倍，就上移多少，但隐形的脚（即高跷的支点）仍在position处</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">foregroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="w"></span>

<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">setAffineTransform</span><span class="p">(</span><span class="bp">CGAffineTransform</span><span class="p">(</span><span class="n">rotationAngle</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CGFloat</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">circle</span><span class="p">.</span><span class="n">addSublayer</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>结果如图：
<figure class="vertical-figure" style="flex: 49.51923076923077" ><img width="412" height="416" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/031ad73f3f956d76b906cf986e36e22e.png" alt=""/></figure></p><ol start="2">
<li>画箭头，演示了复杂的绘制怎么把它代理出去，并且什么时机让它产生绘制：</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1">// the arrow</span>
<span class="n">let</span><span class="w"> </span><span class="n">arrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">contentsScale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">scale</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">anchorPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGPoint</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.8</span><span class="p">)</span><span class="w"> </span><span class="c1">// 箭尾凹进去的位置（所以不可能是1.0）</span>
<span class="n">arrow</span><span class="p">.</span><span class="n">delegate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">self</span><span class="w"> </span><span class="c1">// we will draw the arrow in the delegate method</span>
<span class="n">arrow</span><span class="p">.</span><span class="n">setAffineTransform</span><span class="p">(</span><span class="bp">CGAffineTransform</span><span class="p">(</span><span class="n">rotationAngle</span><span class="o">:</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">5.0</span><span class="p">))</span><span class="w"></span>
<span class="nb">self</span><span class="p">.</span><span class="n">addSublayer</span><span class="p">(</span><span class="n">arrow</span><span class="p">)</span><span class="w"></span>
<span class="n">arrow</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span><span class="w"> </span><span class="c1">// draw, please</span>
</pre></div>
<p>** 3D Transforms</p><ul>
<li>A layer’s <code>affineTransform</code> is merely a façade for accessing its <code>transform</code>.</li>
<li>A layer’s <code>transform</code> is a three-dimensional transform, a <code>CATransform3D</code></li>
</ul>
<p>绕Y轴镜像的示例：</p><div class="highlight"><pre><span></span><span class="n">someLayer</span><span class="p">.</span><span class="n">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CATransform3DMakeRotation</span><span class="p">(.</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>一般而言，在Z轴没有分量的平面图，那就只剩旋转的效果了（没有翻转)
<figure  style="flex: 51.151315789473685" ><img width="622" height="608" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/714bca8197bc1e5f9e71216b3ccd0745.png" alt=""/></figure></p><p>这是把anchorPoint设在了圆心，如果设在(0,0):
<figure class="vertical-figure" style="flex: 45.258620689655174" ><img width="1260" height="1392" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8e747494f676181ffca14504623cb89b.png" alt=""/></figure></p><ul>
<li>layer不是为了3D建模而诞生的（考虑<code>Metal</code>），它是2D对象，为<code>speed</code>和<code>simplicity</code>而设计</li>
</ul>
<p><strong>depth</strong></p><p>现实世界<code>z-component</code>的加入会近大远小，layer绘制没有表现出这种距离，而是压平到一个面：<code>orthographic projection</code>，但是使用了一些技巧来制造这种视觉效果。</p><p>[waiting for demo]</p><h2>Futher Layer Features</h2>
<p><strong>shadows</strong></p><ul>
<li>The shadow is normally based on the shape of the layer’s <code>nontransparent</code> region<ul>
<li>所以完全透明的视图是没有阴影的</li>
</ul>
</li>
<li>clip和shadow是不可能同时存在的，技巧是用另一个view叠到底层，让它实现阴影。</li>
</ul>
<p><strong>Borders and Rounded Corners</strong></p><ul>
<li>想要圆角，就必须用<code>masksToBounds</code>来实现clip，同时还要阴影的话，又得借助上图的技巧了。</li>
<li>从iOS 11起，可以单独设置圆角了：<code>maskedCorners</code>，它由minx, miny, maxx, maxy这种风格的描述进行组合，而不是我们期望的top-left之类的。</li>
</ul>
<p><strong>Masks</strong></p><ul>
<li>A CALayer can have a mask. This is itself a <strong>layer</strong>, whose content must be provided somehow.</li>
<li>只有透明部分有作用<ul>
<li>透明的位置，对应的layer位置也是透明的</li>
<li>反过来想不透明的部分，还是被应用mask的layer能显示的部分</li>
<li>这就是photoshop里图层蒙板”涂黑就是显示“的意思</li>
</ul>
</li>
<li>there is no built-in mechanism for <strong>automatically resizing the mask</strong> as the layer is resized.</li>
<li>把一个view当作另一个view的mask属性，底层就是相应的layer</li>
</ul>
<p>下例用mask来制作自己的圆角矩形，注意里面context和path的关系。在context里面，新建的path都是能直接绘制的，而不需要这个path设为谁的属性（drawRect:方法里也是一样，只要新建path，再自行去stoke, fill都行，</p><p>而context上也可以直接绘制</p><div class="highlight"><pre><span></span><span class="n">func</span><span class="w"> </span><span class="nf">mask</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="n">sz</span><span class="o">:</span><span class="n">CGSize</span><span class="p">,</span><span class="w"> </span><span class="n">roundingCorners</span><span class="w"> </span><span class="n">rad</span><span class="o">:</span><span class="n">CGFloat</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">CALayer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRect</span><span class="p">(</span><span class="n">origin</span><span class="o">:</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="o">:</span><span class="n">sz</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">bounds</span><span class="o">:</span><span class="n">rect</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">im</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">image</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="k">in</span><span class="w"></span>
<span class="w">        </span><span class="c1">// context绘制</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">con</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">(</span><span class="n">white</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="o">:</span><span class="mi">0</span><span class="p">).</span><span class="n">cgColor</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">(</span><span class="n">white</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="o">:</span><span class="mi">1</span><span class="p">).</span><span class="n">cgColor</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// path绘制</span>
<span class="w">        </span><span class="n">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">roundedRect</span><span class="o">:</span><span class="n">rect</span><span class="p">,</span><span class="w"> </span><span class="n">cornerRadius</span><span class="o">:</span><span class="n">rad</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">CALayer</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">mask</span><span class="p">.</span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rect</span><span class="w"></span>
<span class="w">    </span><span class="n">mask</span><span class="p">.</span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">im</span><span class="p">.</span><span class="n">cgImage</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>Layer Efficiency</h2>
<p>由于移动设备算力的影响，大量叠加的半透明图层的渲染是一件很消耗且低效的事，特别是动画的时候。</p><p>debug：</p><ol>
<li>Core Animation template in <strong>Instruments</strong></li>
<li>New in Xcode 12, animation “hitches” can be measured with <code>XCTMetrics</code> during performance testing.</li>
<li>the Simulator’s <code>Debug</code> menu lets you summon <code>colored overlays</code> that provide clues as to possible sources of <strong>inefficient drawing</strong><ul>
<li>真机：Debug → View Debugging → Rendering</li>
</ul>
</li>
<li>New in Xcode 12, the view debugger (“View Debugger” on page 75) can display layers — choose Editor → Show Layers — and can offer suggestions for improving layer rendering efficiency.</li>
</ol>
<p>tips:</p><ol>
<li><strong>opaque drawing</strong> is most efficient.<ul>
<li>Nonopaque drawing is what the Simulator marks when you check Debug → Color Blended Layers.</li>
</ul>
</li>
<li>“freezing” the entirety of the layer’s drawing as a <strong>bitmap</strong>.<ul>
<li>直接绘制效率确实比缓存效率高</li>
<li>但是过深过复杂的继承树，没必要每次都实时计算渲染</li>
<li>by <code>shouldRasterize = true</code> and <code>rasterizationScale = UIScreen.main.scale</code></li>
</ul>
</li>
<li><code>drawsAsynchronously = true</code></li>
</ol>
<h2>Layers and Key-Value Coding</h2>
<div class="highlight"><pre><span></span><span class="n">layer</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>
<span class="c1">// or:</span>
<span class="n">layer</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;mask&quot;</span><span class="p">)</span><span class="w"></span>

<span class="nb">self</span><span class="p">.</span><span class="n">rotationLayer</span><span class="p">.</span><span class="n">transform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CATransform3DMakeRotation</span><span class="p">(.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="c1">// or:</span>
<span class="nb">self</span><span class="p">.</span><span class="n">rotationLayer</span><span class="p">.</span><span class="n">setValue</span><span class="p">(.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="n">forKeyPath</span><span class="o">:</span><span class="s">&quot;transform.rotation.y&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
<ul>
<li><p>不代表<code>CATransform3D</code>有<code>rotation</code>属性</p><ul>
<li>它没有任何属性</li>
<li>它甚至不是一个对象</li>
<li><code>self.rotationLayer.transform.rotation.y = //... no, sorry</code></li>
</ul>
</li>
<li><p>some transform key:</p></li>
</ul>
<p>• &quot;rotation.x&quot;,&quot;rotation.y&quot;,&quot;rotation.z&quot;
• &quot;rotation&quot; (same as &quot;rotation.z&quot;)
• &quot;scale.x&quot;,&quot;scale.y&quot;,&quot;scale.z&quot;
• &quot;translation.x&quot;,&quot;translation.y&quot;,&quot;translation.z&quot; • &quot;translation&quot; (two-dimensional, a CGSize)</p><ul>
<li>The<code>Quartz Core</code> framework also injects key–value coding compliance into <code>CGPoint</code>, <code>CGSize</code>, and <code>CGRect</code>, allowing you to use keys and key paths matching their <code>struct component names</code>.</li>
</ul>
<blockquote>
<p>see “Core Animation Extensions to Key-Value Coding” in Apple’s Core Animation Programming Guide</p></blockquote>
<ul>
<li>you can treat a <code>CALayer</code> as a kind of <code>dictionary</code>, and get and set the value for any key.<ul>
<li>view有tag，layer就有任意key</li>
</ul>
</li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Layer/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">《Effective Objective-C 2.0》笔记第1-2章</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/" target="_self">
                <time class="text-uppercase">
                    January 14 2022
                </time>
            </a>
        </div>
        <div class="prism-content"><figure class="vertical-figure" style="flex: 38.0" ><img width="912" height="1200" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/ac920d0dab7ba40befbff58ed826b587.png" alt=""/></figure><blockquote>
<p>这个书当然中文版的，也很经典，我也读过了，但是嘛，老规矩，有原版还是读一遍原版，再加上英文水平也只有那么好，有机会能多读读在就多读读吧。一共就7章，52节，200多页，并不多。
此外，因为很多名词其实我们平时直接叫的就是英文，中文版里统统都给了一个中文翻译，反而更陌生了，有种“访达”的即视感。</p></blockquote>
<h1>Chapter 1: Accustoming Yourself to Objective-C</h1>
<h2>Item 1: Familiarize Yourself with Objective-C’s Roots</h2>
<ol>
<li><code>messaging structure</code> v.s. <code>function callihng</code><ul>
<li>in messaging structure, the <strong>runtime</strong> decides which code gets executed, while in function, the  <strong>compiler</strong> decides.</li>
<li><code>dynamic binding</code> v.s. <code>virtual table</code>  &lt;= 多态</li>
</ul>
</li>
<li><code>runtime component</code> v.s. <code>compiler</code><ul>
<li>含有所有让面向对象的OC能工作的 <em>data structures</em> and <em>functions</em><ul>
<li>比如，含有所有的memory-management methods</li>
</ul>
</li>
<li>更新runtime component就能提升性能，而无需重新编译</li>
</ul>
</li>
<li>Objective-C is a superset of C<ul>
<li>所以语法基本类似：<code>NSString *str = @&quot;The String</code></li>
<li>表示声明了一个变量，类型是<em>NSString *</em>，是一个指向NSString的指针</li>
<li>所有OC对象必须如此声明，对象内存也总是分配在heap space上<ul>
<li>这是分配到stack上：<code>NSString stackString</code> &lt;- 报错</li>
</ul>
</li>
<li>但指向这个对象的指针（<strong>pointer</strong>）是分配在<code>stack frame</code>里的，多个指向同一对象的指针就分配了多个内存<ul>
<li>每个内存大小就是一枚指针的大小</li>
<li>值也是一样</li>
</ul>
</li>
</ul>
</li>
<li>The memory allocated in the <code>heap</code> has to be <strong>managed directly</strong><ul>
<li>OC将堆内存管理抽象了出来，<code>runtime</code>进一步抽象成一套内存管理架构：<code>reference counting</code></li>
</ul>
</li>
<li>整个系统框架都要使用结构体，用对象会有额外的开销</li>
</ol>
<h2>Item 2: Minimize Importing Headers in Headers</h2>
<p>Objective-C, just like C and C++, makes use of <code>header files</code> and implementation files.</p><ol>
<li><code>forward declaring</code> -&gt; <code>@class SomeClass</code><ul>
<li>头文件里并不知道知道一些类的实现细节，只需要知道有这么一个类就行了</li>
<li>但是<code>.m</code>文件里就要自行去import一次这个class了</li>
<li>原则就是尽量延后引入头文件的时机，减少编译时间</li>
<li>还解决了互相引用的问题</li>
<li>引用<code>super class</code>, <code>protocol</code>等必须要知道细节，不能应用<code>forward declaring</code><ul>
<li>所以最好把protocol单独放在一个头文件，避免无谓地引用大文件，增加编译时间</li>
<li>但是<code>delegate</code>放到<code>class-continuation category</code>里面写更好（即在<strong>.m</strong>文件里写protocol和import），无需暴露到公共头文件</li>
</ul>
</li>
<li>关键词：<code>减小依赖</code>，<code>缩减编译时间</code></li>
</ul>
</li>
</ol>
<h2>Item 3: Prefer Literal Syntax over the Equivalent Methods</h2>
<ul>
<li>尽量使用字面量语法（<code>Literal Syntax</code>）创建和使用对象</li>
<li>字面量语法只是一个语法糖（<code>syntactic sugar</code>），推荐使用字面量，会减少代码量，但最好知道它对应的原始方法。（但是还是会有所区别，看下例）</li>
<li>用字面量初始数组，如果不是最后一个元素是nil，会报错，而原始的<code>arrayWithObjects:</code>方法则会在碰到第一个nil时当成是终止参数而正常执行（只保留nil前的元素初始化数组）<ul>
<li>作者说这反而是好事，未预料到的情况成功执行比报错更可怕，抛异常能更早地发现错误</li>
</ul>
</li>
<li>只能创建Foundation框架的对象，自定义对象不行（一般也没必要）</li>
<li>使用字面量语法创建出来的String, Array, Dict等都<code>immutable</code>的</li>
</ul>
<h2>Item 4: Prefer Typed Constants to Preprocessor #define</h2>
<ul>
<li><code>#define</code>本质是替换</li>
<li><code>#define</code>出来的是没有类型信息的</li>
<li>如果是声明在头文件中，引用了此头文件的代码都会应用此替换<ul>
<li>即使被重定义了，编译器也不会产生警告</li>
</ul>
</li>
<li>而常量就带了类型信息<ul>
<li><code>static NSString * const MyStringConstants = &quot;Hello world;</code></li>
<li>注意星号的位置，这里表示指针指向的是整个常量</li>
<li>如果把星号写到const后，那表示指针就是那个常量...</li>
</ul>
</li>
<li>定义常量的位置很重要（预处理指令也一样），不打算公开的话就在<code>.m</code>文件里定义</li>
<li>命令也很重要</li>
<li>否则成了全局变量，很可能”不经意“引起变量冲突/覆盖</li>
<li><code>static const</code>要一起使用，单独的<code>const</code>会报错<ul>
<li><code>static</code>不再是别的语言中的<strong>静态变量</strong>，而保是一个作用域声明</li>
<li>一个编译单元（<code>translation unit</code>）个输出一个目标文件（<code>object file</code>）<ul>
<li>考虑你编译一个c++文件，一个文件生成一个目标（二进制）文件，然后再链接。</li>
<li>所以一个编译单元一般是一个<code>.m</code>文件</li>
</ul>
</li>
<li>结合起来，<code>static</code>就是在一个目标文件内可见</li>
<li>如果不加<code>static</code>，编译器会添加一个<code>external symbol</code>（后面有详述），这样就有重定义风险了（<code>duplicate symbol</code>）</li>
</ul>
</li>
<li>最后，事实上<code>static const</code>一起用，编译器做的仍然是<strong>替换</strong>，而没有去创建符号（但此时已经有类型信息了）</li>
</ul>
<p>*如果需要公开，则添加到全局符号表（<code>global symbol table</code>）中：</p><div class="highlight"><pre><span></span><span class="c1">// In the header file</span>
<span class="k">extern</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="p">;</span><span class="w"></span>

<span class="c1">// In the implementation file</span>
<span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">EOCStringConstant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">@&quot;VALUE&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>上面解释了<code>static</code>，现在来解释<code>extern</code><ul>
<li><code>extern</code>表示向编译器保证全局符号表中将会有这个符号，其实就是要编译器不要继续检查</li>
<li>它知道链接成二进制文件后，肯定能找到这个常量</li>
</ul>
</li>
<li>所以在<code>.m</code>文件里正常定义和赋值，在<strong>任意</strong><code>.h</code>文件时给编译器打个招呼就行了</li>
<li>命名规范：<ul>
<li>如果是限定可见域的，用<code>k</code>开头就行了</li>
<li>如果会公开的，那么就用函数名作前缀（系统框架都是这么做的）</li>
</ul>
</li>
</ul>
<p><strong>external symbol</strong> V.S. <strong>global symbol</strong></p><blockquote>
<p>前文你已经知道了两种提升作用域的方式，区别在</p><ul>
<li>一个是通过不对const加static（添加external symbol），</li>
<li>一个是额外声明extern（添加到blobal symbol talbe）</li>
</ul>
</blockquote>
<h2>Item 5: Use Enumerations for States, Options, and Status Codes</h2>
<ul>
<li>枚举只是一种常量命名方式</li>
<li>语法很奇葩：<code>enum EOCConnectionState</code> state = EOCConnectionStateDisconnected;<ul>
<li>看高亮的部分，别人只要写一个type，它要连enum带名称写全</li>
</ul>
</li>
<li>所以一般会<code>typedef</code>一下：<code>typedef enum EOCConnectionState EOCConnectionState;</code><ul>
<li>现在就可以用<code>EOCConnectionState</code>这个type来定义变量了</li>
</ul>
</li>
<li>用enum来做选项(options)的时候，因为不是互斥的关系，选择bitwise OR operator来会直观很多（就是每一个二进制位代表一个状态）</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">UIViewAutoresizing</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingNone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleLeftMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleRightMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleTopMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">UIViewAutoresizingFlexibleBottomMargin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<figure  style="flex: 66.52173913043478" ><img width="918" height="690" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4a634eedbb41d909a0b262a8f2f437ee.png" alt=""/></figure><ul>
<li>Foundation框架定义了一些辅助宏，以便支持新的C++标准对宏定义的增强同时还能兼容老的标准: <code>NS_ENUM</code>和<code>NS_OPTIONS</code><ul>
<li>特别是c++对枚举值里的bitwise操作结果需要显式转换</li>
<li>所以用到了<strong>可组合</strong>的option类的枚举，最好用<code>NS_OPTIONS</code>宏，否则用<code>NS_ENUM</code>就够了</li>
</ul>
</li>
<li>对enum应用<code>switch</code>最好不要加<code>default</code>，这样你添加了新的枚举值而忘记了处理，能及时得到错误反馈</li>
</ul>
<h1>Chapter 2: Objects, Messaging, and the Runtime</h1>
<h2>Item 6: Understand Properties</h2>
<ul>
<li><code>Properties</code> are an Objective-C feature providing encapsulation of the data an object contains.<ul>
<li>stored by <code>instance variables</code></li>
<li>accessed through <code>accessor methods</code> (getter, setter)<ul>
<li>can be written by complier automatically &lt;= <code>autosynthesis</code></li>
<li>introduced a <code>dot syntax</code> to  accessing the data</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看一下C++写法：</p><div class="highlight"><pre><span></span><span class="err">@</span><span class="n">interface</span><span class="w"> </span><span class="n">EOCPerson</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">NSObject</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="err">@</span><span class="k">public</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_firstName</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_lastName</span><span class="p">;</span><span class="w"> </span>
<span class="err">@</span><span class="k">private</span><span class="w"></span>
<span class="w">    </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">_someInternalData</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
<span class="err">@</span><span class="n">end</span><span class="w"></span>
</pre></div>
<ul>
<li>对象布局在编译期就确定了，所以就硬编码了每个属性在对象内存中的偏移量</li>
<li>所以如果对象布局变化了（比如增加了实例变量），这些偏移量就会出错，必须要重新编译。<ul>
<li>如果链接代码时使用了不同版本的类定义，就会产生这种“不兼容”的问题</li>
</ul>
</li>
<li>OC的解决方案是，把偏移量仍由“实例变量”存储<ul>
<li>但是交由“类对象“(class object)保管</li>
<li>偏移量在运行期查找 -&gt; 类的定义变了，偏移量也就变了（实时的）<ul>
<li>甚至可以在运行期向类中新增实例变量</li>
<li>nonfragile Application Binary Interface(ABI)</li>
<li>这样就可以不止在声明文件里定义实例变量，还可以在class-continuation和实现文件里面定义了</li>
</ul>
</li>
<li>尽量不要直接访问实例变量</li>
</ul>
</li>
<li>使用<code>点语法</code>访问属性<ul>
<li>编译器会转换为对存取方法的调用</li>
<li>编译器会为属性生成相应的实例变量，并自动合成（生成相应的存取方法）<ul>
<li>编译期进行，所以你看不到实际的代码</li>
<li>也可以手写同样的代码（这时你就可以自定义实例方法的签名了）</li>
<li><code>@dynamic</code>能阻止合成 &lt;= 相信运行期能找到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Property Attributes</h3>
<ol>
<li>原子性(<code>Atomicity</code>)，读写的时候加锁</li>
<li>读/写权限</li>
<li>内存管理语义<ul>
<li>assign: on scalar type</li>
<li>strong: 拥有关系，设置新值流程：retain new -&gt; release old -&gt; set new</li>
<li>weak: 非拥有关系</li>
<li>unsafe_unretained: 类似assign，但适用于对象类型（而不只有scalar type)<ul>
<li>与weak的区别在目标对象在销毁时，该属性值不会自动清空</li>
</ul>
</li>
<li>copy: 类似strong，但是相比起retain，它直接是复制了一份，通常用于拥有可变类型的变量，比如<code>NSString *</code>，可变版的string也能赋值给NSString，这就会引起赋值后值还自己变了的可能性</li>
</ul>
</li>
<li>方法名<ul>
<li>getter=<name>，需要注意的是有些bool类型的通常会设置为<code>isXXXX</code></li>
<li>setter=<name>，但很少这么做</li>
</ul>
</li>
</ol>
<p>如果自己来实现accessor methods，那么就要自己去保证这些方法符合这些attributes，比如内存管理语义为copy，那么在设置的时候就要拷贝传入的值：</p><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">EOCPerson</span> : <span class="bp">NSManagedObject</span><span class="w"> </span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">firstName</span><span class="p">;</span><span class="w"></span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">copy</span><span class="p">)</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">lastName</span><span class="p">;</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithFirstName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">firstName</span><span class="w"> </span><span class="nf">lastName:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">lastName</span><span class="p">;</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>

<span class="c1">// 实现文件：</span>
<span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">initWithFirstName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">firstName</span><span class="w"> </span><span class="n">lastName</span><span class="o">:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">lastName</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nb">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">super</span><span class="w"> </span><span class="n">init</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_firstName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">firstName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">_lastName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">lastName</span><span class="w"> </span><span class="k">copy</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">self</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
<blockquote>
<ul>
<li>读写操作的原子性并不是线程安全</li>
<li>iOS中使用同步锁开销较大</li>
<li>实际iOS程序碰到多线程读写属性的场景也非常少</li>
<li>所以基本上都是声明为<code>nonatomic</code></li>
</ul>
</blockquote>
<h2>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h2>
<p>在对象内部优先访问实例变量。</p><p>直接访问而不用点语法的影响：</p><ul>
<li>不经过消息派发，速度快（编译器生成的代码会直接访问相应的内存）</li>
<li>不会调用setter，也绕过了相应的内存管理语义</li>
<li>不会触发KVO</li>
<li>没有机会在getter, setter中设置断点来调试</li>
<li>没有机会<code>lazy intialization</code>，而getter机制能在首次被调用到的时候才去初始化实例变量</li>
<li>初始化和dealloc的时候总是要直接用实例变量</li>
</ul>
<p>作者建议尽量在读取实例变量的时候直接访问，设置的时候用属性（会自动考虑内存管理语义）</p><h2>Item 8: Understand Object Equality</h2>
<p>其实就是理解NSObject自带的<code>isEqual:</code>方法。</p><ul>
<li><code>==</code>就是比指针</li>
<li><code>isEqual:</code>比的是<code>hash</code>，所以自定义的类要实现equality就要自行实现这两个方法<ul>
<li>hash不同必然对象不同，但由于有hash collisions的存在，反过来并不成立</li>
<li>尽量用对象的不可变部分来做hash</li>
</ul>
</li>
</ul>
<p>一个做hash的方法：</p><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_firstName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">_lastName</span><span class="w"> </span><span class="n">hash</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="n">NSUInteger</span><span class="w"> </span><span class="n">ageHash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_age</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">firstNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">lastNameHash</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">ageHash</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>Item 9: Use the Class Cluster Pattern to Hide Implementation Detail</h2>
<div class="highlight"><pre><span></span><span class="p">+</span> <span class="p">(</span><span class="bp">UIButton</span><span class="o">*</span><span class="p">)</span><span class="nf">buttonWithType:</span><span class="p">(</span><span class="n">UIButtonType</span><span class="p">)</span><span class="nv">type</span><span class="p">;</span><span class="w"></span>
</pre></div>
<ul>
<li>作者将上述这种解释为“类族”，即它的返回值可能是各种button，但归根结底，都是<code>UIButton</code>，就是靠着switch各种type来实例化各种子类。</li>
<li>同时，因为OC没有abstract class，为了避免直接使用抽象基类，一般不提供init方法，并在基类相关方法里干脆抛异常</li>
<li>这里使用<code>isMemberOfClass</code>就要小心，它是kind，但不一定是member</li>
<li>系统框架里有很多<code>class cluster</code>，特别是<code>collection</code><ul>
<li>所以<code>if([anArray class] == [NSArray class])</code>是false（原因就是它是被当作“<strong>抽象基类</strong>来设计的，实际上是隐藏在公共接口后面的某个内部类型）</li>
<li>同样，用<code>isKindOfClass:</code>至少能判断是在这个类族里</li>
</ul>
</li>
</ul>
<h2>Item 10: Use Associated Objects to Attach Custom Data to Existing Classes</h2>
<p>扩展现有类，我们可以继承，但有时候一些特殊机制创建的类却无法继承，可以通过<code>Associated Object</code>来添加这些信息。</p><ul>
<li>以键值对来存储，所以是可以存储多个关联数据的</li>
<li>可以指定storage policy，对应内存管理语义</li>
</ul>
<figure  style="flex: 140.1840490797546" ><img width="914" height="326" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/820ae39c34d1147867f1dfb6f1d64de3.png" alt=""/></figure><p>方法:</p><div class="highlight"><pre><span></span><span class="c1">// Sets up an association of object to value with the given key and policy.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">objc_AssociationPolicy</span><span class="w"> </span><span class="n">policy</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Retrieves the value for the association on object with the given key.</span>
<span class="kt">id</span><span class="w"> </span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Removes all associations against object.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span><span class="w"> </span><span class="n">object</span><span class="p">)</span><span class="w"></span>
</pre></div>
<p>书中写了一个例子，alertView的代理方法来处理按了什么键，而一个页面中如果有多个alertView，且用同一个代理对象，那么处理需要更精细（比如需要知道是哪个警告框弹的，我一般用tag）。
而如果把处理方法定义为一个block，并把它关联到UIAlertView类，那么处理逻辑就可以跟定义alertView写在一起了。</p><p>todo, item 11-14</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E3%80%8AEffective-Objective-C-2.0%E3%80%8B%E7%AC%94%E8%AE%B0%E7%AC%AC1-2%E7%AB%A0/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Drawing/" target="_self">Programming iOS 14 - Drawing</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Drawing/" target="_self">
                <time class="text-uppercase">
                    December 25 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第2章</p><hr />
<h1>Drawing</h1>
<p>Many UIView subclasses, such as a UIButton or a UILabel, know how to draw themselves.</p><p>A <em>pure UIView</em> is all about drawing, and it leaves that drawing largely up to you.</p><h2>Images and Image Views</h2>
<p>图片可以来自文件，代码，或网络。</p><h3>Image Files</h3>
<ul>
<li><code>init(named:)</code>，会从<code>Asset catalog</code>和<code>App bundle</code>的顶层去查找<ul>
<li>返回的是一个Optional，因为不能确定这个路径对应一张图片，或能解码成功</li>
<li>它会将图片缓存<ul>
<li><code>init(contentsOfFile:)</code>则不会缓存，但不从asset catalog加载而是相对于<code>Bundle.main</code>来做路径</li>
</ul>
</li>
</ul>
</li>
<li>从bundle里找时不加扩展名会默认为<em>png</em></li>
<li>直接将图片拖到代码生成的不是Optional的image，调用的是<code>init(imageLiteralResourceName:)</code>方法</li>
<li>文件名里的@表示<code>High-resolution variants</code>，即不同分辨率下采用的图片，比如<code>@2x</code></li>
<li>文件名里的~表示<code>Device type variants</code>，即不同设备类型下采用的图片，比如<code>~ipad</code></li>
</ul>
<blockquote>
<p>尽量把图片放到asset catalog里，对不同的处理器，更宽的色域，等等
不光影响运行时，在Apple Store对你的app对特定设备进行<em>thinning</em>都会用到
不同size class, dark mode, ipad等等trait collection都可以设置对应的图片</p></blockquote>
<p><strong>Vector images</strong></p><ul>
<li>An image file in the asset catalog can be a vector-based PDF or (new in Xcode 12) an SVG.</li>
<li><code>init(systemName:)</code> -&gt; <a href="https://developer.apple.com/sf-symbols/">SF Symbols</a><ul>
<li><code>.withConfiguration(_:) or .applyingSymbolConfiguration(_:)</code> 进行自定义，参数是一个<em>UIImage.SymbolConfiguration</em></li>
<li>Configurations can involve one of nine <code>weights</code>, one of three <code>scales</code>, a font or text <code>style</code>, and a <code>point size</code>, in various combinations</li>
</ul>
</li>
</ul>
<p><strong>Asset catalogs and trait collections</strong></p><p>指定trait collection初始化图片：<code>init(named:in:compatibleWith:)</code></p><ul>
<li>A built-in interface object that displays an image, such as a UIImageView, is <code>automatically trait collection–aware</code>;</li>
<li>it receives the <code>traitCollectionDidChange(_:)</code> message and responds accordingly.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">tcreg</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">verticalSizeClass</span><span class="p">:</span> <span class="p">.</span><span class="n">regular</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tccom</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">verticalSizeClass</span><span class="p">:</span> <span class="p">.</span><span class="n">compact</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">moods</span> <span class="p">=</span> <span class="bp">UIImageAsset</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">frowney</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;frowney&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">smiley</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;smiley&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="n">moods</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">frowney</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">tcreg</span><span class="p">)</span>
<span class="n">moods</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="n">smiley</span><span class="p">,</span> <span class="n">with</span><span class="p">:</span> <span class="n">tccom</span><span class="p">)</span>
</pre></div>
<p>由此也可见，你操作的是“一张图片”，其实它是一<strong>组</strong>带了条件的图片。</p><blockquote>
<p>UIColor也是相同的机制，你用<code>resolvedColor(with:)</code>传入trait collection把对应的颜色取出来使用。</p></blockquote>
<p><strong>Namespacing image files</strong></p><ul>
<li>物理文件夹，虚拟文件夹内的图片访问时，都需要加上文件夹名（namespaing)</li>
<li><code>init(named:)</code>的完全形态其实是<code>init(named:in:)</code>，第二个参数是bundle，比如来自某个framework.</li>
</ul>
<h3>Image Views</h3>
<p>A UIImageView can actually have two images, one assigned to its <code>image</code> property and the other assigned to its <code>highlightedImage</code> property
A UIImageView without an image and without a background color is <em>invisible</em></p><p><strong>Resizable Images</strong></p><p>用inset来设置<strong>不</strong>拉伸的区域，比如一般我们碰到的多为左右随便拉伸的胶囊按钮，需要设计师做的就是左右两个半圆（不拉伸）和中间1像素的可拉伸部分</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">marsTiled</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">resizableImage</span><span class="p">(</span><span class="n">withCapInsets</span><span class="p">:</span>
<span class="n">UIEdgeInsets</span><span class="p">(</span>
    <span class="n">top</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kr">left</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">bottom</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kr">right</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">),</span> <span class="n">resizingMode</span><span class="p">:</span> <span class="p">.</span><span class="n">stretch</span><span class="p">)</span>
</pre></div>
<p>所以如果只是横向拉伸，上面的代码中，top, bottom都可以设为0，或都设为图片高度（而不去除2什么的），只需要保证把UI控件的高度保持跟图片一致即可。</p><p>那么，如果不小心高度大于图片高度了呢？分两种情况，如果设了0，表示没有保留区域，直接竖向拉伸，而如果设成了图片高度，那么表示整个Y方向没有可供拉伸的像素，必然造成拉伸失败：</p><figure  style="flex: 123.51598173515981" ><img width="1082" height="438" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/be32f2993735b82ac7da004327cf4bad.png" alt=""/></figure><p><strong>Transparency Masks</strong></p><p>The image shown on the screen is formed by combining the image’s <code>transparency</code> values with a single <code>tint color</code>.</p><p>忽略图片各像素上颜色的数值，只保留透明度，就成了一个mask. (renderingMode: <code>alwaysTemplate</code>)</p><ul>
<li>iOS gives every UIView a <code>tintColor</code>, which will be used to <code>tint any template images</code>。所以我们经常用的tintColor其实就是给模板图片染色的意思。</li>
<li>tintColor是向下继承的</li>
<li>The symbol images are always template images</li>
<li>iOS 13起，可以对UIImage直接应用tint color</li>
</ul>
<p><strong>Reversible Images</strong></p><ul>
<li>用<code>imageFlippedForRightToLeftLayoutDirection</code>来创建一个在从右向左的书写系统里会自动翻转的图片。<ul>
<li>但你又可以设置<code>semanticContentAttribute</code>来阻止这个镜像行为</li>
</ul>
</li>
<li>如果不考虑书写系统，可以用<code>withHorizontallyFlippedOrientation</code>强行镜像</li>
</ul>
<h2>Graphics Contexts</h2>
<p>Graphics Contexts是绘图的起点，你能从如下方式得到Graphics Contexts：</p><ol>
<li>进入UIView的 <code>draw(_:)</code>方法时，系统会给你提供一个Graphics Contexts</li>
<li>CALayer的<code>draw(in:)</code>,或其代理的<code>draw(_:in:)</code>方法，<em>in</em>参数就是Graphics Contexts<ul>
<li>但它不是<code>currnet context</code></li>
</ul>
</li>
<li>手动创建一个</li>
</ol>
<p>UIKit 和 Core Graphics是两套绘制工具。</p><ul>
<li>UIKit是大多数情况下你的选择，大部分Cocoa class知道如何绘制自己</li>
<li>只能在current context上绘制</li>
<li>Core Graphics is the full drawing API， often referred to as <code>Quartz (2D)</code></li>
<li>UIKit drawing is built on top of it.</li>
</ul>
<p>两套体系，三种context来源，共计6种殊途同归的方式。</p><h3>Drawing on Demand</h3>
<p>直接上代码：</p><div class="highlight"><pre><span></span><span class="c1">// UIView</span>

<span class="c1">// UIKit</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接绘制</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CG</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 取到context</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CALayer</span>

<span class="c1">// UIKit</span>
 <span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">layer</span><span class="p">:</span> <span class="bp">CALayer</span><span class="p">,</span> <span class="k">in</span> <span class="n">con</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
    <span class="n">UIGraphicsPopContext</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// CG</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">layer</span><span class="p">:</span> <span class="bp">CALayer</span><span class="p">,</span> <span class="k">in</span> <span class="n">con</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<h3>Drawing a UIImage</h3>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span><span class="n">ovalIn</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// im is the blue circle image, do something with it here ...</span>
<span class="n">And</span> <span class="n">here</span><span class="err">’</span><span class="n">s</span> <span class="n">the</span> <span class="n">same</span> <span class="n">thing</span> <span class="n">using</span> <span class="n">Core</span> <span class="n">Graphics</span><span class="p">:</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">addEllipse</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// im is the blue circle image, do something with it here ...</span>
</pre></div>
<h2>UIImage Drawing</h2>
<p>用已有的图像进行绘制：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">mars</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Mars&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">sz</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
    <span class="n">format</span><span class="p">:</span><span class="n">mars</span><span class="p">.</span><span class="n">imageRendererFormat</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="n">mars</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">mars</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>这里，绘制了两个火星，注意<code>imageRendererFormat</code>的使用</p><h2>CGImage Drawing</h2>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">mars</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Mars&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="c1">// extract each half as CGImage</span>
<span class="kd">let</span> <span class="nv">marsCG</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">cgImage</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">sz</span> <span class="p">=</span> <span class="n">mars</span><span class="p">.</span><span class="n">size</span>
<span class="kd">let</span> <span class="nv">marsLeft</span> <span class="p">=</span> <span class="n">marsCG</span><span class="p">.</span><span class="n">cropping</span><span class="p">(</span><span class="n">to</span><span class="p">:</span>
    <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">marsRight</span> <span class="p">=</span> <span class="n">marsCG</span><span class="p">.</span><span class="n">cropping</span><span class="p">(</span><span class="n">to</span><span class="p">:</span>
    <span class="n">CGRect</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">CGSize</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
    <span class="n">format</span><span class="p">:</span><span class="n">mars</span><span class="p">.</span><span class="n">imageRendererFormat</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="n">ctx</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span>
    <span class="n">con</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span>
        <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">marsRight</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span>
        <span class="n">CGRect</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
<p>当然, <code>con.draw</code>可以由UIImage来完成：</p><div class="highlight"><pre><span></span><span class="bp">UIImage</span><span class="p">(</span><span class="n">cgImage</span><span class="p">:</span> <span class="n">marsLeft</span><span class="p">!,</span>
<span class="n">scale</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">scale</span><span class="p">,</span>
<span class="n">orientation</span><span class="p">:</span> <span class="n">mars</span><span class="p">.</span><span class="n">imageOrientation</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
<h2>Snapshots</h2>
<ul>
<li><code>drawHierarchy(in:afterScreenUpdates:)</code>将整个视图存成一张图片。</li>
<li>更快，语义更好的方法：<code>.snapshotView(afterScreenUpdates:)</code> -&gt; 输出是UIView，不是UIImage</li>
<li><code>resizableSnapshotView(from:after- ScreenUpdates:withCapInsets:)</code>生成可缩放的</li>
</ul>
<h2>Core Image</h2>
<p>The “CI” in <code>CIFilter</code> and <code>CIImage</code> stands for <code>Core Image</code>, a technology for transforming images through <em>mathematical</em> filters. (iOS 5起，从macOS引入)</p><p>用途：</p><ul>
<li>patterns and gradients (可以被别的filter一起使用)</li>
<li>compositing (使用composting blend modes)</li>
<li>color (颜色调整，亮度锐度色温等等)</li>
<li>geometric (几何相关的就是用来变形)</li>
<li>transformation (distort, blur, stylize an image)</li>
<li>transition (一般用于动画，通过设置frame序列)</li>
</ul>
<p>There are more than 200 available <code>CIFilters</code>， A CIFilter is a set of <strong>instructions</strong> for <code>generating</code> a CIImage</p><ul>
<li>基本上，处理的都是<code>CIImage</code>(input)</li>
<li>输出也是<code>CIImage</code>，或者另一个<code>filter</code> -&gt; 链式调用<ul>
<li>最后一层链可以自行转换为bitmap: cg或ui image(by <code>rendering</code>方法)</li>
<li>rendering的时候，所有的数学计算才开始发生</li>
<li>因为只是<strong>instructions</strong></li>
</ul>
</li>
<li><strong>关键词</strong>：filter是用来描述怎么<strong>生成</strong>CIImage的</li>
<li><code>CGImage</code>和<code>UIImage</code>都能得到CIImage</li>
</ul>
<blockquote>
<p>UIImage只有在已经wraps了一个<code>CIImage</code>的情况下<code>.ciImage</code>才有值，而大多数情况下是没有的。</p></blockquote>
<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html">Core Image Filter Reference</a>里有所有的filter的名字，用来初始化一个filter</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">filter</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;CICheckerboardGenerator&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="c1">// or:</span>
<span class="kd">let</span> <span class="nv">filter</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">checkerboardGenerator</span><span class="p">()</span>

<span class="c1">// 用key-value来决定行为：</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="s">&quot;inputWidth&quot;</span><span class="p">)</span>
<span class="c1">// or:</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">width</span> <span class="p">=</span> <span class="mi">30</span>
<span class="c1">// or init with params</span>
<span class="kd">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="n">parameters</span><span class="p">:)</span>

<span class="c1">// apply filter on CIImage(if exists one)</span>
<span class="n">ciimage</span><span class="p">.</span><span class="n">applyingFilter</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span><span class="n">parameters</span><span class="p">:)</span>
<span class="c1">// or output a ciimage</span>
<span class="bp">filter</span><span class="p">.</span><span class="n">outputImage</span>
</pre></div>
<p><strong>Render a CIImage</strong>
CIImage 不是一个<code>displayaable image</code></p><ul>
<li><code>CIContext</code>.init(options:).createCGImage(_:from)<ul>
<li>参数1是CIImage，</li>
<li>参数2是绘制区域（所以没有frame/bounds)，叫<code>extent</code></li>
<li>这是很昂贵的操作，建议在全app生命周期保留这个context复用</li>
</ul>
</li>
<li><code>UIImage</code>.init(ciImage:)</li>
<li>把上一次的uiimage设置成<code>UIImageView</code>的image，也能造成CIImage的渲染。</li>
</ul>
<p>以上说的都是&quot;render&quot; CIImage的时机，所以传入的</p><blockquote>
<p><code>Metal</code>能快速渲染CIImage</p></blockquote>
<p>串起一个demo:</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">moi</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span><span class="s">&quot;Moi&quot;</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">moici</span> <span class="p">=</span> <span class="bp">CIImage</span><span class="p">(</span><span class="n">image</span><span class="p">:</span><span class="n">moi</span><span class="p">)</span><span class="o">!</span>
<span class="kd">let</span> <span class="nv">moiextent</span> <span class="p">=</span> <span class="n">moici</span><span class="p">.</span><span class="n">extent</span>
<span class="kd">let</span> <span class="nv">smaller</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">moiextent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">larger</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">moiextent</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// first filter</span>
<span class="kd">let</span> <span class="nv">grad</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">radialGradient</span><span class="p">()</span>
<span class="n">grad</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">moiextent</span><span class="p">.</span><span class="n">center</span>
<span class="n">grad</span><span class="p">.</span><span class="n">radius0</span> <span class="p">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">smaller</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="mf">0.7</span>
<span class="n">grad</span><span class="p">.</span><span class="n">radius1</span> <span class="p">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">larger</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
<span class="kd">let</span> <span class="nv">gradimage</span> <span class="p">=</span> <span class="n">grad</span><span class="p">.</span><span class="n">outputImage</span><span class="p">!</span>
<span class="c1">// 到此步为止，并没有moi这个图片参与，等于是一个纯filter</span>

<span class="c1">// second filter</span>
<span class="kd">let</span> <span class="nv">blend</span> <span class="p">=</span> <span class="bp">CIFilter</span><span class="p">.</span><span class="n">blendWithMask</span><span class="p">()</span>
<span class="n">blend</span><span class="p">.</span><span class="n">inputImage</span> <span class="p">=</span> <span class="n">moici</span>  <span class="c1">// 设置了image</span>
<span class="n">blend</span><span class="p">.</span><span class="n">maskImage</span> <span class="p">=</span> <span class="n">gradimage</span> <span class="c1">// 这里演示的是mask filter，按我理解并不是链式的，而且语法上也不是链式的，而是赋值给了maskImage，但书里直接说是链式的</span>
<span class="kd">let</span> <span class="nv">blendimage</span> <span class="p">=</span> <span class="n">blend</span><span class="p">.</span><span class="n">outputImage</span><span class="p">!</span>

<span class="c1">// 两种render方法</span>
<span class="c1">// content</span>
<span class="kd">let</span> <span class="nv">moicg</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">createCGImage</span><span class="p">(</span><span class="n">blendimage</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">moiextent</span><span class="p">)</span><span class="o">!</span> <span class="c1">// *</span>
<span class="kc">self</span><span class="p">.</span><span class="n">iv</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">cgImage</span><span class="p">:</span> <span class="n">moicg</span><span class="p">)</span>

<span class="c1">// UIImage</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">moiextent</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
<span class="kc">self</span><span class="p">.</span><span class="n">iv</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">UIImage</span><span class="p">(</span><span class="n">ciImage</span><span class="p">:</span> <span class="n">blendimage</span><span class="p">).</span><span class="n">draw</span><span class="p">(</span><span class="k">in</span><span class="p">:</span><span class="n">moiextent</span><span class="p">)</span> <span class="c1">// *</span>
<span class="p">}</span>
</pre></div>
<blockquote>
<p>关于上述代码里我的疑惑，第一个filter并不是chain到第二个filter里的，但书里说是<code>obtain the final CIImage in the chain (blendimage)，看来所谓的chain，并不是fitler的chain，而是</code>outputImage`的chain?
问题是，这是唯一且标准的filter嵌套用法么？-&gt; mask</p></blockquote>
<p>不是的</p><ol>
<li>对filter的outputImage继续应用<code>aplyingFilter(_:parameters)</code>来链式应用一个新的filter<ul>
<li>返回值是CIImage，不再是filter</li>
<li>所以如果继续chain，直接用返回值调apply...方法即可</li>
</ul>
</li>
<li>把上一个filter的outputImage设为下一个filter的inputImage:</li>
</ol>
<div class="highlight"><pre><span></span><span class="bp">CIFilter</span><span class="w"> </span><span class="o">*</span><span class="n">gloom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CIFilter</span><span class="w"> </span><span class="n">filterWithName</span><span class="o">:</span><span class="s">@&quot;CIGloom&quot;</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setDefaults</span><span class="p">];</span><span class="w">                                        </span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputImageKey</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@25.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputRadiusKey</span><span class="p">];</span><span class="w">         </span>
<span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@0.75f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputIntensityKey</span><span class="p">];</span><span class="w">      </span>
<span class="c1">// 即outputImage</span>
<span class="bp">CIImage</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">gloom</span><span class="w"> </span><span class="n">valueForKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIOutputImageKey</span><span class="p">];</span><span class="w">   </span>

<span class="bp">CIFilter</span><span class="w"> </span><span class="o">*</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">CIFilter</span><span class="w"> </span><span class="n">filterWithName</span><span class="o">:</span><span class="s">@&quot;CIBumpDistortion&quot;</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setDefaults</span><span class="p">];</span><span class="w">                                              </span>
<span class="c1">// 设置inputImage (with first filter&#39;s output image) </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputImageKey</span><span class="p">];</span><span class="w"></span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="bp">CIVector</span><span class="w"> </span><span class="n">vectorWithX</span><span class="o">:</span><span class="mi">200</span><span class="w"> </span><span class="n">Y</span><span class="o">:</span><span class="mi">150</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="nl">forKey</span><span class="p">:</span><span class="w"> </span><span class="n">kCIInputCenterKey</span><span class="p">];</span><span class="w">                              </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@100.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputRadiusKey</span><span class="p">];</span><span class="w">                </span>
<span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">setValue</span><span class="o">:</span><span class="w"> </span><span class="mf">@3.0f</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIInputScaleKey</span><span class="p">];</span><span class="w">                   </span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">bumpDistortion</span><span class="w"> </span><span class="n">valueForKey</span><span class="o">:</span><span class="w"> </span><span class="n">kCIOutputImageKey</span><span class="p">];</span><span class="w"></span>
</pre></div>
<blockquote>
<p>CIImage能认出EXIF里关于旋转方向的参数，并以正确的方向展示</p></blockquote>
<h2>Blur and Vibrancy Views</h2>
<p>毛玻璃效果，用<code>UIVisualEffectView</code>，这是个抽像类，实际用这两个：<code>UIVisualEffectView</code>和<code>UIVibrancyEffect</code>。</p><p>什么是<code>UIVibrancyEffect</code>?</p><blockquote>
<p>An object that amplifies and adjusts the color of the content layered <code>behind</code> a visual effect view.</p></blockquote>
<p>关键词是<code>behind</code>，即它是配合别的视效一起用的（比如毛玻璃）。文字被毛玻璃覆盖后的效果，并不是由毛玻璃层来确定的，而是由vibrancy effect自定义的。</p><p>总的来说</p><ul>
<li>用effect初始化effect view, effect就是五种<code>material</code></li>
<li>这个view可以当成常规view来定位，布局，添加到subview里，等等</li>
<li>用上一个effect初始化一个vibrancy effect（with style)</li>
<li>用vibrance effect初始化一个view</li>
<li>创建UI控件</li>
<li>让vibView的bounds等于内容的bounds（等于只对内容所有的范围内应用特效），并定位</li>
<li>vibView添加到effectView的contentView的subView里去</li>
<li>需要被vibrancy的内容（比如一个label)，则添加到vibView.contentView.addSubview(label)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">blurEffect</span> <span class="p">=</span> <span class="bp">UIBlurEffect</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="p">.</span><span class="n">systemThinMaterial</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">blurView</span> <span class="p">=</span> <span class="bp">UIVisualEffectView</span><span class="p">(</span><span class="n">effect</span><span class="p">:</span> <span class="n">blurEffect</span><span class="p">)</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">frame</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleWidth</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleHeight</span><span class="p">]</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">blurView</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">vibEffect</span> <span class="p">=</span> <span class="bp">UIVibrancyEffect</span><span class="p">(</span>
    <span class="n">blurEffect</span><span class="p">:</span> <span class="n">blurEffect</span><span class="p">,</span> <span class="n">style</span><span class="p">:</span> <span class="p">.</span><span class="n">label</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">vibView</span> <span class="p">=</span> <span class="bp">UIVisualEffectView</span><span class="p">(</span><span class="n">effect</span><span class="p">:</span><span class="n">vibEffect</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lab</span> <span class="p">=</span> <span class="bp">UILabel</span><span class="p">()</span>
<span class="n">lab</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello, world&quot;</span>
<span class="n">lab</span><span class="p">.</span><span class="n">sizeToFit</span><span class="p">()</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">bounds</span> <span class="p">=</span> <span class="n">lab</span><span class="p">.</span><span class="n">bounds</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span>
    <span class="p">[.</span><span class="n">flexibleTopMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleBottomMargin</span><span class="p">,</span>
    <span class="p">.</span><span class="n">flexibleLeftMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleRightMargin</span><span class="p">]</span>
<span class="n">blurView</span><span class="p">.</span><span class="n">contentView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">vibView</span><span class="p">)</span>
<span class="n">vibView</span><span class="p">.</span><span class="n">contentView</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
</pre></div>
<h2>Drawing a UIView</h2>
<p>UIView本身就提供了一个<code>graphics context</code>，在这个context里进行的绘制会直接显示在view里。</p><ul>
<li>subclass UIView's <code>.draw(_:)</code>method<ul>
<li>直到需要时才会被调用</li>
<li>或<code>setNeedsDisplay</code>会调用</li>
<li>一量被draw，就缓存起来了 (<code>bitmap backing store</code>)</li>
</ul>
</li>
<li>实时绘制会吓到一些初学者，绘制是<code>time-comsuming operation</code></li>
</ul>
<p>推荐在<code>draw</code>方法里实时绘制</p><blockquote>
<p>In fact, moving code to draw(_: ) is commonly a way to increase efficiency. This is because it is more efficient for the drawing engine to <em>render directly onto the screen</em> than for it to <em>render offscreen</em> and then copy those pixels onto the screen.</p></blockquote>
<p>几个注意点：</p><ol>
<li>不要手动调用draw方法，<code>setNeedsDisplay</code>会让系统决定下一个合适的时机来draw</li>
<li>不要重载draw方法，比如你无法合并UIImageView的drawing</li>
<li>不要在draw里做任何与绘制无关的事，配置（如背景色，添加子view/layer）项应该在别的地方做，比如<code>layoutSubviews</code></li>
<li>第二个参数是一个rect，默认是view的bounds<ul>
<li>如果你用<code>setNeesDisplay(_:)</code>送入了自定义的CGRect，draw里面的rect也就成了这个，如果你不在这个rect里画（而是在整个view的rect里），超出部分会被clip掉</li>
<li>这也是为了效率，显示提供绘制的区域</li>
</ul>
</li>
<li>手写draw绘制出来的view会有黑色的底色，如果你没有设计背景色，以及<code>isOpaque == true</code>时（<code>UIView.init(frame:)</code>出来的view恰好满足这两个条件， nib里拖出来的则是nil的背景，反而没这问题）<ul>
<li>解决：实现<code>init(frame:)</code>，去设置*isOpaque`为false</li>
</ul>
</li>
</ol>
<h2>Graphics Context Commands</h2>
<blockquote>
<p>Under the hood, Core Graphics commands to a <code>graphics context</code> are global C functions with names like CGContextSetFillColor，但是swift的封装让调用更简单（语法糖）</p></blockquote>
<p>当你在graphics context里绘制时，取的就是当前的设置，因此在任何绘制前，第一步都是先配置context's setting，比如你要画一根红线，再画一根蓝线</p><ol>
<li>设置context line color red, then draw a line</li>
<li>设置context line color blue, then draw a line</li>
</ol>
<p>直觉认为红和蓝只是两条线各自的属性，其实是你绘制<strong>当时</strong>，整个graphics context的设置</p><ul>
<li>这些配置通通存成一个state</li>
<li>这些state又会stack起来<ul>
<li>saveGState将当前state推到栈顶</li>
<li>restoreGstate则将state从栈顶取出，覆盖当前设置</li>
</ul>
</li>
<li>只要先后配置没有冲突的项，就没必要频繁save-restore</li>
</ul>
<h3>Paths and Shapes</h3>
<ul>
<li><p>通过一系列的描述去移动一去想象中的笔，就是构建<code>path</code>的过程。（注意，不是构建<code>CGPath</code>这个封装的过程）</p><ul>
<li>即只要你在context内，就可以用笔画东西了</li>
</ul>
</li>
<li><p>只要你正确地使用<code>move(to:)</code>方法，就不需要像apple文档里动不动就用<code>beginPath</code>来设置新的path的起点</p></li>
<li><p><code>fillPath</code>会自动<code>closePaht</code></p></li>
<li><p>先提供path，再draw，draw的意思要么是stroke，要么是fill，要么是both（<code>drawPath</code>方法），但不能一步步来，因为draw完你的path就空了</p><ul>
<li>衔接第一条，如果你想复用这个path，才需要用<code>CGPath</code>封装起来</li>
</ul>
</li>
<li><p>如果是使用UIKit封装的语法，那么起点就是一个path <code>let path = UIBezierPath()</code></p></li>
<li><p>那么每次draw完，要在别的位置“落笔”的话，要先清一下靠前的path: <code>path.removeAllPoints()</code></p></li>
</ul>
<h3>Clipping</h3>
<ul>
<li>clipping掉的区域就不能被绘制了</li>
<li>通常你无法得知一个graphics context的大小，但是通过<code>boundingBoxOfClipPath</code>却能拿到整个bounding</li>
</ul>
<p>这一节做了几个实验，单独写到了<a href="https://www.jianshu.com/p/ade133568ac0">另一篇博文</a></p><blockquote>
<p>前面说过，没有背景色+isOpaque会导致背景变黑，在draw里面，默认的颜色也是黑色，所以你不带任何设置的绘制你是看不到任何东西的（就是黑笔在黑纸上画）</p></blockquote>
<h3>Gradients</h3>
<p>gradient不能用作path的fill，但可以反过来让gradient沿着path分布，以及被clip等。</p><p>在上面应用clip绘制箭尾的例子里，我们把箭柄变成从左到右是灰-黑-灰的渐变，只需要在<code>addLine</code>并设置了line的宽度后(不要设颜色了），不是去<code>strokePath()</code>，而是：</p><div class="highlight"><pre><span></span><span class="n">con</span><span class="p">.</span><span class="n">replacePathWithStrokedPath</span><span class="p">()</span>  <span class="c1">// 不再strokePath</span>
<span class="n">con</span><span class="p">.</span><span class="n">clip</span><span class="p">()</span>                        <span class="c1">// 再clip一次，奇偶反转</span>
<span class="c1">// draw the gradient</span>
<span class="kd">let</span> <span class="nv">locs</span> <span class="p">:</span> <span class="p">[</span><span class="n">CGFloat</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">]</span>
<span class="kd">let</span> <span class="nv">colors</span> <span class="p">:</span> <span class="p">[</span><span class="n">CGFloat</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span>
        <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// starting color, transparent light gray</span>
        <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="c1">// intermediate color, darker less transparent gray</span>
        <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="c1">// ending color, transparent light gray</span>
    <span class="p">]</span>
<span class="kd">let</span> <span class="nv">sp</span> <span class="p">=</span> <span class="n">CGColorSpaceCreateDeviceGray</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">grad</span> <span class="p">=</span> <span class="n">CGGradient</span><span class="p">(</span>
    <span class="n">colorSpace</span><span class="p">:</span><span class="n">sp</span><span class="p">,</span> <span class="n">colorComponents</span><span class="p">:</span> <span class="n">colors</span><span class="p">,</span> <span class="n">locations</span><span class="p">:</span> <span class="n">locs</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span><span class="o">!</span>
<span class="n">con</span><span class="p">.</span><span class="n">drawLinearGradient</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">end</span><span class="p">:</span> <span class="n">CGPoint</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">options</span><span class="p">:[])</span>
<span class="n">con</span><span class="p">.</span><span class="n">resetClip</span><span class="p">()</span> <span class="c1">// done clipping</span>
</pre></div>
<p>小技巧就是用<code>replacePathWithStrokedPath</code>假装进行了描边（所以只需要线宽并不需要线的颜色），返回了一个新的path，一条粗线变成了一个矩形框。<br />
而一旦添加了这个框，前面的奇偶关系就全反过来了，于是我们再<code>clip</code>一次，这就是头两行代码里做的事。</p><h3>Colors and Patterns</h3>
<p>当你的suer interface sytle changes(比如黑暗模式切换), <code>draw(_:)</code>方法会被立刻调用，被设置<code>UITraitCollection.current</code>，任何支持动态颜色的<code>UIColor</code>能变成相应的颜色，但是<code>CGColor</code>不能，你需要手动触发重绘。</p><p>UIKit使用pattern非常简单，把纹理绘制到图片上，然后从纹理图片提取出颜色信息，就能像别的颜色一样<code>setFill</code>了：</p><div class="highlight"><pre><span></span><span class="c1">// create the pattern image tile</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="bp">UIGraphicsImageRenderer</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">stripes</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">image</span> <span class="p">{</span> <span class="n">ctx</span> <span class="k">in</span>
    <span class="kd">let</span> <span class="nv">imcon</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">cgContext</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">imcon</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// paint the point of the arrow with it</span>
<span class="kd">let</span> <span class="nv">stripesPattern</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">patternImage</span><span class="p">:</span><span class="n">stripes</span><span class="p">)</span>
<span class="n">stripesPattern</span><span class="p">.</span><span class="n">setFill</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>
</pre></div>
<p>而Core Graphics则要复杂（也更底层）得多，结合注释看代码：</p><div class="highlight"><pre><span></span><span class="n">con</span><span class="p">.</span><span class="n">saveGState</span><span class="p">()</span>
<span class="c1">// 非常重要，设置颜色空间</span>
<span class="kd">let</span> <span class="nv">sp2</span> <span class="p">=</span> <span class="n">CGColorSpace</span><span class="p">(</span><span class="n">patternBaseSpace</span><span class="p">:</span><span class="kc">nil</span><span class="p">)</span><span class="o">!</span>
<span class="n">con</span><span class="p">.</span><span class="n">setFillColorSpace</span><span class="p">(</span><span class="n">sp2</span><span class="p">)</span>
<span class="c1">// 纹理绘制真正发生的地方</span>
<span class="kd">let</span> <span class="nv">drawStripes</span> <span class="p">:</span> <span class="n">CGPatternDrawPatternCallback</span> <span class="p">=</span> <span class="p">{</span> <span class="kc">_</span><span class="p">,</span> <span class="n">con</span> <span class="k">in</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
    <span class="n">con</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">// 包装成一个callback给CGPattern使用</span>
<span class="kd">var</span> <span class="nv">callbacks</span> <span class="p">=</span> <span class="bp">CGPatternCallbacks</span><span class="p">(</span>
    <span class="n">version</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">drawPattern</span><span class="p">:</span> <span class="n">drawStripes</span><span class="p">,</span> <span class="n">releaseInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// 一个struct</span>

<span class="c1">// 核心就是构造这个CGPattern</span>
<span class="kd">let</span> <span class="nv">patt</span> <span class="p">=</span> <span class="n">CGPattern</span><span class="p">(</span><span class="n">info</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>  <span class="c1">// cell大小</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="p">.</span><span class="n">identity</span><span class="p">,</span>    <span class="c1">// cell变换，这里没有，就用.identity</span>
    <span class="n">xStep</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">yStep</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>   <span class="c1">// 横向纵向复制cell时的步长</span>
    <span class="n">tiling</span><span class="p">:</span> <span class="p">.</span><span class="n">constantSpacingMinimalDistortion</span><span class="p">,</span>  <span class="c1">// 排列方式</span>
    <span class="n">isColored</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>      <span class="c1">// 是颜色还是画笔模式，选颜色true</span>
    <span class="n">callbacks</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">callbacks</span><span class="p">)</span><span class="o">!</span>  <span class="c1">// 纹理绘制的方法包在callback里面，传指针</span>
<span class="kd">var</span> <span class="nv">alph</span> <span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mf">1.0</span>
<span class="n">con</span><span class="p">.</span><span class="n">setFillPattern</span><span class="p">(</span><span class="n">patt</span><span class="p">,</span> <span class="n">colorComponents</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">alph</span><span class="p">)</span>
<span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
<span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
<span class="n">con</span><span class="p">.</span><span class="n">restoreGState</span><span class="p">()</span>
</pre></div>
<h3>Graphics Context Transforms</h3>
<p>跟前面的知识点一样，应用<em>Graphics Context Transforms</em>后，也不会影响当前已经绘制的东西。 =&gt; <code>CTM</code>即（<code>current transform matrix</code>)。</p><p>旋转的中心点是原点，大多数情况下不是你想要的，记得先translate一下。</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
    <span class="n">con</span><span class="p">.</span><span class="n">setShadow</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span> <span class="n">CGSize</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">blur</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">// 顺便演示下sahdow</span>
    <span class="n">con</span><span class="p">.</span><span class="n">beginTransparencyLayer</span><span class="p">(</span><span class="n">auxiliaryInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>  <span class="c1">// 这样重叠的阴影不会叠成黑色</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">arrow</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">3</span> <span class="p">{</span>
        <span class="n">con</span><span class="p">.</span><span class="n">translateBy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">translateBy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">arrow</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">at</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// 注意这里是用前面方法生成的箭头图片来draw到指定位置</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<figure  style="flex: 77.47747747747748" ><img width="688" height="444" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/0059ea4156dffb9df15e77df8a87f971.png" alt=""/></figure><p>注意，语法虽然是先处理context，再绘制，其实只是告知坐标系的变化，绘制的时候自动应用这些变换。</p><h3>Erasing</h3>
<p><code>clear(_:)</code>擦除行为取决于context是透明还是实心的（透明擦成透明，实心擦成黑色），只要不是opaque，通通理解为透明，比如background color是nil, 或0.9999的透明度。</p><h2>Points and Pixels</h2>
<p><code>con.fill(CGRect(100,0,1.0/self.contentScaleFactor,100))</code>应用contentScaleFactor画一条在任何屏幕上都锐利的1像素直线。</p><h2>Content Mode</h2>
<p>the drawing system will <code>avoid</code> asking a view to <code>redraw</code> itself from scratch if possible; instead, it will use the <code>cached</code> result of the previous drawing operation (the <strong>bitmap backing store</strong>).</p><p>If the view is resized, the system may simply stretch or shrink or reposition the cached drawing, if your contentMode setting instructs it to do so.</p><p><code>draw(_:)</code>从原点开始绘制，所以你的<code>contentMode</code>也要相应设置为<code>topLeft</code>。而如果设置为<code>.redraw</code>，则不会使用cached content，每当view被resize的时候，就会调用<code>setNeedsDisplay</code>方法，最终触发<code>draw(_:)</code>进行重绘。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Drawing/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/View/" target="_self">Programming iOS 14 - View</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/View/" target="_self">
                <time class="text-uppercase">
                    December 22 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第1章</p><hr />
<h1>View</h1>
<ul>
<li>A view knows how to draw itself into a rectangular area of the interface.</li>
<li>A view is also a responder</li>
<li>init:<ul>
<li><code>init(frame:)</code>: init from code</li>
<li><code>init(coder:)</code>: init from nib</li>
</ul>
</li>
</ul>
<h2>Window and Root View</h2>
<ul>
<li>Window = top view, ultimate superview<ul>
<li>iPad with iOS 13+ can have multiple window</li>
</ul>
</li>
<li>only one subview: rootViewController's <code>main view</code> -&gt; occupy the entirety of the window</li>
</ul>
<h2>How an App Launches</h2>
<ul>
<li>Swift项目自动调用了<code>UIApplicationMain</code>方法，唯一方法，初始化了必要资源</li>
<li>初始化<code>UIApplicationMain</code>（你<code>UIApplication.shared</code>的来源），及其degate class(<code>@UIApplicationMain</code>)，并持有，贯穿app整个生命周期</li>
<li>UIApplicationMain calls the app delegate’s <code>application(_:didFinish- LaunchingWithOptions:)</code>, giving your code an opportunity run.</li>
<li>UIApplicationMain creates a <code>UISceneSession</code>, a <code>UIWindowScene</code>, and an instance that will serve as the window scene’s <code>delegate</code>.<ul>
<li>delegate由<em>plist.info / Application Scene Manifest / Delegate Class Name</em> 决定 (<code>$(PRODUCT_MODULE_NAME).SceneDelegate</code>)</li>
</ul>
</li>
<li>初始化root view<ul>
<li>UIApplicationMain根据plist判断是否使用了storyboard<ul>
<li>初始化UIWindow，并赋给scene delegate's <code>window</code> property</li>
<li>初始化initial view controller 并赋给window的<code>rootViewController</code>属性</li>
<li>UIAplicationMain call window's <code>makeKeyAndVisible</code>呈现Interface</li>
</ul>
</li>
<li>call scene delegate's <code>scene(_:willConnectTo:options:)</code><ul>
<li>这里也是没用storyboard的话，手动去实现上面几步的地方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Referring to the Windows</strong></p><ul>
<li><code>view.window</code>, if it's nil means it can't be visible to the user</li>
<li>scene delegate's <code>window</code> property</li>
<li><code>UIApplication.shared.windows.first!</code></li>
</ul>
<blockquote>
<p>Do not expect that the window you know about is the app’s only window. The runtime can create <code>additional mysterious windows</code>, such as the <code>UITextEffectsWindow</code> and the <code>UIRemoteKeyboardWindow</code>.</p></blockquote>
<h2>Subview and Superview</h2>
<p><strong>曾经</strong>，一个view拥有它对应的一个矩形区域，不属于它的subview的其它view在这个矩形内是看不见的，因为重绘矩形的时候是不会考虑到其它view的。同样，也不能draw到矩形区域外去。</p><p>OS X10.5起，苹果更新了关于View的架构，iOS也跟着改变了，subview能出现在superview之外（所以反而需要<code>clipping</code>了），一个view也能overlap到另一个view上而无需成为其subview（后来居上）。</p><p>结果就是，你现在看到几个互相重叠的我色块，你再也分辨不出view之间的层次关系了。（<code>isDescendant(of:)</code>可以检查层次关系）</p><p>没有清空subview的方法，所以：<code>myView.subviews.forEach {$0.removeFromSuperview()}</code></p><h2>Color</h2>
<ul>
<li>background color不设置表示这个view是透明的</li>
<li>如果再没有进行任何子view的绘制，那么这个view就看不见了</li>
<li>这种view可以作为容器来使用</li>
</ul>
<p>iOS 13起，引入黑暗模式后，硬编码的颜色就迎来了很大的问题。</p><ul>
<li>纠结的解决方法：</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span> <span class="p">{</span> <span class="n">tc</span> <span class="k">in</span>
        <span class="k">switch</span> <span class="n">tc</span><span class="p">.</span><span class="n">userInterfaceStyle</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">dark</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>其中, tc是<code>trait collection</code>，一系列特征的集合。</p><ul>
<li>而iOS 13起多了很多<code>.system</code>开头的color，可以自适应</li>
<li><em>asset catalog</em>中可以自定义颜色，并设置不同模式下的颜色</li>
</ul>
<h2>Visibility and Opacity</h2>
<p>隐藏一个view:</p><ul>
<li><code>isHidden</code>: view还在，但不会接受触摸事件<ul>
<li><code>alpha = 0</code>也会使得<code>isHidden == true</code></li>
</ul>
</li>
<li><code>isOpaque</code>: 它不影响可见性，但影响<strong>drawing system</strong><ul>
<li><code>opaque == true</code>的view不具有透明度，将拥有最高的渲染效率</li>
</ul>
</li>
<li><code>frame = CGRect.zero</code>的view也是不可见的</li>
</ul>
<h2>Frame, Bounds and Center</h2>
<ul>
<li>就是视图在父视图（坐标系）中的位置和大小。</li>
<li><code>sizeTofit</code>方法来适应内容的大小。</li>
<li><code>bound</code>原点设为(10, 10)意思是坐标系往左上角移了(10,10)的像素，即原来的(10,10)现在到了原点。<ul>
<li><code>bounds.insetBy(dx:dy)</code>是保持中心不变（即同时改变了原点和宽高）</li>
</ul>
</li>
<li><code>center</code>表示的是视图在父级中的位置，所以改变自己的bounds并不改变它的center<ul>
<li>本质上<code>frame</code>是center+宽度的便捷方法</li>
<li>如果v2是v1的子视图，<code>v2.center = v1.center</code> 通常不能生效，因为它们的坐标系不同（各自的父级）</li>
</ul>
</li>
</ul>
<h2>Transform and Transform3D</h2>
<ul>
<li>Transform改变View的绘制，但不改变它的bounds和center.</li>
<li>value is a <code>CGAffineTransform</code>，其实就是一个变换矩阵</li>
<li>CGPoint, CGSize, and CGRect all have an <code>applying(_:)</code> method 用来计算应用Transform后的坐标</li>
<li>3D版的就是多了一个垂直于屏幕的Z轴</li>
</ul>
<h2>Window Coordinates and Screen Coordinates</h2>
<ul>
<li>The device screen has <code>no frame</code>, but it has bounds.</li>
<li>The window has <code>no superview</code>, but its frame is set automatically to match the screen’s bounds.<ul>
<li>continues to fill the screen</li>
</ul>
</li>
</ul>
<p>iOS 7及之前，屏幕的坐标系是不变的，如果有旋转，则是对root view进行了一次rotation的transfrom。
但在iOS 8不再用transform而是制定了两套坐标系，通过<code>UICoordinateSpace</code>协议表示
    * UIScreen's <code>coordinateSpace</code>: 会旋转的bounds
    * UIScreen's <code>fixedCoordinateSpace</code>: 不变</p><p>读取视图v在设备的固定坐标系下的位置：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">screen</span> <span class="p">=</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">fixedCoordinateSpace</span>
<span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">superview</span><span class="p">!.</span><span class="n">convert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">screen</span><span class="p">)</span>
</pre></div>
<h2>Trait Collections</h2>
<p>将view的一系列环境特征通过view hierarchy层级下传，通过服从<code>UITraitEnvironment</code>协议（提供<code>traitCollection</code>属性和<code>traitCollectionDidChange</code>方法）</p><p><strong>traitCollection</strong></p><ul>
<li><em>displayScale</em>: screen's resolution</li>
<li><em>userInterfaceIdiom</em>: general device type, iPhone, or ipad</li>
<li><em>interfaceStyle</em>: is in light/dark mode</li>
<li><em>userInterfaceLevel</em>: .base / .elevated -&gt; affects dynamic background colors</li>
</ul>
<blockquote>
<p>If you implement traitCollectionDidChange(_: ), <code>always call super in the first line</code>. Forgetting to do this is a common beginner mistake.</p></blockquote>
<p>自定义trait collection只能用下面这种“组合”的方式</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">tcdisp</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">displayScale</span><span class="p">:</span> <span class="bp">UIScreen</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">scale</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tcphone</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceIdiom</span><span class="p">:</span> <span class="p">.</span><span class="n">phone</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">tc1</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">traitsFrom</span><span class="p">:</span> <span class="p">[</span><span class="n">tcdisp</span><span class="p">,</span> <span class="n">tcphone</span><span class="p">])</span>  <span class="c1">// 取交集</span>
</pre></div>
<p>自动颜色的底层逻辑：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">yellow</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">systemYellow</span>
<span class="kd">let</span> <span class="nv">light</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">light</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">dark</span> <span class="p">=</span> <span class="bp">UITraitCollection</span><span class="p">(</span><span class="n">userInterfaceStyle</span><span class="p">:</span> <span class="p">.</span><span class="n">dark</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">yellowLight</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">light</span><span class="p">)</span>
<span class="c1">// 1 0.8 0 1</span>
<span class="kd">let</span> <span class="nv">yellowDark</span> <span class="p">=</span> <span class="n">yellow</span><span class="p">.</span><span class="n">resolvedColor</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">dark</span><span class="p">)</span>
<span class="c1">// 1 0.839216 0.0392157 1</span>
</pre></div>
<h3>Size Classes</h3>
<p>把屏幕针对宽高和比例做几个分类：</p><ul>
<li>.regular(h, v) -&gt; iPad</li>
<li>.compact(h) + .regular(v) -&gt; 竖屏iPhone</li>
<li>.regular(h) + .compact(v) -&gt; 横屏大iPhone</li>
<li>.compact(h, v) -&gt; 横屏小iPhone（5S以前的）</li>
</ul>
<p>所以, size class:</p><ul>
<li>并不能从<code>traitCollectionDidChange</code>获得，因为iPad永远是<code>.regular</code></li>
<li>只关心横竖向突然间.regular和.compact的切换</li>
</ul>
<p><strong>Overriding Trait Collections</strong></p><p>You cannot <code>insert</code> a trait collection directly into the inheritance hierarchy simply by setting a view’s trait collection;</p><p>For the user interface style, there is a simpler facility available both for a UIViewController and for a UIView: the <code>overrideUserInterfaceStyle</code> property. 
    * default <code>.unspecified</code>，意味着interface style会往下传
    * 一旦设为.dark或.light, 就拦截了<code>userInterfaceStyle</code>的继承</p><h2>Layout</h2>
<ul>
<li>Manual layout: <code>layoutSubviews</code>里手动摆放每个视图，可定制最强</li>
<li>Autoresizing: 子视图根据<code>autoresizingMask</code>来调整</li>
<li>Autolayout: 依赖对“约束”的描述来布局，背后仍然是<code>layoutSubviews</code><ul>
<li>需要禁止autoresizing</li>
</ul>
</li>
</ul>
<h3>Autoresizing</h3>
<p>Autoresizing is a matter of conceptually assigning a subview “<strong>springs and struts</strong>.” A spring can expand and contract; a strut can’t. Springs and struts can be assigned internally or externally, horizontally or vertically.</p><p>可变的就叫Spring(有弹性)，不变的就叫Strut（不知道怎么翻译）。</p><ul>
<li>一个居中的子视图，本身也会随着父视图而改变大小:<ul>
<li>意味着它与父视图的四个边距是不变的 -&gt; 4个外部决定的struts</li>
<li>宽高则是可变的 -&gt; 2个内部决定的spring</li>
</ul>
</li>
<li>而如果子视图不随环境改变大小：<ul>
<li>意思着宽高是固定的 -&gt; 2个内部决定的struts</li>
<li>而四个边距通通可变 -&gt; 4个外部决定的spring</li>
</ul>
</li>
<li>一个右下角摆放的OK button<ul>
<li>显然，按钮大小不改变 -&gt; 2个内部struts</li>
<li>与右边和底部距离不变 -&gt; 2个外部struts</li>
<li>与顶部和左边距离可变 -&gt; 2个外部spring</li>
</ul>
</li>
<li>一个顶部占满的text field<ul>
<li>高度不变 -&gt; 1个vertical struts（内部）</li>
<li>宽度可变 -&gt; 1个horizontal spring(内部)</li>
<li>顶，左，右三边距离不变 -&gt; 3个外部struts</li>
<li>底部距离可变 -&gt; 1个外部spring</li>
</ul>
</li>
</ul>
<p>所谓的“内部”，是因为教材里用的是internally，就例子来看，其实就是说衡量的对象只是自己，而“距离”明显需要有一个参照物，那就叫externally了。</p><p>通过<code>autoresizingMask</code>来描述上述例子中的规则，通过bitmask来进行组合，默认为全空（但是等同于<code>flexibleRightMargin</code>)，即普通的流式布局，靠左上对齐，右边距和底边距是动态的。</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">v1</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">194</span><span class="p">))</span>
<span class="n">v1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v2</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">v2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">v1b</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">bounds</span>
<span class="kd">let</span> <span class="nv">v3</span> <span class="p">=</span> <span class="bp">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="n">v1b</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="n">v1b</span><span class="p">.</span><span class="n">height</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">v3</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="n">v1</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v3</span><span class="p">)</span>
</pre></div>
<p>演示了上例中的&quot;text fiels&quot;和“ok button&quot;，一个置顶，一个靠中下。并且都设置了绝对大小的宽高，那么当你改变v1的frame的时候，比如变宽变高，v2,v3会发生什么呢？</p><p>因为你没有设置autoresizingMask，那么就会默认保持左上的边距，这样v2不再铺满顶部，v3也不再紧贴右下角，想要它们跟着v1变化：</p><div class="highlight"><pre><span></span><span class="n">v2</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">.</span><span class="n">flexibleWidth</span>  <span class="c1">// 宽度可变</span>
<span class="n">v3</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleTopMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleLeftMargin</span><span class="p">]</span> <span class="c1">// 左，顶可变（这样就能尽情往右下贴了）</span>
</pre></div>
<blockquote>
<p>AutoResizing在<code>layoutSubviews</code>被调用之前发生。</p></blockquote>
<h3>Autolayout and Constraints</h3>
<p>autolayout的子view可以不用autolayout，但是父view必须是autolayout，层层向上到<code>main view</code> of it's view controller, which <em>receives autolayout-related events</em></p><p>autolayout描述不同view的属性之间的位置关系，这些view不必是兄弟，也不非得是父子，只需要保证拥有一个共同的祖先。</p><p>谁持有这些约束？</p><ul>
<li>如果是约束自身的宽度（绝对值） -&gt; 属于自身</li>
<li>如果是约束了它对superview的顶部的距离 -&gt; 属于superview</li>
<li>如果约束了几个sibling view的顶部对齐 -&gt; 属于这些view的superview</li>
</ul>
<p>事实上，iOS不需要你关心这个，<code>.activate</code>让你只管描述约束和关系，然后把它加到正确的view上。</p><p>约束基本上是可读的，除了<code>priority</code>, <code>constant</code>, 和 <code>isActive</code>，其它情况你只能移除并重建了。（还有一个跟约束无关的<code>identifier</code>， debug有用）</p><blockquote>
<p>autolayout发生在<code>layoutSubviews</code>，所以如果你提前设置了frame，图像将会发生跳动。如果你是在layoutSubviews里面设置的就不会。当然你最好线用约束。</p></blockquote>
<p>如果你的约束涉及到了别的之前并没用使用autolayout的view， The autolayout engine takes care of this for you:</p><ul>
<li>it <code>reads</code> the view’s <em>frame</em></li>
<li>and <em>autoresizingMask</em> settings and <code>translates</code> them into implicit constraints</li>
</ul>
<p>比如：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">lab1</span> <span class="p">=</span> <span class="bp">UILabel</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span><span class="n">CGRect</span><span class="p">(</span><span class="mi">270</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">22</span><span class="p">))</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="p">=</span> <span class="p">[.</span><span class="n">flexibleLeftMargin</span><span class="p">,</span> <span class="p">.</span><span class="n">flexibleBottomMargin</span><span class="p">]</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">lab1</span><span class="p">)</span>
</pre></div>
<p>一个右上的label，如果你的另一个view相对<em>lab1</em>来设置autolayout的约束，那么lab1将会自动产生如下四个约束：</p>
<pre><code>1. &lt;NSAutoresizingMaskLayoutConstraint H:[UILabel:'Hello']-(63)-|&gt;
2. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.minY == 20&gt;
3. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.width == 42&gt;
4. &lt;NSAutoresizingMaskLayoutConstraint UILabel:'Hello'.height == 22&gt;
</code></pre>
<p>而且约束的具体数值以当前运行设备来定的，比如上例是iPhone8，屏幕宽度是375，那么：</p><ul>
<li>origin(270, 28) 能得到minY = 20 -&gt; 约束2</li>
<li>size(42, 22)能得到height = 22, width = 42 -&gt; 约束3，4</li>
<li>结合屏幕宽度，origin, size， 得到右边距离：(375 - 270 - 42 = 63) -&gt; 约束1</li>
</ul>
<p>但是如果后面还有别的约束的话，很容易千万冲突，毕竟都自动生成的，用户写代码的时候并不会在意当时自动生成的约束在其它场景是否也会有别的约束自动生成</p><p><code>translatesAutoresizingMaskIntoConstraints</code>干的就是这个，所以一般情况下是把它关掉的。</p><p>语法：</p><div class="highlight"><pre><span></span><span class="n">v1</span><span class="p">.</span><span class="n">addConstraint</span><span class="p">(</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">v2</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">relatedBy</span><span class="p">:</span> <span class="p">.</span><span class="bp">equal</span><span class="p">,</span>
        <span class="n">toItem</span><span class="p">:</span> <span class="n">v1</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="p">.</span><span class="n">leading</span><span class="p">,</span>
        <span class="n">multiplier</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">)</span>


<span class="c1">// compact notation</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="n">lab1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="mi">20</span><span class="p">),</span>
        <span class="n">lab2</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span>
            <span class="n">equalTo</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">,</span> <span class="n">constant</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
<h3>VFL (Visual format notation)</h3>
<p><code>&quot;V:|-10-[v2(20)]&quot;</code>这代表v2的顶部距离superview 10个point,高度是20。如果描述的是水平方向的，则是<strong>H</strong>，但H是默认的，可以省略。同样，H对应的括号里的数值会被理解为width.</p><p>v2是view的名字，通常你需要准备一个字典，这样就可以在<code>VFL</code>中用简单的文字对应任何view了</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;v2&quot;</span><span class="p">:</span><span class="n">v2</span><span class="p">,</span><span class="s">&quot;v3&quot;</span><span class="p">:</span><span class="n">v3</span><span class="p">]</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|[v2]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:|[v2(10)]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">),</span>
    <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;V:[v3(20)]|&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
<span class="p">].</span><span class="n">flatMap</span> <span class="p">{</span><span class="nv">$0</span><span class="p">})</span>
</pre></div>
<p>注意这里的flatMap，因为<code>constraints(withVisualFormat:)</code> 返的是一个数组，而期望是一个值，所以用map把$0取了出来。</p><p><code>&quot;[v1(&gt;=20@400,&lt;=30)]&quot;</code>，@后面接的是优先级</p><h3>new features</h3>
<p>iOS 10引入的<code>anchorWithOffset(to:)</code>，是什么意思？</p><p>它也是创建的一个anchor，也就是说可以应用<code>constrain(equalto:)</code>之类的方法，而它本身是一个dimension，所以dimension当然是可以用来比较的。</p><p>比如，我有一个view(v1)，摆在屏幕上面某位置，现在要摆一个view(v2)，希望它出现在v1和屏幕底部（或v1的superview，设为v0）的中间（即垂直居中），显然，如果要用dimension描述出来的话，那就是：</p><ul>
<li>v1底部到v2中间的距离</li>
<li>等于</li>
<li>v2中部到屏幕底部v0底部的距离</li>
</ul>
<div class="highlight"><pre><span></span><span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">v1</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">)</span>
        <span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> 
    <span class="n">v2</span><span class="p">.</span><span class="n">centerYAnchor</span><span class="p">.</span><span class="n">anchorWithOffset</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
<p>刻意写成了三行，与我上文的三段文字描述对应</p><p>iOS 11引入了运行时决定的spacing：</p>
<pre><code>constraint(equalToSystemSpacingAfter:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(lessThanOrEqualToSystemSpacingAfter:multiplier:)
constraint(equalToSystemSpacingBelow:multiplier:)
constraint(greaterThanOrEqualToSystemSpacingBelow:multiplier:)
constraint(lessThanOrEqualToSystemSpacingBelow:multiplier:)
</code></pre>
<h3>Margins and Guides</h3>
<ul>
<li>UIEdgeInsets是对布局的补充，增加“第二条边”</li>
<li>Layout guides -&gt; 没看明白</li>
<li>safe area可以表示为inset，也可以表示为guides<ul>
<li><code>additionalSafeAreaInsets</code>还能增加safe area</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">)</span>
</pre></div>
<p>subview might be positioned with respect to its superview’s <code>margins</code>, especially through an autolayout constraint. By <strong>default</strong>, a view has a margin of 8 on all four edges.
这更像是superview的padding，而iOS并没有padding的概念（因为它并不是CSS的盒子模型）</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">arr</span> <span class="p">=</span> <span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">constraints</span><span class="p">(</span><span class="n">withVisualFormat</span><span class="p">:</span>
        <span class="s">&quot;H:|-[v]&quot;</span><span class="p">,</span> <span class="n">metrics</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">views</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">:</span><span class="n">v</span><span class="p">])</span>
</pre></div>
<ul>
<li><code>layoutMarginsGuide</code>是只读的，但UIView提供了<code>layoutMargins</code>属性（一个UIEdgeInsets）<ul>
<li>from iOS11: <code>directionalLayoutMargins</code>(其实就是用了trail, leading等)</li>
</ul>
</li>
<li>VFL中用短横线来代表对齐的是margin</li>
<li>margin会往下传，用<code>preservesSuperviewLayoutMargins</code>控制</li>
<li>margin与safearea不冲突，会自动相加，用<code>insetsLayoutMarginsFromSafeArea</code>关闭</li>
<li>viewController有<code>systemMinimumLayoutMargins</code>可以增加main view的margin(减小的话会静默失败，即无效)<ul>
<li>而<code>viewRespectsSystemMinimumLayoutMargins</code>设为false，就能突破这个限制：（上下为0，左右为16，大屏设备左右为20）</li>
</ul>
</li>
</ul>
<p><strong>Custom layout guides</strong></p><p>书中的例子是垂直平均分配几个view，然后发现是把layout guide当成一个view来做的</p><ul>
<li>每个view（除去最后一个） add一个guide</li>
<li>ABABABA排列，A是view,B是guide</li>
<li>A的底部=B的顶部（除去最后一个A）</li>
<li>A的顶部=B的底部（除去第一个A）</li>
<li>令B的高度相等</li>
</ul>
<p>就把4个A给垂直平均分配了，理解的难点就是guide也当作一个view来用，而语法上又是加到view的属性里的。同时，只要设置guide的高度相等，就会自动占用4个View之外的所有空间平均分配。
<figure  style="flex: 78.66449511400651" ><img width="966" height="614" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2629afe5515d8fa7df75f83b138083fa.png" alt=""/></figure></p><p>这么做只是为了演示layout guide，但是虽然理解了，也不知道能用它来干嘛？当成一个隐形的view去做布局？</p><p><strong>Constraint alignment</strong></p><p>通过设置view的<code>alignmentRectInsets</code>，可以改变constrains计算的起点。对我来说，又是一种padding?</p><p>同样的还有自定义baseline的<code>forFirstBaselineLayout and forLastBaselineLayout.</code></p><h3>Intrinsic Content Size</h3>
<p>button, label, image等会根据内容和预设有一个instrinsic content size，而且可以用来<strong>隐式地</strong>产生约束（<code>NSContentSizeLayoutConstraint</code>）</p><ul>
<li><code>contentHuggingPriority(for:)</code> 某方向上阻止扩大到比intrinsic size更大的优先级，默认250</li>
<li><code>contentCompressionResistancePriority(for:)</code>，阻止缩小的优先级，默认750</li>
<li><code>invalidateIntrinsicContentSize</code>就像invalidate a view，会触发重新计算size</li>
</ul>
<p><code>&quot;H:[lab1(&gt;=100)]-(&gt;=20)-[lab2(&gt;=100)]&quot;</code> 这两个label，在屏幕变小时，谁最先缩到100？</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">lab2</span><span class="p">.</span><span class="n">contentCompressionResistancePriority</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
<span class="n">lab1</span><span class="p">.</span><span class="n">setContentCompressionResistancePriority</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">horizontal</span><span class="p">)</span>
</pre></div>
<p>这里把lab1阻止缩小的优先级调得更高，那么就是lab2会先缩小</p><h3>Self-Sizing Views</h3>
<p>前面讲的都是superview对subview的影响，这一节反过来，subview的大小影响superview。</p><p>假定一个没有设置宽高的view，包含了一个button，我们知道button是有其intrinsic size的（固定的高，宽度由按钮文字决定），</p><ul>
<li>所以这个view也就有了宽高。</li>
<li>但这个宽高拥有低优先级，不会与显式设定的宽高相冲突。</li>
<li>运行时调用<code>systemLayoutSizeFitting(_:)</code>可以让系统优优先级地去按这个size去layout。这个操作是昂贵和低效的。</li>
</ul>
<h3>Stack Views</h3>
<p>UIStackView仍然是自动布局体系里的，它的作用是（为其<code>arrangedSubviews</code>）生成一系列约束，可以理解为语法糖。</p><ul>
<li><code>arrangedSubviews</code>是<strong>subViews</strong>的一个子集</li>
<li>stackView也可以添加额外的subView</li>
<li><em>setCustomSpacing(_:after:)</em>设置额外的space</li>
<li>不要再对arrangedSubviews手动添加约束，基本会与你看不见的计算出来的约束冲突<ul>
<li>但stackview本身是可以用autolayout来布局的</li>
</ul>
</li>
</ul>
<p>此时再来看看前面的竖向排列元素，并且间隔相等的例子的写法：</p><div class="highlight"><pre><span></span><span class="c1">// give the stack view arranged subviews</span>
<span class="kd">let</span> <span class="nv">sv</span> <span class="p">=</span> <span class="bp">UIStackView</span><span class="p">(</span><span class="n">arrangedSubviews</span><span class="p">:</span> <span class="n">views</span><span class="p">)</span>
<span class="c1">// configure the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">axis</span> <span class="p">=</span> <span class="p">.</span><span class="n">vertical</span>
<span class="n">sv</span><span class="p">.</span><span class="n">alignment</span> <span class="p">=</span> <span class="p">.</span><span class="n">fill</span>
<span class="n">sv</span><span class="p">.</span><span class="n">distribution</span> <span class="p">=</span> <span class="p">.</span><span class="n">equalSpacing</span>
<span class="c1">// constrain the stack view</span>
<span class="n">sv</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="p">=</span> <span class="kc">false</span>
<span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">marg</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layoutMarginsGuide</span>
<span class="kd">let</span> <span class="nv">safe</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">safeAreaLayoutGuide</span>
<span class="bp">NSLayoutConstraint</span><span class="p">.</span><span class="n">activate</span><span class="p">([</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">safe</span><span class="p">.</span><span class="n">topAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">leadingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="n">marg</span><span class="p">.</span><span class="n">trailingAnchor</span><span class="p">),</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">.</span><span class="n">constraint</span><span class="p">(</span><span class="n">equalTo</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bottomAnchor</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
<p>顺便注意以下里对layoutMargin和safearea的引用，都是通过layout guide的。</p><blockquote>
<p>debug会发现stack view其实帮你做了你之前做的事：<code>generating UILayoutGuide objects and using them as spacers</code></p></blockquote>
<p>stack view还有一个特性就是能自适应<code>arrangedSubviews</code>的变化。如果你把它理解为一个计算引擎，可能就好理解了。</p><h3>Internationalization</h3>
<p>使用.leading, .trailing等是为了适应不同语言的左右顺序，引入到布局里却会出现问题，并不是从右到左的语言的横向布局就也要相应反转。UIView.semanticContentAttribute可以人为控制，</p><ul>
<li>默认值是.unspecified，</li>
<li>.playback or .spatial将会不应用翻转。</li>
<li>.forceLeftToRight or .forceRightToLeft则是手动指定一个方向</li>
</ul>
<p>UIView<code>.effectiveUserInterfaceLayoutDirection</code>能report出这个trait</p><blockquote>
<p>You can test your app’s right-to-left behavior easily by changing the scheme’s Run option Application Language to “Right to Left Pseudolanguage.”</p></blockquote>
<h3>Debug autolayout</h3>

<pre><code>(lldb) e -l objc -- [[UIApplication sharedApplication] windows][0]
(UIWindow *) $1 = ...
(lldb) e -l objc -O -- [$1 _autolayoutTrace]
</code></pre>
<p>To get a full list of the constraints responsible for positioning a particular view within its superview, log the results of calling the UIView instance method <code>constraintsAffectingLayout(for:)</code>.</p><h2>Configuring Layout in Nib</h2>
<p>这一部分内容建议打开Xcode对着原文操作，多为界面操作</p><h3>Conditional Interface Design</h3>
<p>wC, HR等用来表示宽高在正常和压缩空间里的不同组合。</p><p>思路：先架构通用的视图和约束，然后用两种方法之一来描述不同size class下的特殊布局：</p><ul>
<li>in the Attributes or Size inspector</li>
<li>design that difference in the canvas:</li>
</ul>
<h2>Xcode View Features</h2>
<h3>Designable Views and Inspectable Properties</h3>
<p>有关Xcode的预览这一节可以看看，以及<code>@IBDesignable</code>方法能在xib里面呈现（教程里是在<code>willMove(toSuperview)</code>方法里调用）</p><h2>Layout Events</h2>
<p><strong>updateConstraints</strong></p><ul>
<li>（向上冒泡）<code>propagated up</code> the hierarchy, starting at the deepest subview</li>
<li>called at launch time，然后几乎不会调用，除非手动</li>
<li>也从不直接调用，而是通过<ul>
<li><code>updateConstraintsIfNeeded</code>方法</li>
<li>或是<code>setNeedsUpdateConstraints</code></li>
</ul>
</li>
</ul>
<p><strong>traitCollectionDidChange(_:)</strong></p><ul>
<li>(向下传播)<code>propagated down</code> the hierarchy of UITraitEnvironments.</li>
</ul>
<p><strong>layoutSubviews</strong></p><ul>
<li>The layoutSubviews message is the moment when <code>layout actually takes place</code>.</li>
<li>（向下传播） <code>propagated down</code> the hierarchy, starting at the top (typically the root view) and working down to the deepest subview.</li>
<li>If you’re not using autolayout, layoutSubviews does <strong>nothing</strong> by default</li>
<li>layoutSubviews is your opportunity to perform manual layout <strong>after</strong> autoresizing has taken place.</li>
<li>If you are using autolayout, you <strong>must</strong> call super or the app will crash (with a helpful error message).</li>
<li>从不直接调用：<ul>
<li><code>layoutIfNeeded</code></li>
<li><code>setNeedsLayout</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>When you’re using autolayout, <code>what happens in layoutSubviews</code>?</p><ol>
<li>The runtime, having examined and resolved all the constraints affecting this view’s subviews,</li>
<li>and having worked out values for their center and bounds,</li>
<li>now simply assigns <code>center</code> and <code>bounds</code> values to them.</li>
</ol>
<p>In other words, layoutSubviews performs <strong>manual layout</strong>!</p></blockquote>
<p>所以如果你需要在auto layout之后微调，<code>layoutSubviews</code>是法定的入口：</p><ol>
<li>call <code>super</code>, causing all the subviews to adopt their new frames</li>
<li>examine those frames, 如果不满意，则对<code>frame</code>进行微调（或者<code>bounds</code>和<code>center</code>）</li>
</ol>
<p>这也是autolayout engine自己的步骤，要注意的是你必须要和autolayout engine来协作，并且<strong>不要</strong>调用<code>setNeedsUpdateConstraints</code>(时机已过)</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/View/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_self">翻转二叉树</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/" target="_self">
                <time class="text-uppercase">
                    December 08 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>最近在找工作，所以这些算法梗又出现在了我的阅读视野里，比如经典的homebrew作者吐槽的翻转二叉树的问题。
<figure  style="flex: 86.71052631578948" ><img width="659" height="380" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4b282d39e440d597c619d781ee3b690e.png" alt=""/></figure></p><p>我本以为是根和叶节点倒转过来，原来是同层里面的左右翻转。</p><p>那么就是把左边换到右边，右边换到左边呗，可以考虑递归。我一直用一个原则理解递归，就是把命令传达下去（比如上面的左右互换，就完了），而不关心细节，只有最末端的那个大头兵才是真正做业务的人，写了一下，递归加业务也就4行代码：</p><figure  style="flex: 80.10335917312662" ><img width="1240" height="774" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/8defc3430ca00b8a8501fb6d8356c6fb.png" alt=""/></figure><p>具体到这个问题，就是我把left和right互换就是了
然后left和right你们做好自己的子级的互换，我不管，所以核心代码就一句
<code>left, right = right, left</code>，前面是为了稳妥，通过了之后，直接用python这种左右互换的特性，那就真是一句代码了：</p><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">理解Core-Graphics的Clipping和填充模式</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/" target="_self">
                <time class="text-uppercase">
                    November 28 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>先来看一个例子
<figure class="vertical-figure" style="flex: 38.76146788990825" ><img width="338" height="436" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d5fdc49bd6037d399e4685d3cf9d72bf.png" alt=""/></figure>
画一个箭头，其中箭尾有分叉，一般来说，是画一个三角，画一个矩形（实心矩形一般也直接用很粗的线条），最后再叠一个三角（with <code>CGBlendModel.clear</code>)，这里就不多介绍了：</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>       
    <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="bp">UIBezierPath</span><span class="p">()</span>
    <span class="c1">// shaft</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">lineWidth</span> <span class="p">=</span> <span class="mi">20</span>
    <span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>

    <span class="c1">// point</span>
    <span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="kr">set</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">()</span>

    <span class="c1">// snip</span>
    <span class="n">p</span><span class="p">.</span><span class="n">removeAllPoints</span><span class="p">()</span>
    <span class="n">p</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">with</span><span class="p">:</span><span class="n">CGBlendMode</span><span class="p">.</span><span class="n">clear</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>我们来看看<code>clipping</code>怎么用</p><ol>
<li>fill三角箭头（出于堆叠上目的可以最后画）</li>
<li>找到箭尾的三个顶点<ul>
<li>用<code>boundingBoxOfClipPath</code>来创建整个画板大小的矩形</li>
<li>应用<code>clipping</code>把小三角挖掉</li>
</ul>
</li>
</ol>
<p>3，画一根黄色箭柄粗细的线（从底向上）
    * 因为小三角区域被clipping掉了，结果就成了图示的模样</p><div class="highlight"><pre><span></span><span class="kr">override</span> <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="kc">_</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// obtain the current graphics context</span>
        <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>

        <span class="c1">// punch triangular hole in context clipping region</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">90</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">90</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">110</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">closePath</span><span class="p">()</span>
        <span class="c1">// 添加整个区域为rect</span>
        <span class="c1">// 然后再clip设定为不渲染的区域</span>
        <span class="c1">// 后续的渲染全会避开这个区域</span>
        <span class="c1">// 我们后面把这个rect设为蓝色试试(顺便改为一个小一点的rect)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addRect</span><span class="p">(</span><span class="n">con</span><span class="p">.</span><span class="n">boundingBoxOfClipPath</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">using</span><span class="p">:.</span><span class="n">evenOdd</span><span class="p">)</span>
<span class="c1">//        con.fillPath()</span>

        <span class="c1">// draw the vertical line</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setStrokeColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">yellow</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">19</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">strokePath</span><span class="p">()</span>

        <span class="c1">// draw the red triangle, the point of the arrow</span>
        <span class="n">con</span><span class="p">.</span><span class="n">setFillColor</span><span class="p">(</span><span class="bp">UIColor</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">cgColor</span><span class="p">)</span>
        <span class="n">con</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">to</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="mi">120</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">25</span><span class="p">))</span>
        <span class="n">con</span><span class="p">.</span><span class="n">fillPath</span><span class="p">()</span>
    <span class="p">}</span>
</pre></div>
<p>能够完美run起来，但是我对clipping的机制还是有点不理解，一些关键点的讲解，和我的问题，一条条过：</p><ol>
<li>我们用构建了箭尾的三角形，然后<code>closePath</code>，那是因为我们只画了两条线，如果事实上第三条线连回了原点，那么这个<code>closePath</code>就不需要了</li>
</ol>
<ul>
<li>（图一）演示了不close的话就直接只有两条线了</li>
</ul>
<ol start="2">
<li>我想看看clipping到底发生了啥，于是注释掉了clip的那一行，得到了（图二）</li>
</ol>
<ul>
<li>之所以长那样是因为随后设置了stroke的参数（20像素的黄色）</li>
<li>stroke时，画板上有三个元素：一个三角，一个矩形，一条线段，全部用20宽的黄线描边了，一切如预期</li>
</ul>
<ol start="3">
<li>于是我尝试添加rect时只取了中间一小块，并涂成蓝色，不clip试试，得到（图三）。</li>
<li>知道了新rect的位置，把clip加回来，发现箭尾有了，箭头却没了（图四）</li>
<li>rect与clip的关系已经出来了，尝试把红三角的y通通加50，移到了蓝矩形范围内，得到证明（图五）</li>
</ol>
<figure  style="flex: 58.108108108108105" ><img width="774" height="666" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/83a72f77f3c1af59c2e83c0616699ca5.png" alt=""/></figure><p>那么clipping到底能对哪些起作用呢？是上面的rect吗？<strong>当然不是</strong>！</p><p>在clip方法被调用的时候，画布里有多少封闭元素，就会被应用clip。由于我们选择的是<code>evenOdd</code>模式，那么就会简单计数，某像素覆盖奇数次显示，偶数次则不显示。</p><p>上例中，<code>con.clip(using:)</code>方法调用时，画布里有两个封闭元素，一个三角，一个矩形，三角包在矩形里，那么计数为2，就不予显示了。</p><blockquote>
<p>事实上，判定奇偶的依据是该点向外做无限长的射线，判定有几条边与射线相交。同时，同样的设定可以用来解释<code>.winding</code>模式，即不但与相交的边有交，还与相交时，那条边是顺时针方向绘制的（+1）还是逆时针方向绘制的（-1）,总结果为0则不填充。<a href="https://www.jianshu.com/p/5cf8048b083b">参考</a></p></blockquote>
<p>那就玩一玩验证下吧</p><ol>
<li>把矩形改成了圆圈，线宽也改小一点，得到（图一）<em>绿色三角形是我后加的，因为被黄实线盖住了</em></li>
<li>再在里面添加了一个小圆，得到（图二）</li>
<li>这时候按照奇偶原则，小圆里的像素是偶数，而小圆里的三角则是奇数了，那么应该就只有大圆减掉小圆的部分，和小圆内的三角会被渲染了（图三），与预期一致</li>
</ol>
<figure  style="flex: 137.00564971751413" ><img width="970" height="354" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/84aa194f6e13d2f92fe6e9929e5c7110.png" alt=""/></figure><p>现在再来回顾书上先套一个画布大小的矩形，再画一个三角形，你大概应该知道目的了（凑奇偶），我们矩形区域过小时绘制不了红色三角，纯粹也是因为奇数，往下移到矩形区域内，立马变偶数了。(当然，要在原位置渲染我们可以先中止clip:<code>con.resetClip()</code>再绘图）</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E7%90%86%E8%A7%A3Core-Graphics%E7%9A%84Clipping%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/Thread-in-iOS/" target="_self">Programming iOS 14 - Threading</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/Thread-in-iOS/" target="_self">
                <time class="text-uppercase">
                    November 26 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>《Programming iOS 14: Dive Deep into Views, View Controllers, and Frameworks》第25章</p><hr />
<h1>Thread</h1>
<p>Thread在开发过程中基本上线程是隐形的，你感知不到，因为大多数情况下，程序只（需要）跑在主线程上，这是没有问题的：</p><ul>
<li>你的代码事实上执行得非常快，你感知不到</li>
<li>响应逻辑过程锁死UI，是安全的操作</li>
</ul>
<p>原生的后台线程：</p><ul>
<li>动画：The Core Animation framework is running the animation and updating the presentation layer on a background thread.</li>
<li>网络：A web view’s fetching and loading of its content is asynchronous</li>
<li>影音：Sounds are played asynchronously. Loading, preparation, and playing of movies happens asynchronously.</li>
<li>存盘：UIDocument saves and reads on a background thread.</li>
</ul>
<p>但所有的<code>complete functions / delegations / notification</code> 都是在主线程被调用的</p><p>多线程的问题</p><ul>
<li>调用时机/顺序不可控，次数也不可控，随时可能被执行</li>
<li>数据的线程安全，不得不借助“锁”的机制来保证（race condition）<ul>
<li>a lock is an <code>invitation</code> to <em>forget</em> to use the lock, or to <em>forget</em> to remove the lock after you’ve set it.</li>
</ul>
</li>
<li>The lifetime of a thread is independent of the lifetimes of other objects in your app.<ul>
<li>一个对象的退出不能保证有后台线程将来会调用它 -&gt; 闪退或Zombie</li>
</ul>
</li>
<li>Hard to debug.</li>
</ul>
<p>XCode对debug的支持：</p><ul>
<li>Debug navigator</li>
<li><code>NSLog / os_log / Logger</code> outputs</li>
<li>Instruments &gt; Time Profiler</li>
<li>Thread Sanitizer, Main Thread Checker (项目配置 &gt; Diagnostics)</li>
</ul>
<p>执行后台线程的方法：</p><h2>Manual Threading</h2>
<p><code>performSelector(inBackground:with:)</code></p><ul>
<li>只能传一个参数，多个参数要打包</li>
<li>手动管理内存 -&gt; wrap every thing in an autorelease pool</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
        <span class="c1">// 这里打包参数为一个字典</span>
        <span class="kd">let</span> <span class="nv">d</span> <span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">]</span> <span class="p">=</span>
            <span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">:</span><span class="n">center</span><span class="p">,</span> <span class="s">&quot;bounds&quot;</span><span class="p">:</span><span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="s">&quot;zoom&quot;</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">inBackground</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">reallyDraw</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">}</span>
<span class="c1">// trampoline, background thread entry point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">reallyDraw</span><span class="p">(</span><span class="kc">_</span> <span class="n">d</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyHashable</span><span class="p">:</span><span class="nb">Any</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// 手动控制内存</span>
    <span class="n">autoreleasepool</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;center&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGPoint</span><span class="p">,</span>
            <span class="n">bounds</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;bounds&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGRect</span><span class="p">,</span>
            <span class="n">zoom</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s">&quot;zoom&quot;</span><span class="p">]</span> <span class="k">as</span><span class="p">!</span> <span class="n">CGFloat</span><span class="p">)</span>
        <span class="c1">// 手动回调主线程</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">performSelector</span><span class="p">(</span><span class="n">onMainThread</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">allDone</span><span class="p">),</span> <span class="n">with</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
            <span class="n">waitUntilDone</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>

<span class="p">}</span>
<span class="c1">// called on main thread! background thread exit point</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">allDone</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>即便如此，还是没有解决不同线程使用同一个实例变量（如<code>bitmapContext</code>）造成程序非常脆弱的问题，得进一步使用<code>lock</code>等机制。</p><h2>Operation</h2>
<ul>
<li>将<code>thread</code>封装成<code>task</code>，表示成<code>Operation</code> 通过 <code>OperationQueue</code>来操作。</li>
<li>回调机制变成了通知机制（或<code>KVO</code>）</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">queue</span> <span class="p">:</span> <span class="n">OperationQueue</span> <span class="p">=</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
    <span class="c1">// ... further configurations can go here ...</span>
    <span class="k">return</span> <span class="n">q</span>
<span class="p">}()</span>

<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="c1">// 也可以用 BlcokOperation</span>
    <span class="c1">// 来执行你的耗时操作</span>
    <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">MyMandelbrotOperation</span><span class="p">(</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 通知/回调</span>
    <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
        <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="n">operationFinished</span><span class="p">),</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
    <span class="c1">// 结合起来</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>而一个<code>Operation</code>子类包含两个部分：</p><ol>
<li>A designated initializer<ul>
<li>你可以把需要的参数设计成对应的属性，并初始化好它</li>
</ul>
</li>
<li>A main method<ul>
<li>耗程序真正执行的地方，OperationQueue执行到这个Operation的时候就会被自动执行</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">MyMandelbrotOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">mandelOpFinished</span> <span class="p">=</span> <span class="n">Notification</span><span class="p">.</span><span class="n">Name</span><span class="p">(</span><span class="s">&quot;mandelOpFinished&quot;</span><span class="p">)</span>

    <span class="c1">// 1. params -&gt; arguments</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">center</span> <span class="p">:</span> <span class="n">CGPoint</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">:</span> <span class="n">CGRect</span>
    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">zoom</span> <span class="p">:</span> <span class="n">CGFloat</span>
    <span class="kd">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">bitmapContext</span> <span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span> <span class="p">=</span> <span class="kc">nil</span>  <span class="c1">// 封装成了类属性，不再线程共享</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">center</span> <span class="n">c</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span> <span class="n">b</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span> <span class="n">z</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">c</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span> <span class="p">=</span> <span class="n">b</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span> <span class="p">=</span> <span class="n">z</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// 1.1 logic</span>
    <span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
    <span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... same as before</span>
    <span class="p">}</span>

    <span class="c1">// 2. main</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 首先要检查isCancelled</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span><span class="p">}</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">zoom</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="p">{</span>
            <span class="c1">// 完成通知，也可以用KVO机制</span>
            <span class="c1">// 主线程接收到后要立即处理，因为OpearationQueue将会立即释放这个Operation</span>
            <span class="c1">// 此外，接收通知可能也不在主线程，-&gt; GCD</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 3. observer</span>
<span class="c1">// 就是前面在主线程里注册监听消息的方法</span>
<span class="c1">// warning! called on background thread</span>
<span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">operationFinished</span><span class="p">(</span><span class="kc">_</span> <span class="n">n</span><span class="p">:</span><span class="n">Notification</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">op</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">MyMandelbrotOperation</span> <span class="p">{</span>
        <span class="c1">// 1. 主线程（GCD）</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="c1">// 2. 移除通知监听</span>
            <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="kc">self</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">MyMandelbrotOperation</span><span class="p">.</span><span class="n">mandelOpFinished</span><span class="p">,</span> <span class="n">object</span><span class="p">:</span> <span class="n">op</span><span class="p">)</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">op</span><span class="p">.</span><span class="n">bitmapContext</span>  <span class="c1">// 传回这个之前是线程共享的变量</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>注意<code>bitmapContext</code>这个之前主线程设置，然后后台线程共享的变量，现在由Operation这个类自己持有，结束时才赋值回主线程。</p><p>此外，还能限制并发数量：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">OperationQueue</span><span class="p">()</span>
<span class="n">q</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="p">=</span> <span class="mi">1</span>
</pre></div>
<p>This turns the OperationQueue into a <code>serial queue</code>.</p><p>最后，解决最后一个问题，即你的调用者都没了，比如ViewController没了，调用者没了，后台任务也理应取消（下载、存盘类不需要UI交互的除外）</p><div class="highlight"><pre><span></span><span class="kd">deinit</span><span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">cancelAllOperations</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>至此，前面提到的一些多线程会带来的问题如调用时机和数量不可控，跨线程数据安全，以及生命周期等问题，<code>Operation</code>都完美解决并封装了。</p><p>设置优先级，QoS, 依赖等一些进阶示例：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">backgroundOperation</span> <span class="p">=</span> <span class="bp">NSOperation</span><span class="p">()</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">queuePriority</span> <span class="p">=</span> <span class="p">.</span><span class="n">Low</span>
<span class="n">backgroundOperation</span><span class="p">.</span><span class="n">qualityOfService</span> <span class="p">=</span> <span class="p">.</span><span class="n">Background</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">backgroundOperation</span><span class="p">)</span>

<span class="c1">// dependence</span>
<span class="kd">let</span> <span class="nv">networkingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="kd">let</span> <span class="nv">resizingOperation</span><span class="p">:</span> <span class="bp">NSOperation</span> <span class="p">=</span> <span class="p">...</span>
<span class="n">resizingOperation</span><span class="p">.</span><span class="n">addDependency</span><span class="p">(</span><span class="n">networkingOperation</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">operationQueue</span> <span class="p">=</span> <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">()</span>
<span class="c1">// 虽然resizing添加了network为依赖，但是还是需要全部加到队列里</span>
<span class="c1">// 不要以为加了尾部operation就能把依赖全加进去</span>
<span class="n">operationQueue</span><span class="p">.</span><span class="n">addOperations</span><span class="p">([</span><span class="n">networkingOperation</span><span class="p">,</span> <span class="n">resizingOperation</span><span class="p">],</span> <span class="n">waitUntilFinished</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
</pre></div>
<h2>Grand Central Dispatch</h2>
<p>可以认为GCD是更底层的Operation，它甚至直接嵌入了操作系统，能被任何代码执行而且非常高效。调用过程也与Operation差不多:</p><ul>
<li>表示一个task</li>
<li>加入一个queue<ul>
<li>GCD Queue也被表示成了<em>dispatch queue</em></li>
<li>a lightweight opaque pseudo-object consisting essentially of <code>a list of functions</code> to be executed.</li>
<li>如果自定义这个queue，它默认状态下是<code>serial queue</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">MANDELBROT_STEPS</span> <span class="p">=</span> <span class="mi">100</span>
<span class="kd">var</span> <span class="nv">bitmapContext</span><span class="p">:</span> <span class="n">CGContext</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">draw_queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;com.neuburg.mandeldraw&quot;</span><span class="p">)</span>

<span class="c1">// 改造一个返回前述跨线程变量的方法</span>
<span class="kd">func</span> <span class="nf">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="n">CGSize</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">CGContext</span> <span class="p">{</span>
    <span class="c1">// ... as before ...</span>
    <span class="kd">let</span> <span class="nv">context</span> <span class="p">=</span> <span class="n">CGContext</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">),</span> <span class="n">height</span><span class="p">:</span> <span class="nb">Int</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
        <span class="n">bitsPerComponent</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="n">bytesPerRow</span><span class="p">:</span> <span class="n">bitmapBytesPerRow</span><span class="p">,</span>
        <span class="n">space</span><span class="p">:</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">:</span> <span class="n">prem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">!</span>
<span class="p">}</span>
<span class="c1">// 相应方法增加这个context参数，而不是从环境里取</span>
<span class="kd">func</span> <span class="nf">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span><span class="n">CGContext</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... as before, but we refer to local context, not self.bitmapContext</span>
<span class="p">}</span>

<span class="c1">// 剩下的，一个block搞定：</span>
<span class="c1">// UI触发的事件</span>
<span class="kd">func</span> <span class="nf">drawThatPuppy</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">center</span>
    <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">bounds</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// 下面两行代码虽然用到了self，但是它们没有改变任何属性，是线程安全的</span>
        <span class="kd">let</span> <span class="nv">bitmap</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">makeBitmapContext</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span> <span class="n">bounds</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">zoom</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">bitmap</span><span class="p">)</span>
        <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">bitmapContext</span> <span class="p">=</span> <span class="n">bitmap</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<p>可以看到，相比Operation把代码结构都改了，GCD几乎只是包了一层block，代码变动非常少。（唯一的发动就是把所有执行代码的变量都需要通过参数机制传进去）。</p><p>同时， <em>center, bounds</em>等参数，直接从环境里取，这是block机制带来的便利；同样的机制也被用在了线程共享的变量传回主线程时，因为对第二层block而言，第一层block就是它的<code>higher surrounding scope</code>，是能看到它的<em>bitmap</em>变量的。 -&gt; 我们并没有从头到尾retrive一个<code>self.bitmap</code>变量，也就不存在data sharing。</p><p>不像Operation把耗时操作写在别处，GCD的方式易读性更高。</p><p>除了有<code>.async(execute:)</code>，还有<code>asyncAfter(deadline:execute:)</code>和<code>sync(execute:)</code>，望文生义，就不多介绍了。</p><h3>Dispatch Groups</h3>
<p>group提供了监听(wait)一组后台线程全部执行结束的功能：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">outerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;outer&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">innerQueue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;inner&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">group</span> <span class="p">=</span> <span class="n">DispatchGroup</span><span class="p">()</span>
<span class="n">outerQueue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">series</span> <span class="p">=</span> <span class="s">&quot;123456789&quot;</span>
    <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">series</span> <span class="p">{</span>
        <span class="n">group</span><span class="p">.</span><span class="n">enter</span><span class="p">()</span>  <span class="c1">// flag 1</span>
        <span class="n">innerQueue</span><span class="p">.</span><span class="n">asyncAfter</span><span class="p">(</span>
            <span class="n">deadline</span><span class="p">:.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">milliseconds</span><span class="p">(</span><span class="nb">Int</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="k">in</span><span class="p">:</span> <span class="mf">1.</span><span class="p">..</span><span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">terminator</span><span class="p">:</span><span class="s">&quot;&quot;</span><span class="p">)</span>
                <span class="n">group</span><span class="p">.</span><span class="n">leave</span><span class="p">()</span> <span class="c1">// flag 2</span>
        <span class="p">}</span> 
        <span class="n">group</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>  <span class="c1">// 一旦加了这句话，这9个线程就变成线性的了，注释掉，就是9个线程随机先后执行</span>
    <span class="p">}</span>
    <span class="c1">// 可见这个notify等同于wait_all</span>
    <span class="c1">// 当enter次数与leave次数一致时触发</span>
    <span class="n">group</span><span class="p">.</span><span class="n">notify</span><span class="p">(</span><span class="n">queue</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">done&quot;</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div>
<h3>One-Time Execution</h3>
<p>Objective-C中实现单例的<code>dispatch_once</code>其实就是GCD的内容，而在Swift中这个方法就没有了，也没用GCD去实现了:</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">globalOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in a lifetime&quot;</span><span class="p">)</span> <span class="c1">// once, at most</span>
<span class="p">}()</span>
</pre></div>
<p>这个print只会打印一次。而如果是用在对象中，可以声明为<code>lazy</code>：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
        <span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">instanceOnce</span> <span class="p">:</span> <span class="nb">Void</span> <span class="p">=</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;once in an instance&quot;</span><span class="p">)</span> <span class="c1">// once per instance, at most</span>
        <span class="p">}()</span>
<span class="c1">// ... }</span>
</pre></div>
<p><code>instanceOnce</code>这个变量也只会初始化一次。</p><p><strong>Bonus</strong></p><div class="highlight"><pre><span></span><span class="c1">// 并发</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">(</span><span class="n">label</span><span class="p">:</span> <span class="s">&quot;queue&quot;</span><span class="p">,</span> <span class="n">attributes</span><span class="p">:</span> <span class="p">.</span><span class="n">concurrent</span><span class="p">)</span>
<span class="c1">// 条件， check the queue</span>
<span class="n">dispatchPrecondition</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="p">.</span><span class="n">onQueue</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">draw_queue</span><span class="p">))</span>
</pre></div>
<h2>App Backgrounding</h2>
<ul>
<li>应用进入后台时，iOS系统会给应用<code>小于5秒</code>的时间来结束当前的任务</li>
<li>可以用<code>UIApplication.shared.beginBackgroundTask(expirationHandler:)</code>来申请更长的时间（<code>不超过30秒</code>），返回一个identifier<ul>
<li><code>expirationHandler</code>是一个超时还没处理完的话，系统会调的方法，</li>
</ul>
</li>
<li>任务执行完后需要调用<code>UIApplication.shared.endBackgroundTask(_:)</code>方法来结束后台时间的申请<ul>
<li><code>expirationHandler</code>里同样需要显式<code>endBackgroundTask</code></li>
<li>所以正常方法体和超时方法体都会有endBackgroundTask的调用</li>
</ul>
</li>
</ul>
<p>把这个特性直接封装到一个operation里去：</p><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">BackgroundTaskOperation</span><span class="p">:</span> <span class="n">Operation</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">whatToDo</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kd">var</span> <span class="nv">cleanup</span> <span class="p">:</span> <span class="p">(()</span> <span class="p">-&gt;</span> <span class="p">())?</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="kd">var</span> <span class="nv">bti</span> <span class="p">:</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="p">=</span> <span class="p">.</span><span class="n">invalid</span>
        <span class="n">bti</span> <span class="p">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">beginBackgroundTask</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cleanup</span><span class="p">?()</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// cancellation</span>
        <span class="p">}</span>
        <span class="k">guard</span> <span class="n">bti</span> <span class="o">!=</span> <span class="p">.</span><span class="n">invalid</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">whatToDo</span><span class="p">?()</span>
        <span class="k">guard</span> <span class="o">!</span><span class="kc">self</span><span class="p">.</span><span class="n">isCancelled</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="bp">UIApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">endBackgroundTask</span><span class="p">(</span><span class="n">bti</span><span class="p">)</span> <span class="c1">// completion</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 调用</span>
<span class="kd">let</span> <span class="nv">task</span> <span class="p">=</span> <span class="n">BackgroundTaskOperation</span><span class="p">()</span>
<span class="n">task</span><span class="p">.</span><span class="n">whatToDo</span> <span class="p">=</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="n">myQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
<p>这样，</p><ul>
<li>正常情况下会执行<code>whatToDo()</code></li>
<li>如果应用被挂到后台，因为注册过后台任务，有小于30秒的时间跑完任务</li>
<li>如果顺利跑完，你把应用切到前台，会发现UI已经更新了</li>
<li>超时也没跑完，就会进入超时的block里去取消任务了，UI上也得不到结果</li>
</ul>
<blockquote>
<p>最后，要知道所谓的申请时长，并不是在<em>didEnterBackground</em>之类的方法里去做的，而是做任务的时候就直接注册了，是不是很麻烦？</p></blockquote>
<h2>Background Processing</h2>
<p>相比向系统申请少得可怜的后台挂起时间，iOS 从13开始引入了后台任务机制，方便你执行一些用户不需要感知的任务，比如下载，或数据清理：</p><ul>
<li>路径：target &gt; Signing &amp; Capabilities &gt; Background processing</li>
<li>use <code>Background Task framework</code>, need to import <code>BackgroundTasks</code></li>
<li><em>Info.plist</em> &gt; add &quot;Permitted background task schedule identifiers&quot; key (<code>BTTaskSchedulerPermittedIdentifiers</code>), 任意标识字符串，比如反域名</li>
<li>在<code>appDelegate</code>里面去实现需要后台执行的方法</li>
</ul>
<p>涉及到两个类:</p><ul>
<li><code>BGProcessingTaskRequest</code><ul>
<li>在<code>didEnterBackground</code>方法里调用</li>
<li>需要match <em>plist.info</em>里的id</li>
<li>注册是否通电/有网/延迟执行（ExternalPower / Network / earliestBeginDate）</li>
</ul>
</li>
<li><code>BGTaskScheduler</code><ul>
<li><code>application(_:didFinishLaunchingWithOptions:)</code>里执行</li>
<li><code>register(forTaskWithIdentifier:using:launchHandler:)</code>方法<ul>
<li>id: matching plist.info</li>
<li>using: dispatch queue</li>
<li>handler: <code>BGTask</code> object</li>
</ul>
</li>
<li>在<code>BGTask</code>的超时方法里，和正常执行的代码里，均需调用<code>setTaskCompleted(_:bool)</code>方法</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">taskid</span> <span class="p">=</span> <span class="s">&quot;com.neuburg.matt.lengthy&quot;</span>
<span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">,</span>
    <span class="n">didFinishLaunchingWithOptions</span> <span class="n">launchOptions</span><span class="p">:</span>
    <span class="p">[</span><span class="bp">UIApplication</span><span class="p">.</span><span class="n">LaunchOptionsKey</span> <span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
<span class="p">}</span>
<span class="c1">// let v = MyView()</span>
<span class="kd">let</span> <span class="nv">ok</span> <span class="p">=</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">forTaskWithIdentifier</span><span class="p">:</span> <span class="n">taskid</span><span class="p">,</span>
    <span class="n">using</span><span class="p">:</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:</span> <span class="p">.</span><span class="n">background</span><span class="p">))</span> <span class="p">{</span> <span class="n">task</span> <span class="k">in</span>
        <span class="n">task</span><span class="p">.</span><span class="n">expirationHandler</span> <span class="p">=</span> <span class="p">{</span>
            <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//... my task logic</span>
        <span class="n">task</span><span class="p">.</span><span class="n">setTaskCompleted</span><span class="p">(</span><span class="n">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// might check `ok` here</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">applicationDidEnterBackground</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// might check to see whether it&#39;s time to submit this request</span>
    <span class="kd">let</span> <span class="nv">req</span> <span class="p">=</span> <span class="bp">BGProcessingTaskRequest</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">taskid</span><span class="p">)</span>
    <span class="k">try</span><span class="p">?</span> <span class="bp">BGTaskScheduler</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<h3>Debug</h3>
<ol>
<li>打满<em>print</em>和断点</li>
<li>设备上，把应用送到后台再拉到前台</li>
<li>Xcode上暂停app</li>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟launching<ul>
<li><code>(lldb) e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&quot;my_id&quot;]</code> 模拟超时</li>
</ul>
</li>
<li>控制台输入<code>continue</code>, 运行task function</li>
<li>当<code>task.setTaskComplete(success: true)</code> 被调用，控制台输出：“Marking simulated task complete,”</li>
</ol>
<h3>BGAppRefreshTaskRequest</h3>
<p>not mentioned</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/Thread-in-iOS/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">数据结构篇九：Indexed Priority Queue</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/" target="_self">
                <time class="text-uppercase">
                    November 17 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>这是一位 google 工程师分享的8小时的<a href="https://www.youtube.com/watch?v=RBSGKlAvoiM">数据结构</a>的视频,我的笔记</p><hr />
<h1>Indexed Priority Queue</h1>
<ul>
<li>a traditional priority queue variant</li>
<li>top node supports <code>quick update and deletions of key-value paris</code></li>
</ul>
<figure  style="flex: 77.8894472361809" ><img width="1240" height="796" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5e238bf5e89b7b2188cfb748c4e5990e.png" alt=""/></figure><p>观察这个图，数据是Anna, Bella...等等，</p><ul>
<li>首先，为这一堆数据进行任意排序，得到一堆索引(0,1,...)</li>
<li>然后组一个binary heap，这样每个元素又获得一个索引，就是在heap上的序号（<code>Position Map</code>）</li>
</ul>
<p>通过两组索引迅速找到key（就是人名）在堆中的位置，比如：</p><ul>
<li>George，ki = 6, pm = 1</li>
<li>kelly, ki = 10, pm = 10</li>
<li>...</li>
</ul>
<p>现在能迅速找到数据源在堆上的位置了，那么如果反过来呢？比如堆上索引3是数据源的谁？</p><ul>
<li>pm = 3 -&gt; ki = 8 -&gt; Issac <strong>BINGO!!!</strong></li>
</ul>
<p>但神奇的事发生了，有人希望复用ki这个自然数序列（闲的蛋疼？），于是多做了一个数组，把ki定义为heap上的索引，与元素原来的ki进行映射（<code>Inverse Map</code>）:IM
<figure  style="flex: 68.88888888888889" ><img width="1240" height="900" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/71be1add8c1a0cde72e08fc72adbd071.png" alt=""/></figure></p><p>可以看到，这张图上张个ki到im的映射，与pm到ki的映射其实是一样的，也就是说重定义了一下，并没有引入新的东西。(pm表里找到3，对应的第一行ki表里就是8）</p><p>这个时候，我们直接用ki的3就能找到im的8，继而找到数据源的<em>Issac</em>了。</p><h2>Insertion</h2>
<p>上面的数组，我们往里面添加第12条数据试试:</p><ul>
<li>{ki:12, pm: 12, im:12, value:2}</li>
<li>显然违反了binary heap的 invariant，向上冒泡，也就是跟{ki:12, pm:5, im:2, value:4}的节点互换</li>
<li>此时，数据源肯定不会变，但是节点变了，pm的值就要交换（5， 12 互换）</li>
<li>pm变了，把pm当成ki的映射表im也要变（12， 11互换）</li>
</ul>
<figure  style="flex: 224.63768115942028" ><img width="1240" height="276" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/47da2e700214e5e2de16aa42f5b92fb3.png" alt=""/></figure><p>仔细观察图片，搞清楚第一行ki在两次互换时的身份就明白了</p><ul>
<li>pm的互换是直观的，就是节点的位置</li>
<li>知道pm互换的依据后（2，5），在第一行找2，5对应的im值互换，因为在这个映射里，相当于pm与原ki的映射，pm此时是（2，5）了。</li>
</ul>
<p>同样逻辑继续冒泡就是了。</p><p>pseudo code:</p><div class="highlight"><pre><span></span><span class="c1"># Inserts a value into the min indexed binary </span>
<span class="c1"># heap. The key index must not already be in </span>
<span class="c1"># the heap and the value must not be null. </span>
<span class="n">function</span> <span class="n">insert</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># ‘sz’ is the current size of the heap</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz</span>  <span class="c1"># 对应上图，意思就第一行索引器是ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="n">ki</span>  <span class="c1"># 对应上图，意思就是一行索引器是pm</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span>     <span class="c1"># 这里传进去的pm，即heap上节点的索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 添加成功，size加1</span>
</pre></div>
<p>理论上，添加元素到最后一个, sz和ki应该是相等的（因为都是尾巴上）</p><div class="highlight"><pre><span></span><span class="c1"># Swims up node i (zero based) until heap </span>
<span class="c1"># invariant is satisfied.</span>
<span class="n">function</span> <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 比父节点小就冒泡，注意入参i是节点上的索引，即pm</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)):</span> 
        <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># 所以这里传的也是pm</span>
        <span class="n">i</span><span class="o">=</span><span class="n">p</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

<span class="n">function</span> <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> 
    <span class="c1"># 我们交换了节点，需要交换pm表里的值，和im表里的值</span>
    <span class="c1"># 交换pm的值需要数据源的索引，即ki，而ki能从im表里用pm算出来</span>
    <span class="c1"># 所以ki = im[pm] 这里i,j是pm，所以im[i]自然就是i对应ki</span>
    <span class="c1"># pm[ki]当然就是pm[im[i]]了：</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">pm</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
    <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">function</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">values</span><span class="p">[</span><span class="n">im</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
<p>还是那句话，理解清楚那三行映射表里第一行的动态含义，就不会有问题。</p><ul>
<li>pm表要key index来索引</li>
<li>im表要node index来索引</li>
</ul>
<p>在操作时，只需要知道传入的是哪种索引，及时转化就行了。</p><p>有了索引，lookup的时间复杂度就是常量时间了：O(1)</p><h2>Polling and Removals</h2>
<p>没有什么特殊的,仍然是找到节点,与最后一个交换,移除最后一个节点,然后再看最后一个在堆里是上升还是下降.
仍然是记得每一步交换,相应的几个索引值也需要随之交换.(polling 其实就是移除第1个节点,本质上还是 removal)
<figure class="vertical-figure" style="flex: 36.70811130846655" ><img width="1240" height="1689" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/581b8563020c36307eae7a9bf618a7e0.png" alt=""/></figure></p><p>pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Deletes the node with the key index ki</span>
<span class="c1"># in the heap. The key index ki must exist </span>
<span class="c1"># and be present in the heap.</span>
<span class="n">function</span> <span class="n">remove</span><span class="p">(</span><span class="n">ki</span><span class="p">):</span>
    <span class="c1"># 注意，这里送进来的是ki，而不是node index(pm)</span>
    <span class="c1"># 说明业务需求一般是操作数据源，而不是操作堆</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>    <span class="c1"># 转成节点索引</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># 与最后一个元素交换，用size来做节点索引</span>

    <span class="c1"># 下面三个子函数送入的就是节点索引了</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> 
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span>  <span class="c1"># 数据源对应的值置空，所以用ki</span>
    <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 数据源对应的节点置空，所以用ki</span>
    <span class="n">im</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>        <span class="c1"># 反查表用节点索引，此处size就是最后一个节点的索引</span>
</pre></div>
<p>sink pseudo code</p><div class="highlight"><pre><span></span><span class="c1"># Sinks the node at index i by swapping </span>
<span class="c1"># itself with the smallest of the left </span>
<span class="c1"># or the right child node.</span>
<span class="n">function</span> <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="c1"># 这是堆操作,传入的索引也是节点索引,没问题</span>
    <span class="c1"># sink是下沉，但不是跟BTS一样找左侧最大右则最小那种直接换</span>
    <span class="c1"># 而是一层层往下换</span>
    <span class="c1"># 即一次while只跟左右子级比大小，确实比子级还小的话，就替换，然后再跟下一层比较</span>
    <span class="k">while</span> <span class="n">true</span><span class="p">:</span>
        <span class="c1"># 利用二叉树特性算出子节点</span>
        <span class="c1"># 默认左边最小，然后再看右边是不是更小</span>
        <span class="n">left</span> <span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">left</span>
    <span class="c1"># 右边不越界，且小于左边，就设右边</span>
    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sz</span> <span class="ow">and</span> <span class="n">less</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="n">smallest</span> <span class="o">=</span> <span class="n">right</span>
    <span class="c1"># 左侧都越界了，或已经比最小值大了，说明不需要下沉了</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">sz</span> <span class="ow">or</span> <span class="n">less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">smallest</span><span class="p">):</span>
        <span class="k">break</span>
    <span class="c1"># 只要没有break，说明能交换，然后把交换后的作为下一个循环的起点</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">smallest</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">smallest</span>
</pre></div>
<h2>Updates</h2>
<p>更新节点要简单的多:</p><ul>
<li>用ki找到value，把值更新</li>
<li>然后根据新value实际情况上浮或下沉</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># Updates the value of a key in the binary </span>
<span class="c1"># heap. The key index must exist and the</span>
<span class="c1"># value must not be null.</span>
<span class="n">function</span> <span class="n">update</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span>
    <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">swim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
<h2>Decrease and Increase key</h2>
<p>不好说，先看代码吧：</p><div class="highlight"><pre><span></span><span class="c1"># For both these functions assume ki and value </span>
<span class="c1"># are valid inputs and we are dealing with a</span>
<span class="c1"># min indexed binary heap.</span>
<span class="n">function</span> <span class="n">decreaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]):</span> 
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">swim</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>

<span class="n">function</span> <span class="n">increaseKey</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">less</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">],</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> 
        <span class="n">sink</span><span class="p">(</span><span class="n">pm</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
</pre></div>
<p>代码里是跟一个固定值比较，只要ki对应的值比它大(desreaseKey)或小(increaseKey），就用这个固定值来替换它，并且在value改变后根据实际情况上浮或下沉。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E4%B9%9D%EF%BC%9AIndexed-Priority-Queue/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next text-muted">
                <span title="Viewing the first page."><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</span>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/2/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 AlanDecode</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>